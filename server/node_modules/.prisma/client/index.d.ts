
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model MasterItem
 * 
 */
export type MasterItem = $Result.DefaultSelection<Prisma.$MasterItemPayload>
/**
 * Model MasterTouch
 * 
 */
export type MasterTouch = $Result.DefaultSelection<Prisma.$MasterTouchPayload>
/**
 * Model masterWastage
 * 
 */
export type masterWastage = $Result.DefaultSelection<Prisma.$masterWastagePayload>
/**
 * Model mastercopper
 * 
 */
export type mastercopper = $Result.DefaultSelection<Prisma.$mastercopperPayload>
/**
 * Model JewelStock
 * 
 */
export type JewelStock = $Result.DefaultSelection<Prisma.$JewelStockPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Entry
 * 
 */
export type Entry = $Result.DefaultSelection<Prisma.$EntryPayload>
/**
 * Model customer_order
 * 
 */
export type customer_order = $Result.DefaultSelection<Prisma.$customer_orderPayload>
/**
 * Model product_multiple_images
 * 
 */
export type product_multiple_images = $Result.DefaultSelection<Prisma.$product_multiple_imagesPayload>
/**
 * Model MasterBullion
 * 
 */
export type MasterBullion = $Result.DefaultSelection<Prisma.$MasterBullionPayload>
/**
 * Model BullionPurchase
 * 
 */
export type BullionPurchase = $Result.DefaultSelection<Prisma.$BullionPurchasePayload>
/**
 * Model GivenDetail
 * 
 */
export type GivenDetail = $Result.DefaultSelection<Prisma.$GivenDetailPayload>
/**
 * Model Goldsmith
 * 
 */
export type Goldsmith = $Result.DefaultSelection<Prisma.$GoldsmithPayload>
/**
 * Model Jobcard
 * 
 */
export type Jobcard = $Result.DefaultSelection<Prisma.$JobcardPayload>
/**
 * Model givenGold
 * 
 */
export type givenGold = $Result.DefaultSelection<Prisma.$givenGoldPayload>
/**
 * Model itemDelivery
 * 
 */
export type itemDelivery = $Result.DefaultSelection<Prisma.$itemDeliveryPayload>
/**
 * Model deduction
 * 
 */
export type deduction = $Result.DefaultSelection<Prisma.$deductionPayload>
/**
 * Model Total
 * 
 */
export type Total = $Result.DefaultSelection<Prisma.$TotalPayload>
/**
 * Model Receivedsection
 * 
 */
export type Receivedsection = $Result.DefaultSelection<Prisma.$ReceivedsectionPayload>
/**
 * Model RawgoldStock
 * 
 */
export type RawgoldStock = $Result.DefaultSelection<Prisma.$RawgoldStockPayload>
/**
 * Model RawGoldLogs
 * 
 */
export type RawGoldLogs = $Result.DefaultSelection<Prisma.$RawGoldLogsPayload>
/**
 * Model ExpenseTracker
 * 
 */
export type ExpenseTracker = $Result.DefaultSelection<Prisma.$ExpenseTrackerPayload>
/**
 * Model Balances
 * 
 */
export type Balances = $Result.DefaultSelection<Prisma.$BalancesPayload>
/**
 * Model Repair
 * 
 */
export type Repair = $Result.DefaultSelection<Prisma.$RepairPayload>
/**
 * Model ProductStock
 * 
 */
export type ProductStock = $Result.DefaultSelection<Prisma.$ProductStockPayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model OrderItems
 * 
 */
export type OrderItems = $Result.DefaultSelection<Prisma.$OrderItemsPayload>
/**
 * Model billReceived
 * 
 */
export type billReceived = $Result.DefaultSelection<Prisma.$billReceivedPayload>
/**
 * Model receiptVoucher
 * 
 */
export type receiptVoucher = $Result.DefaultSelection<Prisma.$receiptVoucherPayload>
/**
 * Model customerBillBalance
 * 
 */
export type customerBillBalance = $Result.DefaultSelection<Prisma.$customerBillBalancePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WastageType: {
  PERCENTAGE: 'PERCENTAGE',
  ADDITION: 'ADDITION',
  TOUCH: 'TOUCH'
};

export type WastageType = (typeof WastageType)[keyof typeof WastageType]

}

export type WastageType = $Enums.WastageType

export const WastageType: typeof $Enums.WastageType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterItem`: Exposes CRUD operations for the **MasterItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterItems
    * const masterItems = await prisma.masterItem.findMany()
    * ```
    */
  get masterItem(): Prisma.MasterItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterTouch`: Exposes CRUD operations for the **MasterTouch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterTouches
    * const masterTouches = await prisma.masterTouch.findMany()
    * ```
    */
  get masterTouch(): Prisma.MasterTouchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterWastage`: Exposes CRUD operations for the **masterWastage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterWastages
    * const masterWastages = await prisma.masterWastage.findMany()
    * ```
    */
  get masterWastage(): Prisma.masterWastageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mastercopper`: Exposes CRUD operations for the **mastercopper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mastercoppers
    * const mastercoppers = await prisma.mastercopper.findMany()
    * ```
    */
  get mastercopper(): Prisma.mastercopperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jewelStock`: Exposes CRUD operations for the **JewelStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JewelStocks
    * const jewelStocks = await prisma.jewelStock.findMany()
    * ```
    */
  get jewelStock(): Prisma.JewelStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entry`: Exposes CRUD operations for the **Entry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entries
    * const entries = await prisma.entry.findMany()
    * ```
    */
  get entry(): Prisma.EntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer_order`: Exposes CRUD operations for the **customer_order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_orders
    * const customer_orders = await prisma.customer_order.findMany()
    * ```
    */
  get customer_order(): Prisma.customer_orderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product_multiple_images`: Exposes CRUD operations for the **product_multiple_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_multiple_images
    * const product_multiple_images = await prisma.product_multiple_images.findMany()
    * ```
    */
  get product_multiple_images(): Prisma.product_multiple_imagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterBullion`: Exposes CRUD operations for the **MasterBullion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterBullions
    * const masterBullions = await prisma.masterBullion.findMany()
    * ```
    */
  get masterBullion(): Prisma.MasterBullionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bullionPurchase`: Exposes CRUD operations for the **BullionPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BullionPurchases
    * const bullionPurchases = await prisma.bullionPurchase.findMany()
    * ```
    */
  get bullionPurchase(): Prisma.BullionPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.givenDetail`: Exposes CRUD operations for the **GivenDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GivenDetails
    * const givenDetails = await prisma.givenDetail.findMany()
    * ```
    */
  get givenDetail(): Prisma.GivenDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goldsmith`: Exposes CRUD operations for the **Goldsmith** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goldsmiths
    * const goldsmiths = await prisma.goldsmith.findMany()
    * ```
    */
  get goldsmith(): Prisma.GoldsmithDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobcard`: Exposes CRUD operations for the **Jobcard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobcards
    * const jobcards = await prisma.jobcard.findMany()
    * ```
    */
  get jobcard(): Prisma.JobcardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.givenGold`: Exposes CRUD operations for the **givenGold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GivenGolds
    * const givenGolds = await prisma.givenGold.findMany()
    * ```
    */
  get givenGold(): Prisma.givenGoldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemDelivery`: Exposes CRUD operations for the **itemDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemDeliveries
    * const itemDeliveries = await prisma.itemDelivery.findMany()
    * ```
    */
  get itemDelivery(): Prisma.itemDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deduction`: Exposes CRUD operations for the **deduction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deductions
    * const deductions = await prisma.deduction.findMany()
    * ```
    */
  get deduction(): Prisma.deductionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.total`: Exposes CRUD operations for the **Total** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Totals
    * const totals = await prisma.total.findMany()
    * ```
    */
  get total(): Prisma.TotalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receivedsection`: Exposes CRUD operations for the **Receivedsection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receivedsections
    * const receivedsections = await prisma.receivedsection.findMany()
    * ```
    */
  get receivedsection(): Prisma.ReceivedsectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rawgoldStock`: Exposes CRUD operations for the **RawgoldStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawgoldStocks
    * const rawgoldStocks = await prisma.rawgoldStock.findMany()
    * ```
    */
  get rawgoldStock(): Prisma.RawgoldStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rawGoldLogs`: Exposes CRUD operations for the **RawGoldLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawGoldLogs
    * const rawGoldLogs = await prisma.rawGoldLogs.findMany()
    * ```
    */
  get rawGoldLogs(): Prisma.RawGoldLogsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseTracker`: Exposes CRUD operations for the **ExpenseTracker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseTrackers
    * const expenseTrackers = await prisma.expenseTracker.findMany()
    * ```
    */
  get expenseTracker(): Prisma.ExpenseTrackerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balances`: Exposes CRUD operations for the **Balances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balances.findMany()
    * ```
    */
  get balances(): Prisma.BalancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.repair`: Exposes CRUD operations for the **Repair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repairs
    * const repairs = await prisma.repair.findMany()
    * ```
    */
  get repair(): Prisma.RepairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productStock`: Exposes CRUD operations for the **ProductStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStocks
    * const productStocks = await prisma.productStock.findMany()
    * ```
    */
  get productStock(): Prisma.ProductStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItems`: Exposes CRUD operations for the **OrderItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItems.findMany()
    * ```
    */
  get orderItems(): Prisma.OrderItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billReceived`: Exposes CRUD operations for the **billReceived** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillReceiveds
    * const billReceiveds = await prisma.billReceived.findMany()
    * ```
    */
  get billReceived(): Prisma.billReceivedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receiptVoucher`: Exposes CRUD operations for the **receiptVoucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceiptVouchers
    * const receiptVouchers = await prisma.receiptVoucher.findMany()
    * ```
    */
  get receiptVoucher(): Prisma.receiptVoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerBillBalance`: Exposes CRUD operations for the **customerBillBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerBillBalances
    * const customerBillBalances = await prisma.customerBillBalance.findMany()
    * ```
    */
  get customerBillBalance(): Prisma.customerBillBalanceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Customer: 'Customer',
    MasterItem: 'MasterItem',
    MasterTouch: 'MasterTouch',
    masterWastage: 'masterWastage',
    mastercopper: 'mastercopper',
    JewelStock: 'JewelStock',
    Transaction: 'Transaction',
    Entry: 'Entry',
    customer_order: 'customer_order',
    product_multiple_images: 'product_multiple_images',
    MasterBullion: 'MasterBullion',
    BullionPurchase: 'BullionPurchase',
    GivenDetail: 'GivenDetail',
    Goldsmith: 'Goldsmith',
    Jobcard: 'Jobcard',
    givenGold: 'givenGold',
    itemDelivery: 'itemDelivery',
    deduction: 'deduction',
    Total: 'Total',
    Receivedsection: 'Receivedsection',
    RawgoldStock: 'RawgoldStock',
    RawGoldLogs: 'RawGoldLogs',
    ExpenseTracker: 'ExpenseTracker',
    Balances: 'Balances',
    Repair: 'Repair',
    ProductStock: 'ProductStock',
    Bill: 'Bill',
    OrderItems: 'OrderItems',
    billReceived: 'billReceived',
    receiptVoucher: 'receiptVoucher',
    customerBillBalance: 'customerBillBalance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customer" | "masterItem" | "masterTouch" | "masterWastage" | "mastercopper" | "jewelStock" | "transaction" | "entry" | "customer_order" | "product_multiple_images" | "masterBullion" | "bullionPurchase" | "givenDetail" | "goldsmith" | "jobcard" | "givenGold" | "itemDelivery" | "deduction" | "total" | "receivedsection" | "rawgoldStock" | "rawGoldLogs" | "expenseTracker" | "balances" | "repair" | "productStock" | "bill" | "orderItems" | "billReceived" | "receiptVoucher" | "customerBillBalance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      MasterItem: {
        payload: Prisma.$MasterItemPayload<ExtArgs>
        fields: Prisma.MasterItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          findFirst: {
            args: Prisma.MasterItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          findMany: {
            args: Prisma.MasterItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>[]
          }
          create: {
            args: Prisma.MasterItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          createMany: {
            args: Prisma.MasterItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MasterItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          update: {
            args: Prisma.MasterItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          deleteMany: {
            args: Prisma.MasterItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MasterItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          aggregate: {
            args: Prisma.MasterItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterItem>
          }
          groupBy: {
            args: Prisma.MasterItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterItemCountArgs<ExtArgs>
            result: $Utils.Optional<MasterItemCountAggregateOutputType> | number
          }
        }
      }
      MasterTouch: {
        payload: Prisma.$MasterTouchPayload<ExtArgs>
        fields: Prisma.MasterTouchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterTouchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterTouchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          findFirst: {
            args: Prisma.MasterTouchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterTouchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          findMany: {
            args: Prisma.MasterTouchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>[]
          }
          create: {
            args: Prisma.MasterTouchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          createMany: {
            args: Prisma.MasterTouchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MasterTouchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          update: {
            args: Prisma.MasterTouchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          deleteMany: {
            args: Prisma.MasterTouchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterTouchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MasterTouchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          aggregate: {
            args: Prisma.MasterTouchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterTouch>
          }
          groupBy: {
            args: Prisma.MasterTouchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterTouchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterTouchCountArgs<ExtArgs>
            result: $Utils.Optional<MasterTouchCountAggregateOutputType> | number
          }
        }
      }
      masterWastage: {
        payload: Prisma.$masterWastagePayload<ExtArgs>
        fields: Prisma.masterWastageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.masterWastageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.masterWastageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload>
          }
          findFirst: {
            args: Prisma.masterWastageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.masterWastageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload>
          }
          findMany: {
            args: Prisma.masterWastageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload>[]
          }
          create: {
            args: Prisma.masterWastageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload>
          }
          createMany: {
            args: Prisma.masterWastageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.masterWastageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload>
          }
          update: {
            args: Prisma.masterWastageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload>
          }
          deleteMany: {
            args: Prisma.masterWastageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.masterWastageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.masterWastageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$masterWastagePayload>
          }
          aggregate: {
            args: Prisma.MasterWastageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterWastage>
          }
          groupBy: {
            args: Prisma.masterWastageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterWastageGroupByOutputType>[]
          }
          count: {
            args: Prisma.masterWastageCountArgs<ExtArgs>
            result: $Utils.Optional<MasterWastageCountAggregateOutputType> | number
          }
        }
      }
      mastercopper: {
        payload: Prisma.$mastercopperPayload<ExtArgs>
        fields: Prisma.mastercopperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mastercopperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mastercopperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload>
          }
          findFirst: {
            args: Prisma.mastercopperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mastercopperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload>
          }
          findMany: {
            args: Prisma.mastercopperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload>[]
          }
          create: {
            args: Prisma.mastercopperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload>
          }
          createMany: {
            args: Prisma.mastercopperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.mastercopperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload>
          }
          update: {
            args: Prisma.mastercopperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload>
          }
          deleteMany: {
            args: Prisma.mastercopperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mastercopperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mastercopperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mastercopperPayload>
          }
          aggregate: {
            args: Prisma.MastercopperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMastercopper>
          }
          groupBy: {
            args: Prisma.mastercopperGroupByArgs<ExtArgs>
            result: $Utils.Optional<MastercopperGroupByOutputType>[]
          }
          count: {
            args: Prisma.mastercopperCountArgs<ExtArgs>
            result: $Utils.Optional<MastercopperCountAggregateOutputType> | number
          }
        }
      }
      JewelStock: {
        payload: Prisma.$JewelStockPayload<ExtArgs>
        fields: Prisma.JewelStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JewelStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JewelStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          findFirst: {
            args: Prisma.JewelStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JewelStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          findMany: {
            args: Prisma.JewelStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>[]
          }
          create: {
            args: Prisma.JewelStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          createMany: {
            args: Prisma.JewelStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JewelStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          update: {
            args: Prisma.JewelStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          deleteMany: {
            args: Prisma.JewelStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JewelStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JewelStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          aggregate: {
            args: Prisma.JewelStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJewelStock>
          }
          groupBy: {
            args: Prisma.JewelStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<JewelStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.JewelStockCountArgs<ExtArgs>
            result: $Utils.Optional<JewelStockCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Entry: {
        payload: Prisma.$EntryPayload<ExtArgs>
        fields: Prisma.EntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          findFirst: {
            args: Prisma.EntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          findMany: {
            args: Prisma.EntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>[]
          }
          create: {
            args: Prisma.EntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          createMany: {
            args: Prisma.EntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          update: {
            args: Prisma.EntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          deleteMany: {
            args: Prisma.EntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          aggregate: {
            args: Prisma.EntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntry>
          }
          groupBy: {
            args: Prisma.EntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntryCountArgs<ExtArgs>
            result: $Utils.Optional<EntryCountAggregateOutputType> | number
          }
        }
      }
      customer_order: {
        payload: Prisma.$customer_orderPayload<ExtArgs>
        fields: Prisma.customer_orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customer_orderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customer_orderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          findFirst: {
            args: Prisma.customer_orderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customer_orderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          findMany: {
            args: Prisma.customer_orderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>[]
          }
          create: {
            args: Prisma.customer_orderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          createMany: {
            args: Prisma.customer_orderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customer_orderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          update: {
            args: Prisma.customer_orderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          deleteMany: {
            args: Prisma.customer_orderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customer_orderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customer_orderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          aggregate: {
            args: Prisma.Customer_orderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer_order>
          }
          groupBy: {
            args: Prisma.customer_orderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Customer_orderGroupByOutputType>[]
          }
          count: {
            args: Prisma.customer_orderCountArgs<ExtArgs>
            result: $Utils.Optional<Customer_orderCountAggregateOutputType> | number
          }
        }
      }
      product_multiple_images: {
        payload: Prisma.$product_multiple_imagesPayload<ExtArgs>
        fields: Prisma.product_multiple_imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_multiple_imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_multiple_imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          findFirst: {
            args: Prisma.product_multiple_imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_multiple_imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          findMany: {
            args: Prisma.product_multiple_imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>[]
          }
          create: {
            args: Prisma.product_multiple_imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          createMany: {
            args: Prisma.product_multiple_imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.product_multiple_imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          update: {
            args: Prisma.product_multiple_imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          deleteMany: {
            args: Prisma.product_multiple_imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.product_multiple_imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.product_multiple_imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          aggregate: {
            args: Prisma.Product_multiple_imagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct_multiple_images>
          }
          groupBy: {
            args: Prisma.product_multiple_imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Product_multiple_imagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_multiple_imagesCountArgs<ExtArgs>
            result: $Utils.Optional<Product_multiple_imagesCountAggregateOutputType> | number
          }
        }
      }
      MasterBullion: {
        payload: Prisma.$MasterBullionPayload<ExtArgs>
        fields: Prisma.MasterBullionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterBullionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterBullionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          findFirst: {
            args: Prisma.MasterBullionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterBullionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          findMany: {
            args: Prisma.MasterBullionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>[]
          }
          create: {
            args: Prisma.MasterBullionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          createMany: {
            args: Prisma.MasterBullionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MasterBullionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          update: {
            args: Prisma.MasterBullionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          deleteMany: {
            args: Prisma.MasterBullionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterBullionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MasterBullionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          aggregate: {
            args: Prisma.MasterBullionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterBullion>
          }
          groupBy: {
            args: Prisma.MasterBullionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterBullionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterBullionCountArgs<ExtArgs>
            result: $Utils.Optional<MasterBullionCountAggregateOutputType> | number
          }
        }
      }
      BullionPurchase: {
        payload: Prisma.$BullionPurchasePayload<ExtArgs>
        fields: Prisma.BullionPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BullionPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BullionPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          findFirst: {
            args: Prisma.BullionPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BullionPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          findMany: {
            args: Prisma.BullionPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>[]
          }
          create: {
            args: Prisma.BullionPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          createMany: {
            args: Prisma.BullionPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BullionPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          update: {
            args: Prisma.BullionPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          deleteMany: {
            args: Prisma.BullionPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BullionPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BullionPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          aggregate: {
            args: Prisma.BullionPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBullionPurchase>
          }
          groupBy: {
            args: Prisma.BullionPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BullionPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BullionPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<BullionPurchaseCountAggregateOutputType> | number
          }
        }
      }
      GivenDetail: {
        payload: Prisma.$GivenDetailPayload<ExtArgs>
        fields: Prisma.GivenDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GivenDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GivenDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          findFirst: {
            args: Prisma.GivenDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GivenDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          findMany: {
            args: Prisma.GivenDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>[]
          }
          create: {
            args: Prisma.GivenDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          createMany: {
            args: Prisma.GivenDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GivenDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          update: {
            args: Prisma.GivenDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          deleteMany: {
            args: Prisma.GivenDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GivenDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GivenDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          aggregate: {
            args: Prisma.GivenDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGivenDetail>
          }
          groupBy: {
            args: Prisma.GivenDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<GivenDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.GivenDetailCountArgs<ExtArgs>
            result: $Utils.Optional<GivenDetailCountAggregateOutputType> | number
          }
        }
      }
      Goldsmith: {
        payload: Prisma.$GoldsmithPayload<ExtArgs>
        fields: Prisma.GoldsmithFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoldsmithFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoldsmithFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          findFirst: {
            args: Prisma.GoldsmithFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoldsmithFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          findMany: {
            args: Prisma.GoldsmithFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>[]
          }
          create: {
            args: Prisma.GoldsmithCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          createMany: {
            args: Prisma.GoldsmithCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GoldsmithDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          update: {
            args: Prisma.GoldsmithUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          deleteMany: {
            args: Prisma.GoldsmithDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoldsmithUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoldsmithUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          aggregate: {
            args: Prisma.GoldsmithAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoldsmith>
          }
          groupBy: {
            args: Prisma.GoldsmithGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoldsmithGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoldsmithCountArgs<ExtArgs>
            result: $Utils.Optional<GoldsmithCountAggregateOutputType> | number
          }
        }
      }
      Jobcard: {
        payload: Prisma.$JobcardPayload<ExtArgs>
        fields: Prisma.JobcardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobcardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobcardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          findFirst: {
            args: Prisma.JobcardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobcardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          findMany: {
            args: Prisma.JobcardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>[]
          }
          create: {
            args: Prisma.JobcardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          createMany: {
            args: Prisma.JobcardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobcardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          update: {
            args: Prisma.JobcardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          deleteMany: {
            args: Prisma.JobcardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobcardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobcardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          aggregate: {
            args: Prisma.JobcardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobcard>
          }
          groupBy: {
            args: Prisma.JobcardGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobcardGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobcardCountArgs<ExtArgs>
            result: $Utils.Optional<JobcardCountAggregateOutputType> | number
          }
        }
      }
      givenGold: {
        payload: Prisma.$givenGoldPayload<ExtArgs>
        fields: Prisma.givenGoldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.givenGoldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.givenGoldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          findFirst: {
            args: Prisma.givenGoldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.givenGoldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          findMany: {
            args: Prisma.givenGoldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>[]
          }
          create: {
            args: Prisma.givenGoldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          createMany: {
            args: Prisma.givenGoldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.givenGoldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          update: {
            args: Prisma.givenGoldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          deleteMany: {
            args: Prisma.givenGoldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.givenGoldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.givenGoldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          aggregate: {
            args: Prisma.GivenGoldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGivenGold>
          }
          groupBy: {
            args: Prisma.givenGoldGroupByArgs<ExtArgs>
            result: $Utils.Optional<GivenGoldGroupByOutputType>[]
          }
          count: {
            args: Prisma.givenGoldCountArgs<ExtArgs>
            result: $Utils.Optional<GivenGoldCountAggregateOutputType> | number
          }
        }
      }
      itemDelivery: {
        payload: Prisma.$itemDeliveryPayload<ExtArgs>
        fields: Prisma.itemDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          findFirst: {
            args: Prisma.itemDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          findMany: {
            args: Prisma.itemDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>[]
          }
          create: {
            args: Prisma.itemDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          createMany: {
            args: Prisma.itemDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.itemDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          update: {
            args: Prisma.itemDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.itemDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.itemDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          aggregate: {
            args: Prisma.ItemDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemDelivery>
          }
          groupBy: {
            args: Prisma.itemDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemDeliveryCountAggregateOutputType> | number
          }
        }
      }
      deduction: {
        payload: Prisma.$deductionPayload<ExtArgs>
        fields: Prisma.deductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload>
          }
          findFirst: {
            args: Prisma.deductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload>
          }
          findMany: {
            args: Prisma.deductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload>[]
          }
          create: {
            args: Prisma.deductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload>
          }
          createMany: {
            args: Prisma.deductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.deductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload>
          }
          update: {
            args: Prisma.deductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload>
          }
          deleteMany: {
            args: Prisma.deductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.deductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionPayload>
          }
          aggregate: {
            args: Prisma.DeductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeduction>
          }
          groupBy: {
            args: Prisma.deductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.deductionCountArgs<ExtArgs>
            result: $Utils.Optional<DeductionCountAggregateOutputType> | number
          }
        }
      }
      Total: {
        payload: Prisma.$TotalPayload<ExtArgs>
        fields: Prisma.TotalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TotalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TotalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          findFirst: {
            args: Prisma.TotalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TotalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          findMany: {
            args: Prisma.TotalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>[]
          }
          create: {
            args: Prisma.TotalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          createMany: {
            args: Prisma.TotalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TotalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          update: {
            args: Prisma.TotalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          deleteMany: {
            args: Prisma.TotalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TotalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TotalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          aggregate: {
            args: Prisma.TotalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTotal>
          }
          groupBy: {
            args: Prisma.TotalGroupByArgs<ExtArgs>
            result: $Utils.Optional<TotalGroupByOutputType>[]
          }
          count: {
            args: Prisma.TotalCountArgs<ExtArgs>
            result: $Utils.Optional<TotalCountAggregateOutputType> | number
          }
        }
      }
      Receivedsection: {
        payload: Prisma.$ReceivedsectionPayload<ExtArgs>
        fields: Prisma.ReceivedsectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceivedsectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceivedsectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          findFirst: {
            args: Prisma.ReceivedsectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceivedsectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          findMany: {
            args: Prisma.ReceivedsectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>[]
          }
          create: {
            args: Prisma.ReceivedsectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          createMany: {
            args: Prisma.ReceivedsectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReceivedsectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          update: {
            args: Prisma.ReceivedsectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          deleteMany: {
            args: Prisma.ReceivedsectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceivedsectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceivedsectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          aggregate: {
            args: Prisma.ReceivedsectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceivedsection>
          }
          groupBy: {
            args: Prisma.ReceivedsectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceivedsectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceivedsectionCountArgs<ExtArgs>
            result: $Utils.Optional<ReceivedsectionCountAggregateOutputType> | number
          }
        }
      }
      RawgoldStock: {
        payload: Prisma.$RawgoldStockPayload<ExtArgs>
        fields: Prisma.RawgoldStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawgoldStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawgoldStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload>
          }
          findFirst: {
            args: Prisma.RawgoldStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawgoldStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload>
          }
          findMany: {
            args: Prisma.RawgoldStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload>[]
          }
          create: {
            args: Prisma.RawgoldStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload>
          }
          createMany: {
            args: Prisma.RawgoldStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RawgoldStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload>
          }
          update: {
            args: Prisma.RawgoldStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload>
          }
          deleteMany: {
            args: Prisma.RawgoldStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawgoldStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RawgoldStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawgoldStockPayload>
          }
          aggregate: {
            args: Prisma.RawgoldStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawgoldStock>
          }
          groupBy: {
            args: Prisma.RawgoldStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawgoldStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawgoldStockCountArgs<ExtArgs>
            result: $Utils.Optional<RawgoldStockCountAggregateOutputType> | number
          }
        }
      }
      RawGoldLogs: {
        payload: Prisma.$RawGoldLogsPayload<ExtArgs>
        fields: Prisma.RawGoldLogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawGoldLogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawGoldLogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload>
          }
          findFirst: {
            args: Prisma.RawGoldLogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawGoldLogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload>
          }
          findMany: {
            args: Prisma.RawGoldLogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload>[]
          }
          create: {
            args: Prisma.RawGoldLogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload>
          }
          createMany: {
            args: Prisma.RawGoldLogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RawGoldLogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload>
          }
          update: {
            args: Prisma.RawGoldLogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload>
          }
          deleteMany: {
            args: Prisma.RawGoldLogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawGoldLogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RawGoldLogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawGoldLogsPayload>
          }
          aggregate: {
            args: Prisma.RawGoldLogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawGoldLogs>
          }
          groupBy: {
            args: Prisma.RawGoldLogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawGoldLogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawGoldLogsCountArgs<ExtArgs>
            result: $Utils.Optional<RawGoldLogsCountAggregateOutputType> | number
          }
        }
      }
      ExpenseTracker: {
        payload: Prisma.$ExpenseTrackerPayload<ExtArgs>
        fields: Prisma.ExpenseTrackerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseTrackerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseTrackerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload>
          }
          findFirst: {
            args: Prisma.ExpenseTrackerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseTrackerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload>
          }
          findMany: {
            args: Prisma.ExpenseTrackerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload>[]
          }
          create: {
            args: Prisma.ExpenseTrackerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload>
          }
          createMany: {
            args: Prisma.ExpenseTrackerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExpenseTrackerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload>
          }
          update: {
            args: Prisma.ExpenseTrackerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseTrackerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseTrackerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseTrackerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseTrackerPayload>
          }
          aggregate: {
            args: Prisma.ExpenseTrackerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseTracker>
          }
          groupBy: {
            args: Prisma.ExpenseTrackerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseTrackerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseTrackerCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseTrackerCountAggregateOutputType> | number
          }
        }
      }
      Balances: {
        payload: Prisma.$BalancesPayload<ExtArgs>
        fields: Prisma.BalancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          findFirst: {
            args: Prisma.BalancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          findMany: {
            args: Prisma.BalancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>[]
          }
          create: {
            args: Prisma.BalancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          createMany: {
            args: Prisma.BalancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BalancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          update: {
            args: Prisma.BalancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          deleteMany: {
            args: Prisma.BalancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BalancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          aggregate: {
            args: Prisma.BalancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalances>
          }
          groupBy: {
            args: Prisma.BalancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalancesCountArgs<ExtArgs>
            result: $Utils.Optional<BalancesCountAggregateOutputType> | number
          }
        }
      }
      Repair: {
        payload: Prisma.$RepairPayload<ExtArgs>
        fields: Prisma.RepairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          findFirst: {
            args: Prisma.RepairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          findMany: {
            args: Prisma.RepairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>[]
          }
          create: {
            args: Prisma.RepairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          createMany: {
            args: Prisma.RepairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RepairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          update: {
            args: Prisma.RepairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          deleteMany: {
            args: Prisma.RepairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          aggregate: {
            args: Prisma.RepairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepair>
          }
          groupBy: {
            args: Prisma.RepairGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepairGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepairCountArgs<ExtArgs>
            result: $Utils.Optional<RepairCountAggregateOutputType> | number
          }
        }
      }
      ProductStock: {
        payload: Prisma.$ProductStockPayload<ExtArgs>
        fields: Prisma.ProductStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findFirst: {
            args: Prisma.ProductStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findMany: {
            args: Prisma.ProductStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          create: {
            args: Prisma.ProductStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          createMany: {
            args: Prisma.ProductStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          update: {
            args: Prisma.ProductStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          deleteMany: {
            args: Prisma.ProductStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          aggregate: {
            args: Prisma.ProductStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStock>
          }
          groupBy: {
            args: Prisma.ProductStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStockCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStockCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      OrderItems: {
        payload: Prisma.$OrderItemsPayload<ExtArgs>
        fields: Prisma.OrderItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          findFirst: {
            args: Prisma.OrderItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          findMany: {
            args: Prisma.OrderItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>[]
          }
          create: {
            args: Prisma.OrderItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          createMany: {
            args: Prisma.OrderItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          update: {
            args: Prisma.OrderItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          aggregate: {
            args: Prisma.OrderItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItems>
          }
          groupBy: {
            args: Prisma.OrderItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemsCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemsCountAggregateOutputType> | number
          }
        }
      }
      billReceived: {
        payload: Prisma.$billReceivedPayload<ExtArgs>
        fields: Prisma.billReceivedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.billReceivedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.billReceivedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload>
          }
          findFirst: {
            args: Prisma.billReceivedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.billReceivedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload>
          }
          findMany: {
            args: Prisma.billReceivedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload>[]
          }
          create: {
            args: Prisma.billReceivedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload>
          }
          createMany: {
            args: Prisma.billReceivedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.billReceivedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload>
          }
          update: {
            args: Prisma.billReceivedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload>
          }
          deleteMany: {
            args: Prisma.billReceivedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.billReceivedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.billReceivedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billReceivedPayload>
          }
          aggregate: {
            args: Prisma.BillReceivedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillReceived>
          }
          groupBy: {
            args: Prisma.billReceivedGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillReceivedGroupByOutputType>[]
          }
          count: {
            args: Prisma.billReceivedCountArgs<ExtArgs>
            result: $Utils.Optional<BillReceivedCountAggregateOutputType> | number
          }
        }
      }
      receiptVoucher: {
        payload: Prisma.$receiptVoucherPayload<ExtArgs>
        fields: Prisma.receiptVoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.receiptVoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.receiptVoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload>
          }
          findFirst: {
            args: Prisma.receiptVoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.receiptVoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload>
          }
          findMany: {
            args: Prisma.receiptVoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload>[]
          }
          create: {
            args: Prisma.receiptVoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload>
          }
          createMany: {
            args: Prisma.receiptVoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.receiptVoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload>
          }
          update: {
            args: Prisma.receiptVoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload>
          }
          deleteMany: {
            args: Prisma.receiptVoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.receiptVoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.receiptVoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptVoucherPayload>
          }
          aggregate: {
            args: Prisma.ReceiptVoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceiptVoucher>
          }
          groupBy: {
            args: Prisma.receiptVoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptVoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.receiptVoucherCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptVoucherCountAggregateOutputType> | number
          }
        }
      }
      customerBillBalance: {
        payload: Prisma.$customerBillBalancePayload<ExtArgs>
        fields: Prisma.customerBillBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerBillBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerBillBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload>
          }
          findFirst: {
            args: Prisma.customerBillBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerBillBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload>
          }
          findMany: {
            args: Prisma.customerBillBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload>[]
          }
          create: {
            args: Prisma.customerBillBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload>
          }
          createMany: {
            args: Prisma.customerBillBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customerBillBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload>
          }
          update: {
            args: Prisma.customerBillBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload>
          }
          deleteMany: {
            args: Prisma.customerBillBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerBillBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customerBillBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerBillBalancePayload>
          }
          aggregate: {
            args: Prisma.CustomerBillBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerBillBalance>
          }
          groupBy: {
            args: Prisma.customerBillBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerBillBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerBillBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerBillBalanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customer?: CustomerOmit
    masterItem?: MasterItemOmit
    masterTouch?: MasterTouchOmit
    masterWastage?: masterWastageOmit
    mastercopper?: mastercopperOmit
    jewelStock?: JewelStockOmit
    transaction?: TransactionOmit
    entry?: EntryOmit
    customer_order?: customer_orderOmit
    product_multiple_images?: product_multiple_imagesOmit
    masterBullion?: MasterBullionOmit
    bullionPurchase?: BullionPurchaseOmit
    givenDetail?: GivenDetailOmit
    goldsmith?: GoldsmithOmit
    jobcard?: JobcardOmit
    givenGold?: givenGoldOmit
    itemDelivery?: itemDeliveryOmit
    deduction?: deductionOmit
    total?: TotalOmit
    receivedsection?: ReceivedsectionOmit
    rawgoldStock?: RawgoldStockOmit
    rawGoldLogs?: RawGoldLogsOmit
    expenseTracker?: ExpenseTrackerOmit
    balances?: BalancesOmit
    repair?: RepairOmit
    productStock?: ProductStockOmit
    bill?: BillOmit
    orderItems?: OrderItemsOmit
    billReceived?: billReceivedOmit
    receiptVoucher?: receiptVoucherOmit
    customerBillBalance?: customerBillBalanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    transactions: number
    customerOrders: number
    bill: number
    billReceive: number
    receiptVoucher: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
    customerOrders?: boolean | CustomerCountOutputTypeCountCustomerOrdersArgs
    bill?: boolean | CustomerCountOutputTypeCountBillArgs
    billReceive?: boolean | CustomerCountOutputTypeCountBillReceiveArgs
    receiptVoucher?: boolean | CustomerCountOutputTypeCountReceiptVoucherArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_orderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountBillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountBillReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billReceivedWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReceiptVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: receiptVoucherWhereInput
  }


  /**
   * Count Type MasterTouchCountOutputType
   */

  export type MasterTouchCountOutputType = {
    rawGoldStock: number
  }

  export type MasterTouchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawGoldStock?: boolean | MasterTouchCountOutputTypeCountRawGoldStockArgs
  }

  // Custom InputTypes
  /**
   * MasterTouchCountOutputType without action
   */
  export type MasterTouchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouchCountOutputType
     */
    select?: MasterTouchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MasterTouchCountOutputType without action
   */
  export type MasterTouchCountOutputTypeCountRawGoldStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawgoldStockWhereInput
  }


  /**
   * Count Type Customer_orderCountOutputType
   */

  export type Customer_orderCountOutputType = {
    productImages: number
  }

  export type Customer_orderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productImages?: boolean | Customer_orderCountOutputTypeCountProductImagesArgs
  }

  // Custom InputTypes
  /**
   * Customer_orderCountOutputType without action
   */
  export type Customer_orderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_orderCountOutputType
     */
    select?: Customer_orderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Customer_orderCountOutputType without action
   */
  export type Customer_orderCountOutputTypeCountProductImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_multiple_imagesWhereInput
  }


  /**
   * Count Type MasterBullionCountOutputType
   */

  export type MasterBullionCountOutputType = {
    purchases: number
  }

  export type MasterBullionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | MasterBullionCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * MasterBullionCountOutputType without action
   */
  export type MasterBullionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullionCountOutputType
     */
    select?: MasterBullionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MasterBullionCountOutputType without action
   */
  export type MasterBullionCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BullionPurchaseWhereInput
  }


  /**
   * Count Type BullionPurchaseCountOutputType
   */

  export type BullionPurchaseCountOutputType = {
    givenDetails: number
  }

  export type BullionPurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givenDetails?: boolean | BullionPurchaseCountOutputTypeCountGivenDetailsArgs
  }

  // Custom InputTypes
  /**
   * BullionPurchaseCountOutputType without action
   */
  export type BullionPurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchaseCountOutputType
     */
    select?: BullionPurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BullionPurchaseCountOutputType without action
   */
  export type BullionPurchaseCountOutputTypeCountGivenDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GivenDetailWhereInput
  }


  /**
   * Count Type GoldsmithCountOutputType
   */

  export type GoldsmithCountOutputType = {
    jobcards: number
    givenGold: number
    deliveries: number
    received: number
    totals: number
    repairs: number
    summaries: number
  }

  export type GoldsmithCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobcards?: boolean | GoldsmithCountOutputTypeCountJobcardsArgs
    givenGold?: boolean | GoldsmithCountOutputTypeCountGivenGoldArgs
    deliveries?: boolean | GoldsmithCountOutputTypeCountDeliveriesArgs
    received?: boolean | GoldsmithCountOutputTypeCountReceivedArgs
    totals?: boolean | GoldsmithCountOutputTypeCountTotalsArgs
    repairs?: boolean | GoldsmithCountOutputTypeCountRepairsArgs
    summaries?: boolean | GoldsmithCountOutputTypeCountSummariesArgs
  }

  // Custom InputTypes
  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoldsmithCountOutputType
     */
    select?: GoldsmithCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountJobcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobcardWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountGivenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: givenGoldWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemDeliveryWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivedsectionWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountTotalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TotalWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountRepairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalancesWhereInput
  }


  /**
   * Count Type JobcardCountOutputType
   */

  export type JobcardCountOutputType = {
    givenGold: number
    deliveries: number
    received: number
    productStock: number
    total: number
  }

  export type JobcardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givenGold?: boolean | JobcardCountOutputTypeCountGivenGoldArgs
    deliveries?: boolean | JobcardCountOutputTypeCountDeliveriesArgs
    received?: boolean | JobcardCountOutputTypeCountReceivedArgs
    productStock?: boolean | JobcardCountOutputTypeCountProductStockArgs
    total?: boolean | JobcardCountOutputTypeCountTotalArgs
  }

  // Custom InputTypes
  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobcardCountOutputType
     */
    select?: JobcardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountGivenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: givenGoldWhereInput
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemDeliveryWhereInput
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivedsectionWhereInput
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountProductStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountTotalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TotalWhereInput
  }


  /**
   * Count Type ItemDeliveryCountOutputType
   */

  export type ItemDeliveryCountOutputType = {
    deduction: number
  }

  export type ItemDeliveryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deduction?: boolean | ItemDeliveryCountOutputTypeCountDeductionArgs
  }

  // Custom InputTypes
  /**
   * ItemDeliveryCountOutputType without action
   */
  export type ItemDeliveryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemDeliveryCountOutputType
     */
    select?: ItemDeliveryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemDeliveryCountOutputType without action
   */
  export type ItemDeliveryCountOutputTypeCountDeductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deductionWhereInput
  }


  /**
   * Count Type RawgoldStockCountOutputType
   */

  export type RawgoldStockCountOutputType = {
    rawGoldLogs: number
  }

  export type RawgoldStockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawGoldLogs?: boolean | RawgoldStockCountOutputTypeCountRawGoldLogsArgs
  }

  // Custom InputTypes
  /**
   * RawgoldStockCountOutputType without action
   */
  export type RawgoldStockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStockCountOutputType
     */
    select?: RawgoldStockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RawgoldStockCountOutputType without action
   */
  export type RawgoldStockCountOutputTypeCountRawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawGoldLogsWhereInput
  }


  /**
   * Count Type RawGoldLogsCountOutputType
   */

  export type RawGoldLogsCountOutputType = {
    givenGold: number
    receivedSections: number
    billReceive: number
    receiptVoucher: number
    transactions: number
    expenseTracker: number
  }

  export type RawGoldLogsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givenGold?: boolean | RawGoldLogsCountOutputTypeCountGivenGoldArgs
    receivedSections?: boolean | RawGoldLogsCountOutputTypeCountReceivedSectionsArgs
    billReceive?: boolean | RawGoldLogsCountOutputTypeCountBillReceiveArgs
    receiptVoucher?: boolean | RawGoldLogsCountOutputTypeCountReceiptVoucherArgs
    transactions?: boolean | RawGoldLogsCountOutputTypeCountTransactionsArgs
    expenseTracker?: boolean | RawGoldLogsCountOutputTypeCountExpenseTrackerArgs
  }

  // Custom InputTypes
  /**
   * RawGoldLogsCountOutputType without action
   */
  export type RawGoldLogsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogsCountOutputType
     */
    select?: RawGoldLogsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RawGoldLogsCountOutputType without action
   */
  export type RawGoldLogsCountOutputTypeCountGivenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: givenGoldWhereInput
  }

  /**
   * RawGoldLogsCountOutputType without action
   */
  export type RawGoldLogsCountOutputTypeCountReceivedSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivedsectionWhereInput
  }

  /**
   * RawGoldLogsCountOutputType without action
   */
  export type RawGoldLogsCountOutputTypeCountBillReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billReceivedWhereInput
  }

  /**
   * RawGoldLogsCountOutputType without action
   */
  export type RawGoldLogsCountOutputTypeCountReceiptVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: receiptVoucherWhereInput
  }

  /**
   * RawGoldLogsCountOutputType without action
   */
  export type RawGoldLogsCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * RawGoldLogsCountOutputType without action
   */
  export type RawGoldLogsCountOutputTypeCountExpenseTrackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseTrackerWhereInput
  }


  /**
   * Count Type BillCountOutputType
   */

  export type BillCountOutputType = {
    orders: number
    billReceive: number
  }

  export type BillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | BillCountOutputTypeCountOrdersArgs
    billReceive?: boolean | BillCountOutputTypeCountBillReceiveArgs
  }

  // Custom InputTypes
  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillCountOutputType
     */
    select?: BillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountBillReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billReceivedWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "createdAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    createdAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    address: string | null
    createdAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    customerOrders?: boolean | Customer$customerOrdersArgs<ExtArgs>
    bill?: boolean | Customer$billArgs<ExtArgs>
    billReceive?: boolean | Customer$billReceiveArgs<ExtArgs>
    receiptVoucher?: boolean | Customer$receiptVoucherArgs<ExtArgs>
    customerBillBalance?: boolean | Customer$customerBillBalanceArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "address" | "createdAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    customerOrders?: boolean | Customer$customerOrdersArgs<ExtArgs>
    bill?: boolean | Customer$billArgs<ExtArgs>
    billReceive?: boolean | Customer$billReceiveArgs<ExtArgs>
    receiptVoucher?: boolean | Customer$receiptVoucherArgs<ExtArgs>
    customerBillBalance?: boolean | Customer$customerBillBalanceArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      customerOrders: Prisma.$customer_orderPayload<ExtArgs>[]
      bill: Prisma.$BillPayload<ExtArgs>[]
      billReceive: Prisma.$billReceivedPayload<ExtArgs>[]
      receiptVoucher: Prisma.$receiptVoucherPayload<ExtArgs>[]
      customerBillBalance: Prisma.$customerBillBalancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      address: string | null
      createdAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerOrders<T extends Customer$customerOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bill<T extends Customer$billArgs<ExtArgs> = {}>(args?: Subset<T, Customer$billArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billReceive<T extends Customer$billReceiveArgs<ExtArgs> = {}>(args?: Subset<T, Customer$billReceiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receiptVoucher<T extends Customer$receiptVoucherArgs<ExtArgs> = {}>(args?: Subset<T, Customer$receiptVoucherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerBillBalance<T extends Customer$customerBillBalanceArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerBillBalanceArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Customer.customerOrders
   */
  export type Customer$customerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    where?: customer_orderWhereInput
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    cursor?: customer_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * Customer.bill
   */
  export type Customer$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Customer.billReceive
   */
  export type Customer$billReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    where?: billReceivedWhereInput
    orderBy?: billReceivedOrderByWithRelationInput | billReceivedOrderByWithRelationInput[]
    cursor?: billReceivedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillReceivedScalarFieldEnum | BillReceivedScalarFieldEnum[]
  }

  /**
   * Customer.receiptVoucher
   */
  export type Customer$receiptVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    where?: receiptVoucherWhereInput
    orderBy?: receiptVoucherOrderByWithRelationInput | receiptVoucherOrderByWithRelationInput[]
    cursor?: receiptVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptVoucherScalarFieldEnum | ReceiptVoucherScalarFieldEnum[]
  }

  /**
   * Customer.customerBillBalance
   */
  export type Customer$customerBillBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    where?: customerBillBalanceWhereInput
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model MasterItem
   */

  export type AggregateMasterItem = {
    _count: MasterItemCountAggregateOutputType | null
    _avg: MasterItemAvgAggregateOutputType | null
    _sum: MasterItemSumAggregateOutputType | null
    _min: MasterItemMinAggregateOutputType | null
    _max: MasterItemMaxAggregateOutputType | null
  }

  export type MasterItemAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterItemSumAggregateOutputType = {
    id: number | null
  }

  export type MasterItemMinAggregateOutputType = {
    id: number | null
    itemName: string | null
    createdAt: Date | null
  }

  export type MasterItemMaxAggregateOutputType = {
    id: number | null
    itemName: string | null
    createdAt: Date | null
  }

  export type MasterItemCountAggregateOutputType = {
    id: number
    itemName: number
    createdAt: number
    _all: number
  }


  export type MasterItemAvgAggregateInputType = {
    id?: true
  }

  export type MasterItemSumAggregateInputType = {
    id?: true
  }

  export type MasterItemMinAggregateInputType = {
    id?: true
    itemName?: true
    createdAt?: true
  }

  export type MasterItemMaxAggregateInputType = {
    id?: true
    itemName?: true
    createdAt?: true
  }

  export type MasterItemCountAggregateInputType = {
    id?: true
    itemName?: true
    createdAt?: true
    _all?: true
  }

  export type MasterItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterItem to aggregate.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterItems
    **/
    _count?: true | MasterItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterItemMaxAggregateInputType
  }

  export type GetMasterItemAggregateType<T extends MasterItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterItem[P]>
      : GetScalarType<T[P], AggregateMasterItem[P]>
  }




  export type MasterItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterItemWhereInput
    orderBy?: MasterItemOrderByWithAggregationInput | MasterItemOrderByWithAggregationInput[]
    by: MasterItemScalarFieldEnum[] | MasterItemScalarFieldEnum
    having?: MasterItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterItemCountAggregateInputType | true
    _avg?: MasterItemAvgAggregateInputType
    _sum?: MasterItemSumAggregateInputType
    _min?: MasterItemMinAggregateInputType
    _max?: MasterItemMaxAggregateInputType
  }

  export type MasterItemGroupByOutputType = {
    id: number
    itemName: string
    createdAt: Date
    _count: MasterItemCountAggregateOutputType | null
    _avg: MasterItemAvgAggregateOutputType | null
    _sum: MasterItemSumAggregateOutputType | null
    _min: MasterItemMinAggregateOutputType | null
    _max: MasterItemMaxAggregateOutputType | null
  }

  type GetMasterItemGroupByPayload<T extends MasterItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterItemGroupByOutputType[P]>
            : GetScalarType<T[P], MasterItemGroupByOutputType[P]>
        }
      >
    >


  export type MasterItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["masterItem"]>



  export type MasterItemSelectScalar = {
    id?: boolean
    itemName?: boolean
    createdAt?: boolean
  }

  export type MasterItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemName" | "createdAt", ExtArgs["result"]["masterItem"]>

  export type $MasterItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemName: string
      createdAt: Date
    }, ExtArgs["result"]["masterItem"]>
    composites: {}
  }

  type MasterItemGetPayload<S extends boolean | null | undefined | MasterItemDefaultArgs> = $Result.GetResult<Prisma.$MasterItemPayload, S>

  type MasterItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterItemCountAggregateInputType | true
    }

  export interface MasterItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterItem'], meta: { name: 'MasterItem' } }
    /**
     * Find zero or one MasterItem that matches the filter.
     * @param {MasterItemFindUniqueArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterItemFindUniqueArgs>(args: SelectSubset<T, MasterItemFindUniqueArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterItemFindUniqueOrThrowArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemFindFirstArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterItemFindFirstArgs>(args?: SelectSubset<T, MasterItemFindFirstArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemFindFirstOrThrowArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterItems
     * const masterItems = await prisma.masterItem.findMany()
     * 
     * // Get first 10 MasterItems
     * const masterItems = await prisma.masterItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterItemWithIdOnly = await prisma.masterItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterItemFindManyArgs>(args?: SelectSubset<T, MasterItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterItem.
     * @param {MasterItemCreateArgs} args - Arguments to create a MasterItem.
     * @example
     * // Create one MasterItem
     * const MasterItem = await prisma.masterItem.create({
     *   data: {
     *     // ... data to create a MasterItem
     *   }
     * })
     * 
     */
    create<T extends MasterItemCreateArgs>(args: SelectSubset<T, MasterItemCreateArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterItems.
     * @param {MasterItemCreateManyArgs} args - Arguments to create many MasterItems.
     * @example
     * // Create many MasterItems
     * const masterItem = await prisma.masterItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterItemCreateManyArgs>(args?: SelectSubset<T, MasterItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterItem.
     * @param {MasterItemDeleteArgs} args - Arguments to delete one MasterItem.
     * @example
     * // Delete one MasterItem
     * const MasterItem = await prisma.masterItem.delete({
     *   where: {
     *     // ... filter to delete one MasterItem
     *   }
     * })
     * 
     */
    delete<T extends MasterItemDeleteArgs>(args: SelectSubset<T, MasterItemDeleteArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterItem.
     * @param {MasterItemUpdateArgs} args - Arguments to update one MasterItem.
     * @example
     * // Update one MasterItem
     * const masterItem = await prisma.masterItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterItemUpdateArgs>(args: SelectSubset<T, MasterItemUpdateArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterItems.
     * @param {MasterItemDeleteManyArgs} args - Arguments to filter MasterItems to delete.
     * @example
     * // Delete a few MasterItems
     * const { count } = await prisma.masterItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterItemDeleteManyArgs>(args?: SelectSubset<T, MasterItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterItems
     * const masterItem = await prisma.masterItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterItemUpdateManyArgs>(args: SelectSubset<T, MasterItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterItem.
     * @param {MasterItemUpsertArgs} args - Arguments to update or create a MasterItem.
     * @example
     * // Update or create a MasterItem
     * const masterItem = await prisma.masterItem.upsert({
     *   create: {
     *     // ... data to create a MasterItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterItem we want to update
     *   }
     * })
     */
    upsert<T extends MasterItemUpsertArgs>(args: SelectSubset<T, MasterItemUpsertArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemCountArgs} args - Arguments to filter MasterItems to count.
     * @example
     * // Count the number of MasterItems
     * const count = await prisma.masterItem.count({
     *   where: {
     *     // ... the filter for the MasterItems we want to count
     *   }
     * })
    **/
    count<T extends MasterItemCountArgs>(
      args?: Subset<T, MasterItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterItemAggregateArgs>(args: Subset<T, MasterItemAggregateArgs>): Prisma.PrismaPromise<GetMasterItemAggregateType<T>>

    /**
     * Group by MasterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterItemGroupByArgs['orderBy'] }
        : { orderBy?: MasterItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterItem model
   */
  readonly fields: MasterItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterItem model
   */
  interface MasterItemFieldRefs {
    readonly id: FieldRef<"MasterItem", 'Int'>
    readonly itemName: FieldRef<"MasterItem", 'String'>
    readonly createdAt: FieldRef<"MasterItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MasterItem findUnique
   */
  export type MasterItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem findUniqueOrThrow
   */
  export type MasterItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem findFirst
   */
  export type MasterItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterItems.
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterItems.
     */
    distinct?: MasterItemScalarFieldEnum | MasterItemScalarFieldEnum[]
  }

  /**
   * MasterItem findFirstOrThrow
   */
  export type MasterItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterItems.
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterItems.
     */
    distinct?: MasterItemScalarFieldEnum | MasterItemScalarFieldEnum[]
  }

  /**
   * MasterItem findMany
   */
  export type MasterItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItems to fetch.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterItems.
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    distinct?: MasterItemScalarFieldEnum | MasterItemScalarFieldEnum[]
  }

  /**
   * MasterItem create
   */
  export type MasterItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * The data needed to create a MasterItem.
     */
    data: XOR<MasterItemCreateInput, MasterItemUncheckedCreateInput>
  }

  /**
   * MasterItem createMany
   */
  export type MasterItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterItems.
     */
    data: MasterItemCreateManyInput | MasterItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterItem update
   */
  export type MasterItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * The data needed to update a MasterItem.
     */
    data: XOR<MasterItemUpdateInput, MasterItemUncheckedUpdateInput>
    /**
     * Choose, which MasterItem to update.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem updateMany
   */
  export type MasterItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterItems.
     */
    data: XOR<MasterItemUpdateManyMutationInput, MasterItemUncheckedUpdateManyInput>
    /**
     * Filter which MasterItems to update
     */
    where?: MasterItemWhereInput
    /**
     * Limit how many MasterItems to update.
     */
    limit?: number
  }

  /**
   * MasterItem upsert
   */
  export type MasterItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * The filter to search for the MasterItem to update in case it exists.
     */
    where: MasterItemWhereUniqueInput
    /**
     * In case the MasterItem found by the `where` argument doesn't exist, create a new MasterItem with this data.
     */
    create: XOR<MasterItemCreateInput, MasterItemUncheckedCreateInput>
    /**
     * In case the MasterItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterItemUpdateInput, MasterItemUncheckedUpdateInput>
  }

  /**
   * MasterItem delete
   */
  export type MasterItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter which MasterItem to delete.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem deleteMany
   */
  export type MasterItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterItems to delete
     */
    where?: MasterItemWhereInput
    /**
     * Limit how many MasterItems to delete.
     */
    limit?: number
  }

  /**
   * MasterItem without action
   */
  export type MasterItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
  }


  /**
   * Model MasterTouch
   */

  export type AggregateMasterTouch = {
    _count: MasterTouchCountAggregateOutputType | null
    _avg: MasterTouchAvgAggregateOutputType | null
    _sum: MasterTouchSumAggregateOutputType | null
    _min: MasterTouchMinAggregateOutputType | null
    _max: MasterTouchMaxAggregateOutputType | null
  }

  export type MasterTouchAvgAggregateOutputType = {
    id: number | null
    touch: number | null
  }

  export type MasterTouchSumAggregateOutputType = {
    id: number | null
    touch: number | null
  }

  export type MasterTouchMinAggregateOutputType = {
    id: number | null
    touch: number | null
    createdAt: Date | null
  }

  export type MasterTouchMaxAggregateOutputType = {
    id: number | null
    touch: number | null
    createdAt: Date | null
  }

  export type MasterTouchCountAggregateOutputType = {
    id: number
    touch: number
    createdAt: number
    _all: number
  }


  export type MasterTouchAvgAggregateInputType = {
    id?: true
    touch?: true
  }

  export type MasterTouchSumAggregateInputType = {
    id?: true
    touch?: true
  }

  export type MasterTouchMinAggregateInputType = {
    id?: true
    touch?: true
    createdAt?: true
  }

  export type MasterTouchMaxAggregateInputType = {
    id?: true
    touch?: true
    createdAt?: true
  }

  export type MasterTouchCountAggregateInputType = {
    id?: true
    touch?: true
    createdAt?: true
    _all?: true
  }

  export type MasterTouchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterTouch to aggregate.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterTouches
    **/
    _count?: true | MasterTouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterTouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterTouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterTouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterTouchMaxAggregateInputType
  }

  export type GetMasterTouchAggregateType<T extends MasterTouchAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterTouch[P]>
      : GetScalarType<T[P], AggregateMasterTouch[P]>
  }




  export type MasterTouchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterTouchWhereInput
    orderBy?: MasterTouchOrderByWithAggregationInput | MasterTouchOrderByWithAggregationInput[]
    by: MasterTouchScalarFieldEnum[] | MasterTouchScalarFieldEnum
    having?: MasterTouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterTouchCountAggregateInputType | true
    _avg?: MasterTouchAvgAggregateInputType
    _sum?: MasterTouchSumAggregateInputType
    _min?: MasterTouchMinAggregateInputType
    _max?: MasterTouchMaxAggregateInputType
  }

  export type MasterTouchGroupByOutputType = {
    id: number
    touch: number
    createdAt: Date
    _count: MasterTouchCountAggregateOutputType | null
    _avg: MasterTouchAvgAggregateOutputType | null
    _sum: MasterTouchSumAggregateOutputType | null
    _min: MasterTouchMinAggregateOutputType | null
    _max: MasterTouchMaxAggregateOutputType | null
  }

  type GetMasterTouchGroupByPayload<T extends MasterTouchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterTouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterTouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterTouchGroupByOutputType[P]>
            : GetScalarType<T[P], MasterTouchGroupByOutputType[P]>
        }
      >
    >


  export type MasterTouchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    touch?: boolean
    createdAt?: boolean
    rawGoldStock?: boolean | MasterTouch$rawGoldStockArgs<ExtArgs>
    _count?: boolean | MasterTouchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterTouch"]>



  export type MasterTouchSelectScalar = {
    id?: boolean
    touch?: boolean
    createdAt?: boolean
  }

  export type MasterTouchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "touch" | "createdAt", ExtArgs["result"]["masterTouch"]>
  export type MasterTouchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawGoldStock?: boolean | MasterTouch$rawGoldStockArgs<ExtArgs>
    _count?: boolean | MasterTouchCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MasterTouchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterTouch"
    objects: {
      rawGoldStock: Prisma.$RawgoldStockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      touch: number
      createdAt: Date
    }, ExtArgs["result"]["masterTouch"]>
    composites: {}
  }

  type MasterTouchGetPayload<S extends boolean | null | undefined | MasterTouchDefaultArgs> = $Result.GetResult<Prisma.$MasterTouchPayload, S>

  type MasterTouchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterTouchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterTouchCountAggregateInputType | true
    }

  export interface MasterTouchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterTouch'], meta: { name: 'MasterTouch' } }
    /**
     * Find zero or one MasterTouch that matches the filter.
     * @param {MasterTouchFindUniqueArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterTouchFindUniqueArgs>(args: SelectSubset<T, MasterTouchFindUniqueArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterTouch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterTouchFindUniqueOrThrowArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterTouchFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterTouchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterTouch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchFindFirstArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterTouchFindFirstArgs>(args?: SelectSubset<T, MasterTouchFindFirstArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterTouch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchFindFirstOrThrowArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterTouchFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterTouchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterTouches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterTouches
     * const masterTouches = await prisma.masterTouch.findMany()
     * 
     * // Get first 10 MasterTouches
     * const masterTouches = await prisma.masterTouch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterTouchWithIdOnly = await prisma.masterTouch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterTouchFindManyArgs>(args?: SelectSubset<T, MasterTouchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterTouch.
     * @param {MasterTouchCreateArgs} args - Arguments to create a MasterTouch.
     * @example
     * // Create one MasterTouch
     * const MasterTouch = await prisma.masterTouch.create({
     *   data: {
     *     // ... data to create a MasterTouch
     *   }
     * })
     * 
     */
    create<T extends MasterTouchCreateArgs>(args: SelectSubset<T, MasterTouchCreateArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterTouches.
     * @param {MasterTouchCreateManyArgs} args - Arguments to create many MasterTouches.
     * @example
     * // Create many MasterTouches
     * const masterTouch = await prisma.masterTouch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterTouchCreateManyArgs>(args?: SelectSubset<T, MasterTouchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterTouch.
     * @param {MasterTouchDeleteArgs} args - Arguments to delete one MasterTouch.
     * @example
     * // Delete one MasterTouch
     * const MasterTouch = await prisma.masterTouch.delete({
     *   where: {
     *     // ... filter to delete one MasterTouch
     *   }
     * })
     * 
     */
    delete<T extends MasterTouchDeleteArgs>(args: SelectSubset<T, MasterTouchDeleteArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterTouch.
     * @param {MasterTouchUpdateArgs} args - Arguments to update one MasterTouch.
     * @example
     * // Update one MasterTouch
     * const masterTouch = await prisma.masterTouch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterTouchUpdateArgs>(args: SelectSubset<T, MasterTouchUpdateArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterTouches.
     * @param {MasterTouchDeleteManyArgs} args - Arguments to filter MasterTouches to delete.
     * @example
     * // Delete a few MasterTouches
     * const { count } = await prisma.masterTouch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterTouchDeleteManyArgs>(args?: SelectSubset<T, MasterTouchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterTouches
     * const masterTouch = await prisma.masterTouch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterTouchUpdateManyArgs>(args: SelectSubset<T, MasterTouchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterTouch.
     * @param {MasterTouchUpsertArgs} args - Arguments to update or create a MasterTouch.
     * @example
     * // Update or create a MasterTouch
     * const masterTouch = await prisma.masterTouch.upsert({
     *   create: {
     *     // ... data to create a MasterTouch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterTouch we want to update
     *   }
     * })
     */
    upsert<T extends MasterTouchUpsertArgs>(args: SelectSubset<T, MasterTouchUpsertArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchCountArgs} args - Arguments to filter MasterTouches to count.
     * @example
     * // Count the number of MasterTouches
     * const count = await prisma.masterTouch.count({
     *   where: {
     *     // ... the filter for the MasterTouches we want to count
     *   }
     * })
    **/
    count<T extends MasterTouchCountArgs>(
      args?: Subset<T, MasterTouchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterTouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterTouchAggregateArgs>(args: Subset<T, MasterTouchAggregateArgs>): Prisma.PrismaPromise<GetMasterTouchAggregateType<T>>

    /**
     * Group by MasterTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterTouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterTouchGroupByArgs['orderBy'] }
        : { orderBy?: MasterTouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterTouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterTouchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterTouch model
   */
  readonly fields: MasterTouchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterTouch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterTouchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawGoldStock<T extends MasterTouch$rawGoldStockArgs<ExtArgs> = {}>(args?: Subset<T, MasterTouch$rawGoldStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterTouch model
   */
  interface MasterTouchFieldRefs {
    readonly id: FieldRef<"MasterTouch", 'Int'>
    readonly touch: FieldRef<"MasterTouch", 'Float'>
    readonly createdAt: FieldRef<"MasterTouch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MasterTouch findUnique
   */
  export type MasterTouchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch findUniqueOrThrow
   */
  export type MasterTouchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch findFirst
   */
  export type MasterTouchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterTouches.
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterTouches.
     */
    distinct?: MasterTouchScalarFieldEnum | MasterTouchScalarFieldEnum[]
  }

  /**
   * MasterTouch findFirstOrThrow
   */
  export type MasterTouchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterTouches.
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterTouches.
     */
    distinct?: MasterTouchScalarFieldEnum | MasterTouchScalarFieldEnum[]
  }

  /**
   * MasterTouch findMany
   */
  export type MasterTouchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * Filter, which MasterTouches to fetch.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterTouches.
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    distinct?: MasterTouchScalarFieldEnum | MasterTouchScalarFieldEnum[]
  }

  /**
   * MasterTouch create
   */
  export type MasterTouchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * The data needed to create a MasterTouch.
     */
    data: XOR<MasterTouchCreateInput, MasterTouchUncheckedCreateInput>
  }

  /**
   * MasterTouch createMany
   */
  export type MasterTouchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterTouches.
     */
    data: MasterTouchCreateManyInput | MasterTouchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterTouch update
   */
  export type MasterTouchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * The data needed to update a MasterTouch.
     */
    data: XOR<MasterTouchUpdateInput, MasterTouchUncheckedUpdateInput>
    /**
     * Choose, which MasterTouch to update.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch updateMany
   */
  export type MasterTouchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterTouches.
     */
    data: XOR<MasterTouchUpdateManyMutationInput, MasterTouchUncheckedUpdateManyInput>
    /**
     * Filter which MasterTouches to update
     */
    where?: MasterTouchWhereInput
    /**
     * Limit how many MasterTouches to update.
     */
    limit?: number
  }

  /**
   * MasterTouch upsert
   */
  export type MasterTouchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * The filter to search for the MasterTouch to update in case it exists.
     */
    where: MasterTouchWhereUniqueInput
    /**
     * In case the MasterTouch found by the `where` argument doesn't exist, create a new MasterTouch with this data.
     */
    create: XOR<MasterTouchCreateInput, MasterTouchUncheckedCreateInput>
    /**
     * In case the MasterTouch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterTouchUpdateInput, MasterTouchUncheckedUpdateInput>
  }

  /**
   * MasterTouch delete
   */
  export type MasterTouchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    /**
     * Filter which MasterTouch to delete.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch deleteMany
   */
  export type MasterTouchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterTouches to delete
     */
    where?: MasterTouchWhereInput
    /**
     * Limit how many MasterTouches to delete.
     */
    limit?: number
  }

  /**
   * MasterTouch.rawGoldStock
   */
  export type MasterTouch$rawGoldStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    where?: RawgoldStockWhereInput
    orderBy?: RawgoldStockOrderByWithRelationInput | RawgoldStockOrderByWithRelationInput[]
    cursor?: RawgoldStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawgoldStockScalarFieldEnum | RawgoldStockScalarFieldEnum[]
  }

  /**
   * MasterTouch without action
   */
  export type MasterTouchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
  }


  /**
   * Model masterWastage
   */

  export type AggregateMasterWastage = {
    _count: MasterWastageCountAggregateOutputType | null
    _avg: MasterWastageAvgAggregateOutputType | null
    _sum: MasterWastageSumAggregateOutputType | null
    _min: MasterWastageMinAggregateOutputType | null
    _max: MasterWastageMaxAggregateOutputType | null
  }

  export type MasterWastageAvgAggregateOutputType = {
    id: number | null
    wastage: number | null
  }

  export type MasterWastageSumAggregateOutputType = {
    id: number | null
    wastage: number | null
  }

  export type MasterWastageMinAggregateOutputType = {
    id: number | null
    wastage: number | null
    createdAt: Date | null
  }

  export type MasterWastageMaxAggregateOutputType = {
    id: number | null
    wastage: number | null
    createdAt: Date | null
  }

  export type MasterWastageCountAggregateOutputType = {
    id: number
    wastage: number
    createdAt: number
    _all: number
  }


  export type MasterWastageAvgAggregateInputType = {
    id?: true
    wastage?: true
  }

  export type MasterWastageSumAggregateInputType = {
    id?: true
    wastage?: true
  }

  export type MasterWastageMinAggregateInputType = {
    id?: true
    wastage?: true
    createdAt?: true
  }

  export type MasterWastageMaxAggregateInputType = {
    id?: true
    wastage?: true
    createdAt?: true
  }

  export type MasterWastageCountAggregateInputType = {
    id?: true
    wastage?: true
    createdAt?: true
    _all?: true
  }

  export type MasterWastageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which masterWastage to aggregate.
     */
    where?: masterWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of masterWastages to fetch.
     */
    orderBy?: masterWastageOrderByWithRelationInput | masterWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: masterWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` masterWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` masterWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned masterWastages
    **/
    _count?: true | MasterWastageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterWastageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterWastageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterWastageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterWastageMaxAggregateInputType
  }

  export type GetMasterWastageAggregateType<T extends MasterWastageAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterWastage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterWastage[P]>
      : GetScalarType<T[P], AggregateMasterWastage[P]>
  }




  export type masterWastageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: masterWastageWhereInput
    orderBy?: masterWastageOrderByWithAggregationInput | masterWastageOrderByWithAggregationInput[]
    by: MasterWastageScalarFieldEnum[] | MasterWastageScalarFieldEnum
    having?: masterWastageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterWastageCountAggregateInputType | true
    _avg?: MasterWastageAvgAggregateInputType
    _sum?: MasterWastageSumAggregateInputType
    _min?: MasterWastageMinAggregateInputType
    _max?: MasterWastageMaxAggregateInputType
  }

  export type MasterWastageGroupByOutputType = {
    id: number
    wastage: number
    createdAt: Date
    _count: MasterWastageCountAggregateOutputType | null
    _avg: MasterWastageAvgAggregateOutputType | null
    _sum: MasterWastageSumAggregateOutputType | null
    _min: MasterWastageMinAggregateOutputType | null
    _max: MasterWastageMaxAggregateOutputType | null
  }

  type GetMasterWastageGroupByPayload<T extends masterWastageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterWastageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterWastageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterWastageGroupByOutputType[P]>
            : GetScalarType<T[P], MasterWastageGroupByOutputType[P]>
        }
      >
    >


  export type masterWastageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wastage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["masterWastage"]>



  export type masterWastageSelectScalar = {
    id?: boolean
    wastage?: boolean
    createdAt?: boolean
  }

  export type masterWastageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wastage" | "createdAt", ExtArgs["result"]["masterWastage"]>

  export type $masterWastagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "masterWastage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wastage: number
      createdAt: Date
    }, ExtArgs["result"]["masterWastage"]>
    composites: {}
  }

  type masterWastageGetPayload<S extends boolean | null | undefined | masterWastageDefaultArgs> = $Result.GetResult<Prisma.$masterWastagePayload, S>

  type masterWastageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<masterWastageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterWastageCountAggregateInputType | true
    }

  export interface masterWastageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['masterWastage'], meta: { name: 'masterWastage' } }
    /**
     * Find zero or one MasterWastage that matches the filter.
     * @param {masterWastageFindUniqueArgs} args - Arguments to find a MasterWastage
     * @example
     * // Get one MasterWastage
     * const masterWastage = await prisma.masterWastage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends masterWastageFindUniqueArgs>(args: SelectSubset<T, masterWastageFindUniqueArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterWastage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {masterWastageFindUniqueOrThrowArgs} args - Arguments to find a MasterWastage
     * @example
     * // Get one MasterWastage
     * const masterWastage = await prisma.masterWastage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends masterWastageFindUniqueOrThrowArgs>(args: SelectSubset<T, masterWastageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterWastage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {masterWastageFindFirstArgs} args - Arguments to find a MasterWastage
     * @example
     * // Get one MasterWastage
     * const masterWastage = await prisma.masterWastage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends masterWastageFindFirstArgs>(args?: SelectSubset<T, masterWastageFindFirstArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterWastage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {masterWastageFindFirstOrThrowArgs} args - Arguments to find a MasterWastage
     * @example
     * // Get one MasterWastage
     * const masterWastage = await prisma.masterWastage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends masterWastageFindFirstOrThrowArgs>(args?: SelectSubset<T, masterWastageFindFirstOrThrowArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterWastages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {masterWastageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterWastages
     * const masterWastages = await prisma.masterWastage.findMany()
     * 
     * // Get first 10 MasterWastages
     * const masterWastages = await prisma.masterWastage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterWastageWithIdOnly = await prisma.masterWastage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends masterWastageFindManyArgs>(args?: SelectSubset<T, masterWastageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterWastage.
     * @param {masterWastageCreateArgs} args - Arguments to create a MasterWastage.
     * @example
     * // Create one MasterWastage
     * const MasterWastage = await prisma.masterWastage.create({
     *   data: {
     *     // ... data to create a MasterWastage
     *   }
     * })
     * 
     */
    create<T extends masterWastageCreateArgs>(args: SelectSubset<T, masterWastageCreateArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterWastages.
     * @param {masterWastageCreateManyArgs} args - Arguments to create many MasterWastages.
     * @example
     * // Create many MasterWastages
     * const masterWastage = await prisma.masterWastage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends masterWastageCreateManyArgs>(args?: SelectSubset<T, masterWastageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterWastage.
     * @param {masterWastageDeleteArgs} args - Arguments to delete one MasterWastage.
     * @example
     * // Delete one MasterWastage
     * const MasterWastage = await prisma.masterWastage.delete({
     *   where: {
     *     // ... filter to delete one MasterWastage
     *   }
     * })
     * 
     */
    delete<T extends masterWastageDeleteArgs>(args: SelectSubset<T, masterWastageDeleteArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterWastage.
     * @param {masterWastageUpdateArgs} args - Arguments to update one MasterWastage.
     * @example
     * // Update one MasterWastage
     * const masterWastage = await prisma.masterWastage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends masterWastageUpdateArgs>(args: SelectSubset<T, masterWastageUpdateArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterWastages.
     * @param {masterWastageDeleteManyArgs} args - Arguments to filter MasterWastages to delete.
     * @example
     * // Delete a few MasterWastages
     * const { count } = await prisma.masterWastage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends masterWastageDeleteManyArgs>(args?: SelectSubset<T, masterWastageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {masterWastageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterWastages
     * const masterWastage = await prisma.masterWastage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends masterWastageUpdateManyArgs>(args: SelectSubset<T, masterWastageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterWastage.
     * @param {masterWastageUpsertArgs} args - Arguments to update or create a MasterWastage.
     * @example
     * // Update or create a MasterWastage
     * const masterWastage = await prisma.masterWastage.upsert({
     *   create: {
     *     // ... data to create a MasterWastage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterWastage we want to update
     *   }
     * })
     */
    upsert<T extends masterWastageUpsertArgs>(args: SelectSubset<T, masterWastageUpsertArgs<ExtArgs>>): Prisma__masterWastageClient<$Result.GetResult<Prisma.$masterWastagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {masterWastageCountArgs} args - Arguments to filter MasterWastages to count.
     * @example
     * // Count the number of MasterWastages
     * const count = await prisma.masterWastage.count({
     *   where: {
     *     // ... the filter for the MasterWastages we want to count
     *   }
     * })
    **/
    count<T extends masterWastageCountArgs>(
      args?: Subset<T, masterWastageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterWastageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterWastageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterWastageAggregateArgs>(args: Subset<T, MasterWastageAggregateArgs>): Prisma.PrismaPromise<GetMasterWastageAggregateType<T>>

    /**
     * Group by MasterWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {masterWastageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends masterWastageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: masterWastageGroupByArgs['orderBy'] }
        : { orderBy?: masterWastageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, masterWastageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterWastageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the masterWastage model
   */
  readonly fields: masterWastageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for masterWastage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__masterWastageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the masterWastage model
   */
  interface masterWastageFieldRefs {
    readonly id: FieldRef<"masterWastage", 'Int'>
    readonly wastage: FieldRef<"masterWastage", 'Float'>
    readonly createdAt: FieldRef<"masterWastage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * masterWastage findUnique
   */
  export type masterWastageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * Filter, which masterWastage to fetch.
     */
    where: masterWastageWhereUniqueInput
  }

  /**
   * masterWastage findUniqueOrThrow
   */
  export type masterWastageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * Filter, which masterWastage to fetch.
     */
    where: masterWastageWhereUniqueInput
  }

  /**
   * masterWastage findFirst
   */
  export type masterWastageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * Filter, which masterWastage to fetch.
     */
    where?: masterWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of masterWastages to fetch.
     */
    orderBy?: masterWastageOrderByWithRelationInput | masterWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for masterWastages.
     */
    cursor?: masterWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` masterWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` masterWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of masterWastages.
     */
    distinct?: MasterWastageScalarFieldEnum | MasterWastageScalarFieldEnum[]
  }

  /**
   * masterWastage findFirstOrThrow
   */
  export type masterWastageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * Filter, which masterWastage to fetch.
     */
    where?: masterWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of masterWastages to fetch.
     */
    orderBy?: masterWastageOrderByWithRelationInput | masterWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for masterWastages.
     */
    cursor?: masterWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` masterWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` masterWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of masterWastages.
     */
    distinct?: MasterWastageScalarFieldEnum | MasterWastageScalarFieldEnum[]
  }

  /**
   * masterWastage findMany
   */
  export type masterWastageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * Filter, which masterWastages to fetch.
     */
    where?: masterWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of masterWastages to fetch.
     */
    orderBy?: masterWastageOrderByWithRelationInput | masterWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing masterWastages.
     */
    cursor?: masterWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` masterWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` masterWastages.
     */
    skip?: number
    distinct?: MasterWastageScalarFieldEnum | MasterWastageScalarFieldEnum[]
  }

  /**
   * masterWastage create
   */
  export type masterWastageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * The data needed to create a masterWastage.
     */
    data: XOR<masterWastageCreateInput, masterWastageUncheckedCreateInput>
  }

  /**
   * masterWastage createMany
   */
  export type masterWastageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many masterWastages.
     */
    data: masterWastageCreateManyInput | masterWastageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * masterWastage update
   */
  export type masterWastageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * The data needed to update a masterWastage.
     */
    data: XOR<masterWastageUpdateInput, masterWastageUncheckedUpdateInput>
    /**
     * Choose, which masterWastage to update.
     */
    where: masterWastageWhereUniqueInput
  }

  /**
   * masterWastage updateMany
   */
  export type masterWastageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update masterWastages.
     */
    data: XOR<masterWastageUpdateManyMutationInput, masterWastageUncheckedUpdateManyInput>
    /**
     * Filter which masterWastages to update
     */
    where?: masterWastageWhereInput
    /**
     * Limit how many masterWastages to update.
     */
    limit?: number
  }

  /**
   * masterWastage upsert
   */
  export type masterWastageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * The filter to search for the masterWastage to update in case it exists.
     */
    where: masterWastageWhereUniqueInput
    /**
     * In case the masterWastage found by the `where` argument doesn't exist, create a new masterWastage with this data.
     */
    create: XOR<masterWastageCreateInput, masterWastageUncheckedCreateInput>
    /**
     * In case the masterWastage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<masterWastageUpdateInput, masterWastageUncheckedUpdateInput>
  }

  /**
   * masterWastage delete
   */
  export type masterWastageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
    /**
     * Filter which masterWastage to delete.
     */
    where: masterWastageWhereUniqueInput
  }

  /**
   * masterWastage deleteMany
   */
  export type masterWastageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which masterWastages to delete
     */
    where?: masterWastageWhereInput
    /**
     * Limit how many masterWastages to delete.
     */
    limit?: number
  }

  /**
   * masterWastage without action
   */
  export type masterWastageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the masterWastage
     */
    select?: masterWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the masterWastage
     */
    omit?: masterWastageOmit<ExtArgs> | null
  }


  /**
   * Model mastercopper
   */

  export type AggregateMastercopper = {
    _count: MastercopperCountAggregateOutputType | null
    _avg: MastercopperAvgAggregateOutputType | null
    _sum: MastercopperSumAggregateOutputType | null
    _min: MastercopperMinAggregateOutputType | null
    _max: MastercopperMaxAggregateOutputType | null
  }

  export type MastercopperAvgAggregateOutputType = {
    id: number | null
    copperTotal: number | null
    remainCopper: number | null
  }

  export type MastercopperSumAggregateOutputType = {
    id: number | null
    copperTotal: number | null
    remainCopper: number | null
  }

  export type MastercopperMinAggregateOutputType = {
    id: number | null
    copperTotal: number | null
    remainCopper: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MastercopperMaxAggregateOutputType = {
    id: number | null
    copperTotal: number | null
    remainCopper: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MastercopperCountAggregateOutputType = {
    id: number
    copperTotal: number
    remainCopper: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MastercopperAvgAggregateInputType = {
    id?: true
    copperTotal?: true
    remainCopper?: true
  }

  export type MastercopperSumAggregateInputType = {
    id?: true
    copperTotal?: true
    remainCopper?: true
  }

  export type MastercopperMinAggregateInputType = {
    id?: true
    copperTotal?: true
    remainCopper?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MastercopperMaxAggregateInputType = {
    id?: true
    copperTotal?: true
    remainCopper?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MastercopperCountAggregateInputType = {
    id?: true
    copperTotal?: true
    remainCopper?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MastercopperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mastercopper to aggregate.
     */
    where?: mastercopperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mastercoppers to fetch.
     */
    orderBy?: mastercopperOrderByWithRelationInput | mastercopperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mastercopperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mastercoppers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mastercoppers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mastercoppers
    **/
    _count?: true | MastercopperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MastercopperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MastercopperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MastercopperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MastercopperMaxAggregateInputType
  }

  export type GetMastercopperAggregateType<T extends MastercopperAggregateArgs> = {
        [P in keyof T & keyof AggregateMastercopper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMastercopper[P]>
      : GetScalarType<T[P], AggregateMastercopper[P]>
  }




  export type mastercopperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mastercopperWhereInput
    orderBy?: mastercopperOrderByWithAggregationInput | mastercopperOrderByWithAggregationInput[]
    by: MastercopperScalarFieldEnum[] | MastercopperScalarFieldEnum
    having?: mastercopperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MastercopperCountAggregateInputType | true
    _avg?: MastercopperAvgAggregateInputType
    _sum?: MastercopperSumAggregateInputType
    _min?: MastercopperMinAggregateInputType
    _max?: MastercopperMaxAggregateInputType
  }

  export type MastercopperGroupByOutputType = {
    id: number
    copperTotal: number
    remainCopper: number
    createdAt: Date
    updatedAt: Date
    _count: MastercopperCountAggregateOutputType | null
    _avg: MastercopperAvgAggregateOutputType | null
    _sum: MastercopperSumAggregateOutputType | null
    _min: MastercopperMinAggregateOutputType | null
    _max: MastercopperMaxAggregateOutputType | null
  }

  type GetMastercopperGroupByPayload<T extends mastercopperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MastercopperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MastercopperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MastercopperGroupByOutputType[P]>
            : GetScalarType<T[P], MastercopperGroupByOutputType[P]>
        }
      >
    >


  export type mastercopperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    copperTotal?: boolean
    remainCopper?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mastercopper"]>



  export type mastercopperSelectScalar = {
    id?: boolean
    copperTotal?: boolean
    remainCopper?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type mastercopperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "copperTotal" | "remainCopper" | "createdAt" | "updatedAt", ExtArgs["result"]["mastercopper"]>

  export type $mastercopperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mastercopper"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      copperTotal: number
      remainCopper: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mastercopper"]>
    composites: {}
  }

  type mastercopperGetPayload<S extends boolean | null | undefined | mastercopperDefaultArgs> = $Result.GetResult<Prisma.$mastercopperPayload, S>

  type mastercopperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mastercopperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MastercopperCountAggregateInputType | true
    }

  export interface mastercopperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mastercopper'], meta: { name: 'mastercopper' } }
    /**
     * Find zero or one Mastercopper that matches the filter.
     * @param {mastercopperFindUniqueArgs} args - Arguments to find a Mastercopper
     * @example
     * // Get one Mastercopper
     * const mastercopper = await prisma.mastercopper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mastercopperFindUniqueArgs>(args: SelectSubset<T, mastercopperFindUniqueArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mastercopper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mastercopperFindUniqueOrThrowArgs} args - Arguments to find a Mastercopper
     * @example
     * // Get one Mastercopper
     * const mastercopper = await prisma.mastercopper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mastercopperFindUniqueOrThrowArgs>(args: SelectSubset<T, mastercopperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mastercopper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mastercopperFindFirstArgs} args - Arguments to find a Mastercopper
     * @example
     * // Get one Mastercopper
     * const mastercopper = await prisma.mastercopper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mastercopperFindFirstArgs>(args?: SelectSubset<T, mastercopperFindFirstArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mastercopper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mastercopperFindFirstOrThrowArgs} args - Arguments to find a Mastercopper
     * @example
     * // Get one Mastercopper
     * const mastercopper = await prisma.mastercopper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mastercopperFindFirstOrThrowArgs>(args?: SelectSubset<T, mastercopperFindFirstOrThrowArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mastercoppers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mastercopperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mastercoppers
     * const mastercoppers = await prisma.mastercopper.findMany()
     * 
     * // Get first 10 Mastercoppers
     * const mastercoppers = await prisma.mastercopper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mastercopperWithIdOnly = await prisma.mastercopper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mastercopperFindManyArgs>(args?: SelectSubset<T, mastercopperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mastercopper.
     * @param {mastercopperCreateArgs} args - Arguments to create a Mastercopper.
     * @example
     * // Create one Mastercopper
     * const Mastercopper = await prisma.mastercopper.create({
     *   data: {
     *     // ... data to create a Mastercopper
     *   }
     * })
     * 
     */
    create<T extends mastercopperCreateArgs>(args: SelectSubset<T, mastercopperCreateArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mastercoppers.
     * @param {mastercopperCreateManyArgs} args - Arguments to create many Mastercoppers.
     * @example
     * // Create many Mastercoppers
     * const mastercopper = await prisma.mastercopper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mastercopperCreateManyArgs>(args?: SelectSubset<T, mastercopperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mastercopper.
     * @param {mastercopperDeleteArgs} args - Arguments to delete one Mastercopper.
     * @example
     * // Delete one Mastercopper
     * const Mastercopper = await prisma.mastercopper.delete({
     *   where: {
     *     // ... filter to delete one Mastercopper
     *   }
     * })
     * 
     */
    delete<T extends mastercopperDeleteArgs>(args: SelectSubset<T, mastercopperDeleteArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mastercopper.
     * @param {mastercopperUpdateArgs} args - Arguments to update one Mastercopper.
     * @example
     * // Update one Mastercopper
     * const mastercopper = await prisma.mastercopper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mastercopperUpdateArgs>(args: SelectSubset<T, mastercopperUpdateArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mastercoppers.
     * @param {mastercopperDeleteManyArgs} args - Arguments to filter Mastercoppers to delete.
     * @example
     * // Delete a few Mastercoppers
     * const { count } = await prisma.mastercopper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mastercopperDeleteManyArgs>(args?: SelectSubset<T, mastercopperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mastercoppers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mastercopperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mastercoppers
     * const mastercopper = await prisma.mastercopper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mastercopperUpdateManyArgs>(args: SelectSubset<T, mastercopperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mastercopper.
     * @param {mastercopperUpsertArgs} args - Arguments to update or create a Mastercopper.
     * @example
     * // Update or create a Mastercopper
     * const mastercopper = await prisma.mastercopper.upsert({
     *   create: {
     *     // ... data to create a Mastercopper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mastercopper we want to update
     *   }
     * })
     */
    upsert<T extends mastercopperUpsertArgs>(args: SelectSubset<T, mastercopperUpsertArgs<ExtArgs>>): Prisma__mastercopperClient<$Result.GetResult<Prisma.$mastercopperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mastercoppers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mastercopperCountArgs} args - Arguments to filter Mastercoppers to count.
     * @example
     * // Count the number of Mastercoppers
     * const count = await prisma.mastercopper.count({
     *   where: {
     *     // ... the filter for the Mastercoppers we want to count
     *   }
     * })
    **/
    count<T extends mastercopperCountArgs>(
      args?: Subset<T, mastercopperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MastercopperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mastercopper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercopperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MastercopperAggregateArgs>(args: Subset<T, MastercopperAggregateArgs>): Prisma.PrismaPromise<GetMastercopperAggregateType<T>>

    /**
     * Group by Mastercopper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mastercopperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mastercopperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mastercopperGroupByArgs['orderBy'] }
        : { orderBy?: mastercopperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mastercopperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMastercopperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mastercopper model
   */
  readonly fields: mastercopperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mastercopper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mastercopperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mastercopper model
   */
  interface mastercopperFieldRefs {
    readonly id: FieldRef<"mastercopper", 'Int'>
    readonly copperTotal: FieldRef<"mastercopper", 'Float'>
    readonly remainCopper: FieldRef<"mastercopper", 'Float'>
    readonly createdAt: FieldRef<"mastercopper", 'DateTime'>
    readonly updatedAt: FieldRef<"mastercopper", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mastercopper findUnique
   */
  export type mastercopperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * Filter, which mastercopper to fetch.
     */
    where: mastercopperWhereUniqueInput
  }

  /**
   * mastercopper findUniqueOrThrow
   */
  export type mastercopperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * Filter, which mastercopper to fetch.
     */
    where: mastercopperWhereUniqueInput
  }

  /**
   * mastercopper findFirst
   */
  export type mastercopperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * Filter, which mastercopper to fetch.
     */
    where?: mastercopperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mastercoppers to fetch.
     */
    orderBy?: mastercopperOrderByWithRelationInput | mastercopperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mastercoppers.
     */
    cursor?: mastercopperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mastercoppers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mastercoppers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mastercoppers.
     */
    distinct?: MastercopperScalarFieldEnum | MastercopperScalarFieldEnum[]
  }

  /**
   * mastercopper findFirstOrThrow
   */
  export type mastercopperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * Filter, which mastercopper to fetch.
     */
    where?: mastercopperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mastercoppers to fetch.
     */
    orderBy?: mastercopperOrderByWithRelationInput | mastercopperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mastercoppers.
     */
    cursor?: mastercopperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mastercoppers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mastercoppers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mastercoppers.
     */
    distinct?: MastercopperScalarFieldEnum | MastercopperScalarFieldEnum[]
  }

  /**
   * mastercopper findMany
   */
  export type mastercopperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * Filter, which mastercoppers to fetch.
     */
    where?: mastercopperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mastercoppers to fetch.
     */
    orderBy?: mastercopperOrderByWithRelationInput | mastercopperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mastercoppers.
     */
    cursor?: mastercopperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mastercoppers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mastercoppers.
     */
    skip?: number
    distinct?: MastercopperScalarFieldEnum | MastercopperScalarFieldEnum[]
  }

  /**
   * mastercopper create
   */
  export type mastercopperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * The data needed to create a mastercopper.
     */
    data: XOR<mastercopperCreateInput, mastercopperUncheckedCreateInput>
  }

  /**
   * mastercopper createMany
   */
  export type mastercopperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mastercoppers.
     */
    data: mastercopperCreateManyInput | mastercopperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mastercopper update
   */
  export type mastercopperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * The data needed to update a mastercopper.
     */
    data: XOR<mastercopperUpdateInput, mastercopperUncheckedUpdateInput>
    /**
     * Choose, which mastercopper to update.
     */
    where: mastercopperWhereUniqueInput
  }

  /**
   * mastercopper updateMany
   */
  export type mastercopperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mastercoppers.
     */
    data: XOR<mastercopperUpdateManyMutationInput, mastercopperUncheckedUpdateManyInput>
    /**
     * Filter which mastercoppers to update
     */
    where?: mastercopperWhereInput
    /**
     * Limit how many mastercoppers to update.
     */
    limit?: number
  }

  /**
   * mastercopper upsert
   */
  export type mastercopperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * The filter to search for the mastercopper to update in case it exists.
     */
    where: mastercopperWhereUniqueInput
    /**
     * In case the mastercopper found by the `where` argument doesn't exist, create a new mastercopper with this data.
     */
    create: XOR<mastercopperCreateInput, mastercopperUncheckedCreateInput>
    /**
     * In case the mastercopper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mastercopperUpdateInput, mastercopperUncheckedUpdateInput>
  }

  /**
   * mastercopper delete
   */
  export type mastercopperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
    /**
     * Filter which mastercopper to delete.
     */
    where: mastercopperWhereUniqueInput
  }

  /**
   * mastercopper deleteMany
   */
  export type mastercopperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mastercoppers to delete
     */
    where?: mastercopperWhereInput
    /**
     * Limit how many mastercoppers to delete.
     */
    limit?: number
  }

  /**
   * mastercopper without action
   */
  export type mastercopperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mastercopper
     */
    select?: mastercopperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mastercopper
     */
    omit?: mastercopperOmit<ExtArgs> | null
  }


  /**
   * Model JewelStock
   */

  export type AggregateJewelStock = {
    _count: JewelStockCountAggregateOutputType | null
    _avg: JewelStockAvgAggregateOutputType | null
    _sum: JewelStockSumAggregateOutputType | null
    _min: JewelStockMinAggregateOutputType | null
    _max: JewelStockMaxAggregateOutputType | null
  }

  export type JewelStockAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
  }

  export type JewelStockSumAggregateOutputType = {
    id: number | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
  }

  export type JewelStockMinAggregateOutputType = {
    id: number | null
    jewelName: string | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
    createdAt: Date | null
  }

  export type JewelStockMaxAggregateOutputType = {
    id: number | null
    jewelName: string | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
    createdAt: Date | null
  }

  export type JewelStockCountAggregateOutputType = {
    id: number
    jewelName: number
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt: number
    _all: number
  }


  export type JewelStockAvgAggregateInputType = {
    id?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
  }

  export type JewelStockSumAggregateInputType = {
    id?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
  }

  export type JewelStockMinAggregateInputType = {
    id?: true
    jewelName?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
    createdAt?: true
  }

  export type JewelStockMaxAggregateInputType = {
    id?: true
    jewelName?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
    createdAt?: true
  }

  export type JewelStockCountAggregateInputType = {
    id?: true
    jewelName?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
    createdAt?: true
    _all?: true
  }

  export type JewelStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JewelStock to aggregate.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JewelStocks
    **/
    _count?: true | JewelStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JewelStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JewelStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JewelStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JewelStockMaxAggregateInputType
  }

  export type GetJewelStockAggregateType<T extends JewelStockAggregateArgs> = {
        [P in keyof T & keyof AggregateJewelStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJewelStock[P]>
      : GetScalarType<T[P], AggregateJewelStock[P]>
  }




  export type JewelStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JewelStockWhereInput
    orderBy?: JewelStockOrderByWithAggregationInput | JewelStockOrderByWithAggregationInput[]
    by: JewelStockScalarFieldEnum[] | JewelStockScalarFieldEnum
    having?: JewelStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JewelStockCountAggregateInputType | true
    _avg?: JewelStockAvgAggregateInputType
    _sum?: JewelStockSumAggregateInputType
    _min?: JewelStockMinAggregateInputType
    _max?: JewelStockMaxAggregateInputType
  }

  export type JewelStockGroupByOutputType = {
    id: number
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt: Date
    _count: JewelStockCountAggregateOutputType | null
    _avg: JewelStockAvgAggregateOutputType | null
    _sum: JewelStockSumAggregateOutputType | null
    _min: JewelStockMinAggregateOutputType | null
    _max: JewelStockMaxAggregateOutputType | null
  }

  type GetJewelStockGroupByPayload<T extends JewelStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JewelStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JewelStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JewelStockGroupByOutputType[P]>
            : GetScalarType<T[P], JewelStockGroupByOutputType[P]>
        }
      >
    >


  export type JewelStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jewelName?: boolean
    weight?: boolean
    stoneWeight?: boolean
    finalWeight?: boolean
    touch?: boolean
    purityValue?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jewelStock"]>



  export type JewelStockSelectScalar = {
    id?: boolean
    jewelName?: boolean
    weight?: boolean
    stoneWeight?: boolean
    finalWeight?: boolean
    touch?: boolean
    purityValue?: boolean
    createdAt?: boolean
  }

  export type JewelStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jewelName" | "weight" | "stoneWeight" | "finalWeight" | "touch" | "purityValue" | "createdAt", ExtArgs["result"]["jewelStock"]>

  export type $JewelStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JewelStock"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jewelName: string
      weight: number
      stoneWeight: number
      finalWeight: number
      touch: number
      purityValue: number
      createdAt: Date
    }, ExtArgs["result"]["jewelStock"]>
    composites: {}
  }

  type JewelStockGetPayload<S extends boolean | null | undefined | JewelStockDefaultArgs> = $Result.GetResult<Prisma.$JewelStockPayload, S>

  type JewelStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JewelStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JewelStockCountAggregateInputType | true
    }

  export interface JewelStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JewelStock'], meta: { name: 'JewelStock' } }
    /**
     * Find zero or one JewelStock that matches the filter.
     * @param {JewelStockFindUniqueArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JewelStockFindUniqueArgs>(args: SelectSubset<T, JewelStockFindUniqueArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JewelStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JewelStockFindUniqueOrThrowArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JewelStockFindUniqueOrThrowArgs>(args: SelectSubset<T, JewelStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JewelStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockFindFirstArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JewelStockFindFirstArgs>(args?: SelectSubset<T, JewelStockFindFirstArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JewelStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockFindFirstOrThrowArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JewelStockFindFirstOrThrowArgs>(args?: SelectSubset<T, JewelStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JewelStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JewelStocks
     * const jewelStocks = await prisma.jewelStock.findMany()
     * 
     * // Get first 10 JewelStocks
     * const jewelStocks = await prisma.jewelStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jewelStockWithIdOnly = await prisma.jewelStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JewelStockFindManyArgs>(args?: SelectSubset<T, JewelStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JewelStock.
     * @param {JewelStockCreateArgs} args - Arguments to create a JewelStock.
     * @example
     * // Create one JewelStock
     * const JewelStock = await prisma.jewelStock.create({
     *   data: {
     *     // ... data to create a JewelStock
     *   }
     * })
     * 
     */
    create<T extends JewelStockCreateArgs>(args: SelectSubset<T, JewelStockCreateArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JewelStocks.
     * @param {JewelStockCreateManyArgs} args - Arguments to create many JewelStocks.
     * @example
     * // Create many JewelStocks
     * const jewelStock = await prisma.jewelStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JewelStockCreateManyArgs>(args?: SelectSubset<T, JewelStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JewelStock.
     * @param {JewelStockDeleteArgs} args - Arguments to delete one JewelStock.
     * @example
     * // Delete one JewelStock
     * const JewelStock = await prisma.jewelStock.delete({
     *   where: {
     *     // ... filter to delete one JewelStock
     *   }
     * })
     * 
     */
    delete<T extends JewelStockDeleteArgs>(args: SelectSubset<T, JewelStockDeleteArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JewelStock.
     * @param {JewelStockUpdateArgs} args - Arguments to update one JewelStock.
     * @example
     * // Update one JewelStock
     * const jewelStock = await prisma.jewelStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JewelStockUpdateArgs>(args: SelectSubset<T, JewelStockUpdateArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JewelStocks.
     * @param {JewelStockDeleteManyArgs} args - Arguments to filter JewelStocks to delete.
     * @example
     * // Delete a few JewelStocks
     * const { count } = await prisma.jewelStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JewelStockDeleteManyArgs>(args?: SelectSubset<T, JewelStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JewelStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JewelStocks
     * const jewelStock = await prisma.jewelStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JewelStockUpdateManyArgs>(args: SelectSubset<T, JewelStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JewelStock.
     * @param {JewelStockUpsertArgs} args - Arguments to update or create a JewelStock.
     * @example
     * // Update or create a JewelStock
     * const jewelStock = await prisma.jewelStock.upsert({
     *   create: {
     *     // ... data to create a JewelStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JewelStock we want to update
     *   }
     * })
     */
    upsert<T extends JewelStockUpsertArgs>(args: SelectSubset<T, JewelStockUpsertArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JewelStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockCountArgs} args - Arguments to filter JewelStocks to count.
     * @example
     * // Count the number of JewelStocks
     * const count = await prisma.jewelStock.count({
     *   where: {
     *     // ... the filter for the JewelStocks we want to count
     *   }
     * })
    **/
    count<T extends JewelStockCountArgs>(
      args?: Subset<T, JewelStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JewelStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JewelStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JewelStockAggregateArgs>(args: Subset<T, JewelStockAggregateArgs>): Prisma.PrismaPromise<GetJewelStockAggregateType<T>>

    /**
     * Group by JewelStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JewelStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JewelStockGroupByArgs['orderBy'] }
        : { orderBy?: JewelStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JewelStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJewelStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JewelStock model
   */
  readonly fields: JewelStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JewelStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JewelStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JewelStock model
   */
  interface JewelStockFieldRefs {
    readonly id: FieldRef<"JewelStock", 'Int'>
    readonly jewelName: FieldRef<"JewelStock", 'String'>
    readonly weight: FieldRef<"JewelStock", 'Float'>
    readonly stoneWeight: FieldRef<"JewelStock", 'Float'>
    readonly finalWeight: FieldRef<"JewelStock", 'Float'>
    readonly touch: FieldRef<"JewelStock", 'Float'>
    readonly purityValue: FieldRef<"JewelStock", 'Float'>
    readonly createdAt: FieldRef<"JewelStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JewelStock findUnique
   */
  export type JewelStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock findUniqueOrThrow
   */
  export type JewelStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock findFirst
   */
  export type JewelStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JewelStocks.
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JewelStocks.
     */
    distinct?: JewelStockScalarFieldEnum | JewelStockScalarFieldEnum[]
  }

  /**
   * JewelStock findFirstOrThrow
   */
  export type JewelStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JewelStocks.
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JewelStocks.
     */
    distinct?: JewelStockScalarFieldEnum | JewelStockScalarFieldEnum[]
  }

  /**
   * JewelStock findMany
   */
  export type JewelStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStocks to fetch.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JewelStocks.
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    distinct?: JewelStockScalarFieldEnum | JewelStockScalarFieldEnum[]
  }

  /**
   * JewelStock create
   */
  export type JewelStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * The data needed to create a JewelStock.
     */
    data: XOR<JewelStockCreateInput, JewelStockUncheckedCreateInput>
  }

  /**
   * JewelStock createMany
   */
  export type JewelStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JewelStocks.
     */
    data: JewelStockCreateManyInput | JewelStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JewelStock update
   */
  export type JewelStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * The data needed to update a JewelStock.
     */
    data: XOR<JewelStockUpdateInput, JewelStockUncheckedUpdateInput>
    /**
     * Choose, which JewelStock to update.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock updateMany
   */
  export type JewelStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JewelStocks.
     */
    data: XOR<JewelStockUpdateManyMutationInput, JewelStockUncheckedUpdateManyInput>
    /**
     * Filter which JewelStocks to update
     */
    where?: JewelStockWhereInput
    /**
     * Limit how many JewelStocks to update.
     */
    limit?: number
  }

  /**
   * JewelStock upsert
   */
  export type JewelStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * The filter to search for the JewelStock to update in case it exists.
     */
    where: JewelStockWhereUniqueInput
    /**
     * In case the JewelStock found by the `where` argument doesn't exist, create a new JewelStock with this data.
     */
    create: XOR<JewelStockCreateInput, JewelStockUncheckedCreateInput>
    /**
     * In case the JewelStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JewelStockUpdateInput, JewelStockUncheckedUpdateInput>
  }

  /**
   * JewelStock delete
   */
  export type JewelStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter which JewelStock to delete.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock deleteMany
   */
  export type JewelStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JewelStocks to delete
     */
    where?: JewelStockWhereInput
    /**
     * Limit how many JewelStocks to delete.
     */
    limit?: number
  }

  /**
   * JewelStock without action
   */
  export type JewelStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    logId: number | null
    gold: number | null
    amount: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    logId: number | null
    gold: number | null
    amount: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    logId: number | null
    gold: number | null
    amount: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    logId: number | null
    gold: number | null
    amount: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    date: number
    type: number
    logId: number
    gold: number
    amount: number
    goldRate: number
    purity: number
    touch: number
    customerId: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    logId?: true
    gold?: true
    amount?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    logId?: true
    gold?: true
    amount?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    logId?: true
    gold?: true
    amount?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    logId?: true
    gold?: true
    amount?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    logId?: true
    gold?: true
    amount?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    date: Date
    type: string
    logId: number | null
    gold: number | null
    amount: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    logId?: boolean
    gold?: boolean
    amount?: boolean
    goldRate?: boolean
    purity?: boolean
    touch?: boolean
    customerId?: boolean
    createdAt?: boolean
    rawGoldLogs?: boolean | Transaction$rawGoldLogsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    date?: boolean
    type?: boolean
    logId?: boolean
    gold?: boolean
    amount?: boolean
    goldRate?: boolean
    purity?: boolean
    touch?: boolean
    customerId?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "type" | "logId" | "gold" | "amount" | "goldRate" | "purity" | "touch" | "customerId" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawGoldLogs?: boolean | Transaction$rawGoldLogsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      rawGoldLogs: Prisma.$RawGoldLogsPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      type: string
      logId: number | null
      gold: number | null
      amount: number | null
      goldRate: number | null
      purity: number | null
      touch: number | null
      customerId: number
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawGoldLogs<T extends Transaction$rawGoldLogsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$rawGoldLogsArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly logId: FieldRef<"Transaction", 'Int'>
    readonly gold: FieldRef<"Transaction", 'Float'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly goldRate: FieldRef<"Transaction", 'Float'>
    readonly purity: FieldRef<"Transaction", 'Float'>
    readonly touch: FieldRef<"Transaction", 'Float'>
    readonly customerId: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.rawGoldLogs
   */
  export type Transaction$rawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    where?: RawGoldLogsWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Entry
   */

  export type AggregateEntry = {
    _count: EntryCountAggregateOutputType | null
    _avg: EntryAvgAggregateOutputType | null
    _sum: EntrySumAggregateOutputType | null
    _min: EntryMinAggregateOutputType | null
    _max: EntryMaxAggregateOutputType | null
  }

  export type EntryAvgAggregateOutputType = {
    id: number | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
  }

  export type EntrySumAggregateOutputType = {
    id: number | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
  }

  export type EntryMinAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    createdAt: Date | null
  }

  export type EntryMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    createdAt: Date | null
  }

  export type EntryCountAggregateOutputType = {
    id: number
    date: number
    type: number
    cashAmount: number
    goldValue: number
    touch: number
    purity: number
    goldRate: number
    createdAt: number
    _all: number
  }


  export type EntryAvgAggregateInputType = {
    id?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
  }

  export type EntrySumAggregateInputType = {
    id?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
  }

  export type EntryMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
    createdAt?: true
  }

  export type EntryMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
    createdAt?: true
  }

  export type EntryCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
    createdAt?: true
    _all?: true
  }

  export type EntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entry to aggregate.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entries
    **/
    _count?: true | EntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntryMaxAggregateInputType
  }

  export type GetEntryAggregateType<T extends EntryAggregateArgs> = {
        [P in keyof T & keyof AggregateEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntry[P]>
      : GetScalarType<T[P], AggregateEntry[P]>
  }




  export type EntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntryWhereInput
    orderBy?: EntryOrderByWithAggregationInput | EntryOrderByWithAggregationInput[]
    by: EntryScalarFieldEnum[] | EntryScalarFieldEnum
    having?: EntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntryCountAggregateInputType | true
    _avg?: EntryAvgAggregateInputType
    _sum?: EntrySumAggregateInputType
    _min?: EntryMinAggregateInputType
    _max?: EntryMaxAggregateInputType
  }

  export type EntryGroupByOutputType = {
    id: number
    date: Date
    type: string
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    createdAt: Date
    _count: EntryCountAggregateOutputType | null
    _avg: EntryAvgAggregateOutputType | null
    _sum: EntrySumAggregateOutputType | null
    _min: EntryMinAggregateOutputType | null
    _max: EntryMaxAggregateOutputType | null
  }

  type GetEntryGroupByPayload<T extends EntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntryGroupByOutputType[P]>
            : GetScalarType<T[P], EntryGroupByOutputType[P]>
        }
      >
    >


  export type EntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    cashAmount?: boolean
    goldValue?: boolean
    touch?: boolean
    purity?: boolean
    goldRate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["entry"]>



  export type EntrySelectScalar = {
    id?: boolean
    date?: boolean
    type?: boolean
    cashAmount?: boolean
    goldValue?: boolean
    touch?: boolean
    purity?: boolean
    goldRate?: boolean
    createdAt?: boolean
  }

  export type EntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "type" | "cashAmount" | "goldValue" | "touch" | "purity" | "goldRate" | "createdAt", ExtArgs["result"]["entry"]>

  export type $EntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      type: string
      cashAmount: number | null
      goldValue: number | null
      touch: number | null
      purity: number | null
      goldRate: number | null
      createdAt: Date
    }, ExtArgs["result"]["entry"]>
    composites: {}
  }

  type EntryGetPayload<S extends boolean | null | undefined | EntryDefaultArgs> = $Result.GetResult<Prisma.$EntryPayload, S>

  type EntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntryCountAggregateInputType | true
    }

  export interface EntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entry'], meta: { name: 'Entry' } }
    /**
     * Find zero or one Entry that matches the filter.
     * @param {EntryFindUniqueArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntryFindUniqueArgs>(args: SelectSubset<T, EntryFindUniqueArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EntryFindUniqueOrThrowArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntryFindUniqueOrThrowArgs>(args: SelectSubset<T, EntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindFirstArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntryFindFirstArgs>(args?: SelectSubset<T, EntryFindFirstArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindFirstOrThrowArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntryFindFirstOrThrowArgs>(args?: SelectSubset<T, EntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entries
     * const entries = await prisma.entry.findMany()
     * 
     * // Get first 10 Entries
     * const entries = await prisma.entry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entryWithIdOnly = await prisma.entry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntryFindManyArgs>(args?: SelectSubset<T, EntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entry.
     * @param {EntryCreateArgs} args - Arguments to create a Entry.
     * @example
     * // Create one Entry
     * const Entry = await prisma.entry.create({
     *   data: {
     *     // ... data to create a Entry
     *   }
     * })
     * 
     */
    create<T extends EntryCreateArgs>(args: SelectSubset<T, EntryCreateArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entries.
     * @param {EntryCreateManyArgs} args - Arguments to create many Entries.
     * @example
     * // Create many Entries
     * const entry = await prisma.entry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntryCreateManyArgs>(args?: SelectSubset<T, EntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entry.
     * @param {EntryDeleteArgs} args - Arguments to delete one Entry.
     * @example
     * // Delete one Entry
     * const Entry = await prisma.entry.delete({
     *   where: {
     *     // ... filter to delete one Entry
     *   }
     * })
     * 
     */
    delete<T extends EntryDeleteArgs>(args: SelectSubset<T, EntryDeleteArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entry.
     * @param {EntryUpdateArgs} args - Arguments to update one Entry.
     * @example
     * // Update one Entry
     * const entry = await prisma.entry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntryUpdateArgs>(args: SelectSubset<T, EntryUpdateArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entries.
     * @param {EntryDeleteManyArgs} args - Arguments to filter Entries to delete.
     * @example
     * // Delete a few Entries
     * const { count } = await prisma.entry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntryDeleteManyArgs>(args?: SelectSubset<T, EntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entries
     * const entry = await prisma.entry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntryUpdateManyArgs>(args: SelectSubset<T, EntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entry.
     * @param {EntryUpsertArgs} args - Arguments to update or create a Entry.
     * @example
     * // Update or create a Entry
     * const entry = await prisma.entry.upsert({
     *   create: {
     *     // ... data to create a Entry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entry we want to update
     *   }
     * })
     */
    upsert<T extends EntryUpsertArgs>(args: SelectSubset<T, EntryUpsertArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryCountArgs} args - Arguments to filter Entries to count.
     * @example
     * // Count the number of Entries
     * const count = await prisma.entry.count({
     *   where: {
     *     // ... the filter for the Entries we want to count
     *   }
     * })
    **/
    count<T extends EntryCountArgs>(
      args?: Subset<T, EntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntryAggregateArgs>(args: Subset<T, EntryAggregateArgs>): Prisma.PrismaPromise<GetEntryAggregateType<T>>

    /**
     * Group by Entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntryGroupByArgs['orderBy'] }
        : { orderBy?: EntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entry model
   */
  readonly fields: EntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entry model
   */
  interface EntryFieldRefs {
    readonly id: FieldRef<"Entry", 'Int'>
    readonly date: FieldRef<"Entry", 'DateTime'>
    readonly type: FieldRef<"Entry", 'String'>
    readonly cashAmount: FieldRef<"Entry", 'Float'>
    readonly goldValue: FieldRef<"Entry", 'Float'>
    readonly touch: FieldRef<"Entry", 'Float'>
    readonly purity: FieldRef<"Entry", 'Float'>
    readonly goldRate: FieldRef<"Entry", 'Float'>
    readonly createdAt: FieldRef<"Entry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entry findUnique
   */
  export type EntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry findUniqueOrThrow
   */
  export type EntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry findFirst
   */
  export type EntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entries.
     */
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry findFirstOrThrow
   */
  export type EntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entries.
     */
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry findMany
   */
  export type EntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entries to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry create
   */
  export type EntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * The data needed to create a Entry.
     */
    data: XOR<EntryCreateInput, EntryUncheckedCreateInput>
  }

  /**
   * Entry createMany
   */
  export type EntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entries.
     */
    data: EntryCreateManyInput | EntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entry update
   */
  export type EntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * The data needed to update a Entry.
     */
    data: XOR<EntryUpdateInput, EntryUncheckedUpdateInput>
    /**
     * Choose, which Entry to update.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry updateMany
   */
  export type EntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entries.
     */
    data: XOR<EntryUpdateManyMutationInput, EntryUncheckedUpdateManyInput>
    /**
     * Filter which Entries to update
     */
    where?: EntryWhereInput
    /**
     * Limit how many Entries to update.
     */
    limit?: number
  }

  /**
   * Entry upsert
   */
  export type EntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * The filter to search for the Entry to update in case it exists.
     */
    where: EntryWhereUniqueInput
    /**
     * In case the Entry found by the `where` argument doesn't exist, create a new Entry with this data.
     */
    create: XOR<EntryCreateInput, EntryUncheckedCreateInput>
    /**
     * In case the Entry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntryUpdateInput, EntryUncheckedUpdateInput>
  }

  /**
   * Entry delete
   */
  export type EntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter which Entry to delete.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry deleteMany
   */
  export type EntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entries to delete
     */
    where?: EntryWhereInput
    /**
     * Limit how many Entries to delete.
     */
    limit?: number
  }

  /**
   * Entry without action
   */
  export type EntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
  }


  /**
   * Model customer_order
   */

  export type AggregateCustomer_order = {
    _count: Customer_orderCountAggregateOutputType | null
    _avg: Customer_orderAvgAggregateOutputType | null
    _sum: Customer_orderSumAggregateOutputType | null
    _min: Customer_orderMinAggregateOutputType | null
    _max: Customer_orderMaxAggregateOutputType | null
  }

  export type Customer_orderAvgAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    weight: number | null
  }

  export type Customer_orderSumAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    weight: number | null
  }

  export type Customer_orderMinAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    item_name: string | null
    description: string | null
    weight: number | null
    image: string | null
    due_date: Date | null
    status: string | null
    worker_name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type Customer_orderMaxAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    item_name: string | null
    description: string | null
    weight: number | null
    image: string | null
    due_date: Date | null
    status: string | null
    worker_name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type Customer_orderCountAggregateOutputType = {
    id: number
    customer_id: number
    order_group_id: number
    item_name: number
    description: number
    weight: number
    image: number
    due_date: number
    status: number
    worker_name: number
    created_at: number
    updatedAt: number
    _all: number
  }


  export type Customer_orderAvgAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    weight?: true
  }

  export type Customer_orderSumAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    weight?: true
  }

  export type Customer_orderMinAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    item_name?: true
    description?: true
    weight?: true
    image?: true
    due_date?: true
    status?: true
    worker_name?: true
    created_at?: true
    updatedAt?: true
  }

  export type Customer_orderMaxAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    item_name?: true
    description?: true
    weight?: true
    image?: true
    due_date?: true
    status?: true
    worker_name?: true
    created_at?: true
    updatedAt?: true
  }

  export type Customer_orderCountAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    item_name?: true
    description?: true
    weight?: true
    image?: true
    due_date?: true
    status?: true
    worker_name?: true
    created_at?: true
    updatedAt?: true
    _all?: true
  }

  export type Customer_orderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_order to aggregate.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customer_orders
    **/
    _count?: true | Customer_orderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Customer_orderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Customer_orderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Customer_orderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Customer_orderMaxAggregateInputType
  }

  export type GetCustomer_orderAggregateType<T extends Customer_orderAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer_order]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer_order[P]>
      : GetScalarType<T[P], AggregateCustomer_order[P]>
  }




  export type customer_orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_orderWhereInput
    orderBy?: customer_orderOrderByWithAggregationInput | customer_orderOrderByWithAggregationInput[]
    by: Customer_orderScalarFieldEnum[] | Customer_orderScalarFieldEnum
    having?: customer_orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Customer_orderCountAggregateInputType | true
    _avg?: Customer_orderAvgAggregateInputType
    _sum?: Customer_orderSumAggregateInputType
    _min?: Customer_orderMinAggregateInputType
    _max?: Customer_orderMaxAggregateInputType
  }

  export type Customer_orderGroupByOutputType = {
    id: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image: string | null
    due_date: Date | null
    status: string
    worker_name: string | null
    created_at: Date
    updatedAt: Date
    _count: Customer_orderCountAggregateOutputType | null
    _avg: Customer_orderAvgAggregateOutputType | null
    _sum: Customer_orderSumAggregateOutputType | null
    _min: Customer_orderMinAggregateOutputType | null
    _max: Customer_orderMaxAggregateOutputType | null
  }

  type GetCustomer_orderGroupByPayload<T extends customer_orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Customer_orderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Customer_orderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Customer_orderGroupByOutputType[P]>
            : GetScalarType<T[P], Customer_orderGroupByOutputType[P]>
        }
      >
    >


  export type customer_orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    order_group_id?: boolean
    item_name?: boolean
    description?: boolean
    weight?: boolean
    image?: boolean
    due_date?: boolean
    status?: boolean
    worker_name?: boolean
    created_at?: boolean
    updatedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    productImages?: boolean | customer_order$productImagesArgs<ExtArgs>
    _count?: boolean | Customer_orderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_order"]>



  export type customer_orderSelectScalar = {
    id?: boolean
    customer_id?: boolean
    order_group_id?: boolean
    item_name?: boolean
    description?: boolean
    weight?: boolean
    image?: boolean
    due_date?: boolean
    status?: boolean
    worker_name?: boolean
    created_at?: boolean
    updatedAt?: boolean
  }

  export type customer_orderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "order_group_id" | "item_name" | "description" | "weight" | "image" | "due_date" | "status" | "worker_name" | "created_at" | "updatedAt", ExtArgs["result"]["customer_order"]>
  export type customer_orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    productImages?: boolean | customer_order$productImagesArgs<ExtArgs>
    _count?: boolean | Customer_orderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $customer_orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer_order"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>
      productImages: Prisma.$product_multiple_imagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_id: number
      order_group_id: number
      item_name: string
      description: string
      weight: number
      image: string | null
      due_date: Date | null
      status: string
      worker_name: string | null
      created_at: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer_order"]>
    composites: {}
  }

  type customer_orderGetPayload<S extends boolean | null | undefined | customer_orderDefaultArgs> = $Result.GetResult<Prisma.$customer_orderPayload, S>

  type customer_orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customer_orderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Customer_orderCountAggregateInputType | true
    }

  export interface customer_orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer_order'], meta: { name: 'customer_order' } }
    /**
     * Find zero or one Customer_order that matches the filter.
     * @param {customer_orderFindUniqueArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customer_orderFindUniqueArgs>(args: SelectSubset<T, customer_orderFindUniqueArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer_order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customer_orderFindUniqueOrThrowArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customer_orderFindUniqueOrThrowArgs>(args: SelectSubset<T, customer_orderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderFindFirstArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customer_orderFindFirstArgs>(args?: SelectSubset<T, customer_orderFindFirstArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderFindFirstOrThrowArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customer_orderFindFirstOrThrowArgs>(args?: SelectSubset<T, customer_orderFindFirstOrThrowArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customer_orders
     * const customer_orders = await prisma.customer_order.findMany()
     * 
     * // Get first 10 Customer_orders
     * const customer_orders = await prisma.customer_order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customer_orderWithIdOnly = await prisma.customer_order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customer_orderFindManyArgs>(args?: SelectSubset<T, customer_orderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer_order.
     * @param {customer_orderCreateArgs} args - Arguments to create a Customer_order.
     * @example
     * // Create one Customer_order
     * const Customer_order = await prisma.customer_order.create({
     *   data: {
     *     // ... data to create a Customer_order
     *   }
     * })
     * 
     */
    create<T extends customer_orderCreateArgs>(args: SelectSubset<T, customer_orderCreateArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customer_orders.
     * @param {customer_orderCreateManyArgs} args - Arguments to create many Customer_orders.
     * @example
     * // Create many Customer_orders
     * const customer_order = await prisma.customer_order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customer_orderCreateManyArgs>(args?: SelectSubset<T, customer_orderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer_order.
     * @param {customer_orderDeleteArgs} args - Arguments to delete one Customer_order.
     * @example
     * // Delete one Customer_order
     * const Customer_order = await prisma.customer_order.delete({
     *   where: {
     *     // ... filter to delete one Customer_order
     *   }
     * })
     * 
     */
    delete<T extends customer_orderDeleteArgs>(args: SelectSubset<T, customer_orderDeleteArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer_order.
     * @param {customer_orderUpdateArgs} args - Arguments to update one Customer_order.
     * @example
     * // Update one Customer_order
     * const customer_order = await prisma.customer_order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customer_orderUpdateArgs>(args: SelectSubset<T, customer_orderUpdateArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customer_orders.
     * @param {customer_orderDeleteManyArgs} args - Arguments to filter Customer_orders to delete.
     * @example
     * // Delete a few Customer_orders
     * const { count } = await prisma.customer_order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customer_orderDeleteManyArgs>(args?: SelectSubset<T, customer_orderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customer_orders
     * const customer_order = await prisma.customer_order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customer_orderUpdateManyArgs>(args: SelectSubset<T, customer_orderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer_order.
     * @param {customer_orderUpsertArgs} args - Arguments to update or create a Customer_order.
     * @example
     * // Update or create a Customer_order
     * const customer_order = await prisma.customer_order.upsert({
     *   create: {
     *     // ... data to create a Customer_order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer_order we want to update
     *   }
     * })
     */
    upsert<T extends customer_orderUpsertArgs>(args: SelectSubset<T, customer_orderUpsertArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customer_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderCountArgs} args - Arguments to filter Customer_orders to count.
     * @example
     * // Count the number of Customer_orders
     * const count = await prisma.customer_order.count({
     *   where: {
     *     // ... the filter for the Customer_orders we want to count
     *   }
     * })
    **/
    count<T extends customer_orderCountArgs>(
      args?: Subset<T, customer_orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Customer_orderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_orderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Customer_orderAggregateArgs>(args: Subset<T, Customer_orderAggregateArgs>): Prisma.PrismaPromise<GetCustomer_orderAggregateType<T>>

    /**
     * Group by Customer_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customer_orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customer_orderGroupByArgs['orderBy'] }
        : { orderBy?: customer_orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customer_orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomer_orderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer_order model
   */
  readonly fields: customer_orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer_order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customer_orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productImages<T extends customer_order$productImagesArgs<ExtArgs> = {}>(args?: Subset<T, customer_order$productImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer_order model
   */
  interface customer_orderFieldRefs {
    readonly id: FieldRef<"customer_order", 'Int'>
    readonly customer_id: FieldRef<"customer_order", 'Int'>
    readonly order_group_id: FieldRef<"customer_order", 'Int'>
    readonly item_name: FieldRef<"customer_order", 'String'>
    readonly description: FieldRef<"customer_order", 'String'>
    readonly weight: FieldRef<"customer_order", 'Float'>
    readonly image: FieldRef<"customer_order", 'String'>
    readonly due_date: FieldRef<"customer_order", 'DateTime'>
    readonly status: FieldRef<"customer_order", 'String'>
    readonly worker_name: FieldRef<"customer_order", 'String'>
    readonly created_at: FieldRef<"customer_order", 'DateTime'>
    readonly updatedAt: FieldRef<"customer_order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer_order findUnique
   */
  export type customer_orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order findUniqueOrThrow
   */
  export type customer_orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order findFirst
   */
  export type customer_orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_orders.
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_orders.
     */
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * customer_order findFirstOrThrow
   */
  export type customer_orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_orders.
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_orders.
     */
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * customer_order findMany
   */
  export type customer_orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_orders to fetch.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customer_orders.
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * customer_order create
   */
  export type customer_orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * The data needed to create a customer_order.
     */
    data: XOR<customer_orderCreateInput, customer_orderUncheckedCreateInput>
  }

  /**
   * customer_order createMany
   */
  export type customer_orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customer_orders.
     */
    data: customer_orderCreateManyInput | customer_orderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer_order update
   */
  export type customer_orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * The data needed to update a customer_order.
     */
    data: XOR<customer_orderUpdateInput, customer_orderUncheckedUpdateInput>
    /**
     * Choose, which customer_order to update.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order updateMany
   */
  export type customer_orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customer_orders.
     */
    data: XOR<customer_orderUpdateManyMutationInput, customer_orderUncheckedUpdateManyInput>
    /**
     * Filter which customer_orders to update
     */
    where?: customer_orderWhereInput
    /**
     * Limit how many customer_orders to update.
     */
    limit?: number
  }

  /**
   * customer_order upsert
   */
  export type customer_orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * The filter to search for the customer_order to update in case it exists.
     */
    where: customer_orderWhereUniqueInput
    /**
     * In case the customer_order found by the `where` argument doesn't exist, create a new customer_order with this data.
     */
    create: XOR<customer_orderCreateInput, customer_orderUncheckedCreateInput>
    /**
     * In case the customer_order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customer_orderUpdateInput, customer_orderUncheckedUpdateInput>
  }

  /**
   * customer_order delete
   */
  export type customer_orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter which customer_order to delete.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order deleteMany
   */
  export type customer_orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_orders to delete
     */
    where?: customer_orderWhereInput
    /**
     * Limit how many customer_orders to delete.
     */
    limit?: number
  }

  /**
   * customer_order.productImages
   */
  export type customer_order$productImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    where?: product_multiple_imagesWhereInput
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    cursor?: product_multiple_imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * customer_order without action
   */
  export type customer_orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
  }


  /**
   * Model product_multiple_images
   */

  export type AggregateProduct_multiple_images = {
    _count: Product_multiple_imagesCountAggregateOutputType | null
    _avg: Product_multiple_imagesAvgAggregateOutputType | null
    _sum: Product_multiple_imagesSumAggregateOutputType | null
    _min: Product_multiple_imagesMinAggregateOutputType | null
    _max: Product_multiple_imagesMaxAggregateOutputType | null
  }

  export type Product_multiple_imagesAvgAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
  }

  export type Product_multiple_imagesSumAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
  }

  export type Product_multiple_imagesMinAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
    filename: string | null
  }

  export type Product_multiple_imagesMaxAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
    filename: string | null
  }

  export type Product_multiple_imagesCountAggregateOutputType = {
    id: number
    customer_order_id: number
    filename: number
    _all: number
  }


  export type Product_multiple_imagesAvgAggregateInputType = {
    id?: true
    customer_order_id?: true
  }

  export type Product_multiple_imagesSumAggregateInputType = {
    id?: true
    customer_order_id?: true
  }

  export type Product_multiple_imagesMinAggregateInputType = {
    id?: true
    customer_order_id?: true
    filename?: true
  }

  export type Product_multiple_imagesMaxAggregateInputType = {
    id?: true
    customer_order_id?: true
    filename?: true
  }

  export type Product_multiple_imagesCountAggregateInputType = {
    id?: true
    customer_order_id?: true
    filename?: true
    _all?: true
  }

  export type Product_multiple_imagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_multiple_images to aggregate.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_multiple_images
    **/
    _count?: true | Product_multiple_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_multiple_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_multiple_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_multiple_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_multiple_imagesMaxAggregateInputType
  }

  export type GetProduct_multiple_imagesAggregateType<T extends Product_multiple_imagesAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_multiple_images]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_multiple_images[P]>
      : GetScalarType<T[P], AggregateProduct_multiple_images[P]>
  }




  export type product_multiple_imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_multiple_imagesWhereInput
    orderBy?: product_multiple_imagesOrderByWithAggregationInput | product_multiple_imagesOrderByWithAggregationInput[]
    by: Product_multiple_imagesScalarFieldEnum[] | Product_multiple_imagesScalarFieldEnum
    having?: product_multiple_imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_multiple_imagesCountAggregateInputType | true
    _avg?: Product_multiple_imagesAvgAggregateInputType
    _sum?: Product_multiple_imagesSumAggregateInputType
    _min?: Product_multiple_imagesMinAggregateInputType
    _max?: Product_multiple_imagesMaxAggregateInputType
  }

  export type Product_multiple_imagesGroupByOutputType = {
    id: number
    customer_order_id: number
    filename: string
    _count: Product_multiple_imagesCountAggregateOutputType | null
    _avg: Product_multiple_imagesAvgAggregateOutputType | null
    _sum: Product_multiple_imagesSumAggregateOutputType | null
    _min: Product_multiple_imagesMinAggregateOutputType | null
    _max: Product_multiple_imagesMaxAggregateOutputType | null
  }

  type GetProduct_multiple_imagesGroupByPayload<T extends product_multiple_imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_multiple_imagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_multiple_imagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_multiple_imagesGroupByOutputType[P]>
            : GetScalarType<T[P], Product_multiple_imagesGroupByOutputType[P]>
        }
      >
    >


  export type product_multiple_imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_order_id?: boolean
    filename?: boolean
    customerOrderDetails?: boolean | customer_orderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_multiple_images"]>



  export type product_multiple_imagesSelectScalar = {
    id?: boolean
    customer_order_id?: boolean
    filename?: boolean
  }

  export type product_multiple_imagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_order_id" | "filename", ExtArgs["result"]["product_multiple_images"]>
  export type product_multiple_imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerOrderDetails?: boolean | customer_orderDefaultArgs<ExtArgs>
  }

  export type $product_multiple_imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_multiple_images"
    objects: {
      customerOrderDetails: Prisma.$customer_orderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_order_id: number
      filename: string
    }, ExtArgs["result"]["product_multiple_images"]>
    composites: {}
  }

  type product_multiple_imagesGetPayload<S extends boolean | null | undefined | product_multiple_imagesDefaultArgs> = $Result.GetResult<Prisma.$product_multiple_imagesPayload, S>

  type product_multiple_imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<product_multiple_imagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Product_multiple_imagesCountAggregateInputType | true
    }

  export interface product_multiple_imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_multiple_images'], meta: { name: 'product_multiple_images' } }
    /**
     * Find zero or one Product_multiple_images that matches the filter.
     * @param {product_multiple_imagesFindUniqueArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends product_multiple_imagesFindUniqueArgs>(args: SelectSubset<T, product_multiple_imagesFindUniqueArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product_multiple_images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {product_multiple_imagesFindUniqueOrThrowArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends product_multiple_imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, product_multiple_imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_multiple_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesFindFirstArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends product_multiple_imagesFindFirstArgs>(args?: SelectSubset<T, product_multiple_imagesFindFirstArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_multiple_images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesFindFirstOrThrowArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends product_multiple_imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, product_multiple_imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Product_multiple_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findMany()
     * 
     * // Get first 10 Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_multiple_imagesWithIdOnly = await prisma.product_multiple_images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends product_multiple_imagesFindManyArgs>(args?: SelectSubset<T, product_multiple_imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product_multiple_images.
     * @param {product_multiple_imagesCreateArgs} args - Arguments to create a Product_multiple_images.
     * @example
     * // Create one Product_multiple_images
     * const Product_multiple_images = await prisma.product_multiple_images.create({
     *   data: {
     *     // ... data to create a Product_multiple_images
     *   }
     * })
     * 
     */
    create<T extends product_multiple_imagesCreateArgs>(args: SelectSubset<T, product_multiple_imagesCreateArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Product_multiple_images.
     * @param {product_multiple_imagesCreateManyArgs} args - Arguments to create many Product_multiple_images.
     * @example
     * // Create many Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends product_multiple_imagesCreateManyArgs>(args?: SelectSubset<T, product_multiple_imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_multiple_images.
     * @param {product_multiple_imagesDeleteArgs} args - Arguments to delete one Product_multiple_images.
     * @example
     * // Delete one Product_multiple_images
     * const Product_multiple_images = await prisma.product_multiple_images.delete({
     *   where: {
     *     // ... filter to delete one Product_multiple_images
     *   }
     * })
     * 
     */
    delete<T extends product_multiple_imagesDeleteArgs>(args: SelectSubset<T, product_multiple_imagesDeleteArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product_multiple_images.
     * @param {product_multiple_imagesUpdateArgs} args - Arguments to update one Product_multiple_images.
     * @example
     * // Update one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends product_multiple_imagesUpdateArgs>(args: SelectSubset<T, product_multiple_imagesUpdateArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Product_multiple_images.
     * @param {product_multiple_imagesDeleteManyArgs} args - Arguments to filter Product_multiple_images to delete.
     * @example
     * // Delete a few Product_multiple_images
     * const { count } = await prisma.product_multiple_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends product_multiple_imagesDeleteManyArgs>(args?: SelectSubset<T, product_multiple_imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends product_multiple_imagesUpdateManyArgs>(args: SelectSubset<T, product_multiple_imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_multiple_images.
     * @param {product_multiple_imagesUpsertArgs} args - Arguments to update or create a Product_multiple_images.
     * @example
     * // Update or create a Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.upsert({
     *   create: {
     *     // ... data to create a Product_multiple_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_multiple_images we want to update
     *   }
     * })
     */
    upsert<T extends product_multiple_imagesUpsertArgs>(args: SelectSubset<T, product_multiple_imagesUpsertArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesCountArgs} args - Arguments to filter Product_multiple_images to count.
     * @example
     * // Count the number of Product_multiple_images
     * const count = await prisma.product_multiple_images.count({
     *   where: {
     *     // ... the filter for the Product_multiple_images we want to count
     *   }
     * })
    **/
    count<T extends product_multiple_imagesCountArgs>(
      args?: Subset<T, product_multiple_imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_multiple_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_multiple_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_multiple_imagesAggregateArgs>(args: Subset<T, Product_multiple_imagesAggregateArgs>): Prisma.PrismaPromise<GetProduct_multiple_imagesAggregateType<T>>

    /**
     * Group by Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_multiple_imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_multiple_imagesGroupByArgs['orderBy'] }
        : { orderBy?: product_multiple_imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_multiple_imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_multiple_imagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_multiple_images model
   */
  readonly fields: product_multiple_imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_multiple_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_multiple_imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerOrderDetails<T extends customer_orderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customer_orderDefaultArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product_multiple_images model
   */
  interface product_multiple_imagesFieldRefs {
    readonly id: FieldRef<"product_multiple_images", 'Int'>
    readonly customer_order_id: FieldRef<"product_multiple_images", 'Int'>
    readonly filename: FieldRef<"product_multiple_images", 'String'>
  }
    

  // Custom InputTypes
  /**
   * product_multiple_images findUnique
   */
  export type product_multiple_imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images findUniqueOrThrow
   */
  export type product_multiple_imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images findFirst
   */
  export type product_multiple_imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_multiple_images.
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_multiple_images.
     */
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * product_multiple_images findFirstOrThrow
   */
  export type product_multiple_imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_multiple_images.
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_multiple_images.
     */
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * product_multiple_images findMany
   */
  export type product_multiple_imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_multiple_images.
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * product_multiple_images create
   */
  export type product_multiple_imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a product_multiple_images.
     */
    data: XOR<product_multiple_imagesCreateInput, product_multiple_imagesUncheckedCreateInput>
  }

  /**
   * product_multiple_images createMany
   */
  export type product_multiple_imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_multiple_images.
     */
    data: product_multiple_imagesCreateManyInput | product_multiple_imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product_multiple_images update
   */
  export type product_multiple_imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a product_multiple_images.
     */
    data: XOR<product_multiple_imagesUpdateInput, product_multiple_imagesUncheckedUpdateInput>
    /**
     * Choose, which product_multiple_images to update.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images updateMany
   */
  export type product_multiple_imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_multiple_images.
     */
    data: XOR<product_multiple_imagesUpdateManyMutationInput, product_multiple_imagesUncheckedUpdateManyInput>
    /**
     * Filter which product_multiple_images to update
     */
    where?: product_multiple_imagesWhereInput
    /**
     * Limit how many product_multiple_images to update.
     */
    limit?: number
  }

  /**
   * product_multiple_images upsert
   */
  export type product_multiple_imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the product_multiple_images to update in case it exists.
     */
    where: product_multiple_imagesWhereUniqueInput
    /**
     * In case the product_multiple_images found by the `where` argument doesn't exist, create a new product_multiple_images with this data.
     */
    create: XOR<product_multiple_imagesCreateInput, product_multiple_imagesUncheckedCreateInput>
    /**
     * In case the product_multiple_images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_multiple_imagesUpdateInput, product_multiple_imagesUncheckedUpdateInput>
  }

  /**
   * product_multiple_images delete
   */
  export type product_multiple_imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter which product_multiple_images to delete.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images deleteMany
   */
  export type product_multiple_imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_multiple_images to delete
     */
    where?: product_multiple_imagesWhereInput
    /**
     * Limit how many product_multiple_images to delete.
     */
    limit?: number
  }

  /**
   * product_multiple_images without action
   */
  export type product_multiple_imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
  }


  /**
   * Model MasterBullion
   */

  export type AggregateMasterBullion = {
    _count: MasterBullionCountAggregateOutputType | null
    _avg: MasterBullionAvgAggregateOutputType | null
    _sum: MasterBullionSumAggregateOutputType | null
    _min: MasterBullionMinAggregateOutputType | null
    _max: MasterBullionMaxAggregateOutputType | null
  }

  export type MasterBullionAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterBullionSumAggregateOutputType = {
    id: number | null
  }

  export type MasterBullionMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
  }

  export type MasterBullionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
  }

  export type MasterBullionCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    _all: number
  }


  export type MasterBullionAvgAggregateInputType = {
    id?: true
  }

  export type MasterBullionSumAggregateInputType = {
    id?: true
  }

  export type MasterBullionMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
  }

  export type MasterBullionMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
  }

  export type MasterBullionCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    _all?: true
  }

  export type MasterBullionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterBullion to aggregate.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterBullions
    **/
    _count?: true | MasterBullionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterBullionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterBullionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterBullionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterBullionMaxAggregateInputType
  }

  export type GetMasterBullionAggregateType<T extends MasterBullionAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterBullion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterBullion[P]>
      : GetScalarType<T[P], AggregateMasterBullion[P]>
  }




  export type MasterBullionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterBullionWhereInput
    orderBy?: MasterBullionOrderByWithAggregationInput | MasterBullionOrderByWithAggregationInput[]
    by: MasterBullionScalarFieldEnum[] | MasterBullionScalarFieldEnum
    having?: MasterBullionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterBullionCountAggregateInputType | true
    _avg?: MasterBullionAvgAggregateInputType
    _sum?: MasterBullionSumAggregateInputType
    _min?: MasterBullionMinAggregateInputType
    _max?: MasterBullionMaxAggregateInputType
  }

  export type MasterBullionGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    address: string | null
    _count: MasterBullionCountAggregateOutputType | null
    _avg: MasterBullionAvgAggregateOutputType | null
    _sum: MasterBullionSumAggregateOutputType | null
    _min: MasterBullionMinAggregateOutputType | null
    _max: MasterBullionMaxAggregateOutputType | null
  }

  type GetMasterBullionGroupByPayload<T extends MasterBullionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterBullionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterBullionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterBullionGroupByOutputType[P]>
            : GetScalarType<T[P], MasterBullionGroupByOutputType[P]>
        }
      >
    >


  export type MasterBullionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    purchases?: boolean | MasterBullion$purchasesArgs<ExtArgs>
    _count?: boolean | MasterBullionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterBullion"]>



  export type MasterBullionSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
  }

  export type MasterBullionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "address", ExtArgs["result"]["masterBullion"]>
  export type MasterBullionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | MasterBullion$purchasesArgs<ExtArgs>
    _count?: boolean | MasterBullionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MasterBullionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterBullion"
    objects: {
      purchases: Prisma.$BullionPurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      address: string | null
    }, ExtArgs["result"]["masterBullion"]>
    composites: {}
  }

  type MasterBullionGetPayload<S extends boolean | null | undefined | MasterBullionDefaultArgs> = $Result.GetResult<Prisma.$MasterBullionPayload, S>

  type MasterBullionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterBullionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterBullionCountAggregateInputType | true
    }

  export interface MasterBullionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterBullion'], meta: { name: 'MasterBullion' } }
    /**
     * Find zero or one MasterBullion that matches the filter.
     * @param {MasterBullionFindUniqueArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterBullionFindUniqueArgs>(args: SelectSubset<T, MasterBullionFindUniqueArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterBullion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterBullionFindUniqueOrThrowArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterBullionFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterBullionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterBullion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionFindFirstArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterBullionFindFirstArgs>(args?: SelectSubset<T, MasterBullionFindFirstArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterBullion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionFindFirstOrThrowArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterBullionFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterBullionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterBullions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterBullions
     * const masterBullions = await prisma.masterBullion.findMany()
     * 
     * // Get first 10 MasterBullions
     * const masterBullions = await prisma.masterBullion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterBullionWithIdOnly = await prisma.masterBullion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterBullionFindManyArgs>(args?: SelectSubset<T, MasterBullionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterBullion.
     * @param {MasterBullionCreateArgs} args - Arguments to create a MasterBullion.
     * @example
     * // Create one MasterBullion
     * const MasterBullion = await prisma.masterBullion.create({
     *   data: {
     *     // ... data to create a MasterBullion
     *   }
     * })
     * 
     */
    create<T extends MasterBullionCreateArgs>(args: SelectSubset<T, MasterBullionCreateArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterBullions.
     * @param {MasterBullionCreateManyArgs} args - Arguments to create many MasterBullions.
     * @example
     * // Create many MasterBullions
     * const masterBullion = await prisma.masterBullion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterBullionCreateManyArgs>(args?: SelectSubset<T, MasterBullionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterBullion.
     * @param {MasterBullionDeleteArgs} args - Arguments to delete one MasterBullion.
     * @example
     * // Delete one MasterBullion
     * const MasterBullion = await prisma.masterBullion.delete({
     *   where: {
     *     // ... filter to delete one MasterBullion
     *   }
     * })
     * 
     */
    delete<T extends MasterBullionDeleteArgs>(args: SelectSubset<T, MasterBullionDeleteArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterBullion.
     * @param {MasterBullionUpdateArgs} args - Arguments to update one MasterBullion.
     * @example
     * // Update one MasterBullion
     * const masterBullion = await prisma.masterBullion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterBullionUpdateArgs>(args: SelectSubset<T, MasterBullionUpdateArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterBullions.
     * @param {MasterBullionDeleteManyArgs} args - Arguments to filter MasterBullions to delete.
     * @example
     * // Delete a few MasterBullions
     * const { count } = await prisma.masterBullion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterBullionDeleteManyArgs>(args?: SelectSubset<T, MasterBullionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterBullions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterBullions
     * const masterBullion = await prisma.masterBullion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterBullionUpdateManyArgs>(args: SelectSubset<T, MasterBullionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterBullion.
     * @param {MasterBullionUpsertArgs} args - Arguments to update or create a MasterBullion.
     * @example
     * // Update or create a MasterBullion
     * const masterBullion = await prisma.masterBullion.upsert({
     *   create: {
     *     // ... data to create a MasterBullion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterBullion we want to update
     *   }
     * })
     */
    upsert<T extends MasterBullionUpsertArgs>(args: SelectSubset<T, MasterBullionUpsertArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterBullions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionCountArgs} args - Arguments to filter MasterBullions to count.
     * @example
     * // Count the number of MasterBullions
     * const count = await prisma.masterBullion.count({
     *   where: {
     *     // ... the filter for the MasterBullions we want to count
     *   }
     * })
    **/
    count<T extends MasterBullionCountArgs>(
      args?: Subset<T, MasterBullionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterBullionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterBullion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterBullionAggregateArgs>(args: Subset<T, MasterBullionAggregateArgs>): Prisma.PrismaPromise<GetMasterBullionAggregateType<T>>

    /**
     * Group by MasterBullion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterBullionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterBullionGroupByArgs['orderBy'] }
        : { orderBy?: MasterBullionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterBullionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterBullionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterBullion model
   */
  readonly fields: MasterBullionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterBullion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterBullionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchases<T extends MasterBullion$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, MasterBullion$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterBullion model
   */
  interface MasterBullionFieldRefs {
    readonly id: FieldRef<"MasterBullion", 'Int'>
    readonly name: FieldRef<"MasterBullion", 'String'>
    readonly phone: FieldRef<"MasterBullion", 'String'>
    readonly address: FieldRef<"MasterBullion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MasterBullion findUnique
   */
  export type MasterBullionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion findUniqueOrThrow
   */
  export type MasterBullionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion findFirst
   */
  export type MasterBullionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterBullions.
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterBullions.
     */
    distinct?: MasterBullionScalarFieldEnum | MasterBullionScalarFieldEnum[]
  }

  /**
   * MasterBullion findFirstOrThrow
   */
  export type MasterBullionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterBullions.
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterBullions.
     */
    distinct?: MasterBullionScalarFieldEnum | MasterBullionScalarFieldEnum[]
  }

  /**
   * MasterBullion findMany
   */
  export type MasterBullionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullions to fetch.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterBullions.
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    distinct?: MasterBullionScalarFieldEnum | MasterBullionScalarFieldEnum[]
  }

  /**
   * MasterBullion create
   */
  export type MasterBullionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * The data needed to create a MasterBullion.
     */
    data: XOR<MasterBullionCreateInput, MasterBullionUncheckedCreateInput>
  }

  /**
   * MasterBullion createMany
   */
  export type MasterBullionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterBullions.
     */
    data: MasterBullionCreateManyInput | MasterBullionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterBullion update
   */
  export type MasterBullionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * The data needed to update a MasterBullion.
     */
    data: XOR<MasterBullionUpdateInput, MasterBullionUncheckedUpdateInput>
    /**
     * Choose, which MasterBullion to update.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion updateMany
   */
  export type MasterBullionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterBullions.
     */
    data: XOR<MasterBullionUpdateManyMutationInput, MasterBullionUncheckedUpdateManyInput>
    /**
     * Filter which MasterBullions to update
     */
    where?: MasterBullionWhereInput
    /**
     * Limit how many MasterBullions to update.
     */
    limit?: number
  }

  /**
   * MasterBullion upsert
   */
  export type MasterBullionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * The filter to search for the MasterBullion to update in case it exists.
     */
    where: MasterBullionWhereUniqueInput
    /**
     * In case the MasterBullion found by the `where` argument doesn't exist, create a new MasterBullion with this data.
     */
    create: XOR<MasterBullionCreateInput, MasterBullionUncheckedCreateInput>
    /**
     * In case the MasterBullion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterBullionUpdateInput, MasterBullionUncheckedUpdateInput>
  }

  /**
   * MasterBullion delete
   */
  export type MasterBullionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter which MasterBullion to delete.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion deleteMany
   */
  export type MasterBullionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterBullions to delete
     */
    where?: MasterBullionWhereInput
    /**
     * Limit how many MasterBullions to delete.
     */
    limit?: number
  }

  /**
   * MasterBullion.purchases
   */
  export type MasterBullion$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    where?: BullionPurchaseWhereInput
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    cursor?: BullionPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * MasterBullion without action
   */
  export type MasterBullionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
  }


  /**
   * Model BullionPurchase
   */

  export type AggregateBullionPurchase = {
    _count: BullionPurchaseCountAggregateOutputType | null
    _avg: BullionPurchaseAvgAggregateOutputType | null
    _sum: BullionPurchaseSumAggregateOutputType | null
    _min: BullionPurchaseMinAggregateOutputType | null
    _max: BullionPurchaseMaxAggregateOutputType | null
  }

  export type BullionPurchaseAvgAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
  }

  export type BullionPurchaseSumAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
  }

  export type BullionPurchaseMinAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
    createdAt: Date | null
  }

  export type BullionPurchaseMaxAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
    createdAt: Date | null
  }

  export type BullionPurchaseCountAggregateOutputType = {
    id: number
    bullionId: number
    grams: number
    touch: number
    purity: number
    rate: number
    amount: number
    balance: number
    createdAt: number
    _all: number
  }


  export type BullionPurchaseAvgAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
  }

  export type BullionPurchaseSumAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
  }

  export type BullionPurchaseMinAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
    createdAt?: true
  }

  export type BullionPurchaseMaxAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
    createdAt?: true
  }

  export type BullionPurchaseCountAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
    createdAt?: true
    _all?: true
  }

  export type BullionPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BullionPurchase to aggregate.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BullionPurchases
    **/
    _count?: true | BullionPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BullionPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BullionPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BullionPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BullionPurchaseMaxAggregateInputType
  }

  export type GetBullionPurchaseAggregateType<T extends BullionPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateBullionPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBullionPurchase[P]>
      : GetScalarType<T[P], AggregateBullionPurchase[P]>
  }




  export type BullionPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BullionPurchaseWhereInput
    orderBy?: BullionPurchaseOrderByWithAggregationInput | BullionPurchaseOrderByWithAggregationInput[]
    by: BullionPurchaseScalarFieldEnum[] | BullionPurchaseScalarFieldEnum
    having?: BullionPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BullionPurchaseCountAggregateInputType | true
    _avg?: BullionPurchaseAvgAggregateInputType
    _sum?: BullionPurchaseSumAggregateInputType
    _min?: BullionPurchaseMinAggregateInputType
    _max?: BullionPurchaseMaxAggregateInputType
  }

  export type BullionPurchaseGroupByOutputType = {
    id: number
    bullionId: number
    grams: number
    touch: number | null
    purity: number | null
    rate: number
    amount: number
    balance: number
    createdAt: Date
    _count: BullionPurchaseCountAggregateOutputType | null
    _avg: BullionPurchaseAvgAggregateOutputType | null
    _sum: BullionPurchaseSumAggregateOutputType | null
    _min: BullionPurchaseMinAggregateOutputType | null
    _max: BullionPurchaseMaxAggregateOutputType | null
  }

  type GetBullionPurchaseGroupByPayload<T extends BullionPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BullionPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BullionPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BullionPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], BullionPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type BullionPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bullionId?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    rate?: boolean
    amount?: boolean
    balance?: boolean
    createdAt?: boolean
    bullion?: boolean | MasterBullionDefaultArgs<ExtArgs>
    givenDetails?: boolean | BullionPurchase$givenDetailsArgs<ExtArgs>
    _count?: boolean | BullionPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bullionPurchase"]>



  export type BullionPurchaseSelectScalar = {
    id?: boolean
    bullionId?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    rate?: boolean
    amount?: boolean
    balance?: boolean
    createdAt?: boolean
  }

  export type BullionPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bullionId" | "grams" | "touch" | "purity" | "rate" | "amount" | "balance" | "createdAt", ExtArgs["result"]["bullionPurchase"]>
  export type BullionPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bullion?: boolean | MasterBullionDefaultArgs<ExtArgs>
    givenDetails?: boolean | BullionPurchase$givenDetailsArgs<ExtArgs>
    _count?: boolean | BullionPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BullionPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BullionPurchase"
    objects: {
      bullion: Prisma.$MasterBullionPayload<ExtArgs>
      givenDetails: Prisma.$GivenDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bullionId: number
      grams: number
      touch: number | null
      purity: number | null
      rate: number
      amount: number
      balance: number
      createdAt: Date
    }, ExtArgs["result"]["bullionPurchase"]>
    composites: {}
  }

  type BullionPurchaseGetPayload<S extends boolean | null | undefined | BullionPurchaseDefaultArgs> = $Result.GetResult<Prisma.$BullionPurchasePayload, S>

  type BullionPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BullionPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BullionPurchaseCountAggregateInputType | true
    }

  export interface BullionPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BullionPurchase'], meta: { name: 'BullionPurchase' } }
    /**
     * Find zero or one BullionPurchase that matches the filter.
     * @param {BullionPurchaseFindUniqueArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BullionPurchaseFindUniqueArgs>(args: SelectSubset<T, BullionPurchaseFindUniqueArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BullionPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BullionPurchaseFindUniqueOrThrowArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BullionPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, BullionPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BullionPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseFindFirstArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BullionPurchaseFindFirstArgs>(args?: SelectSubset<T, BullionPurchaseFindFirstArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BullionPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseFindFirstOrThrowArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BullionPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, BullionPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BullionPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BullionPurchases
     * const bullionPurchases = await prisma.bullionPurchase.findMany()
     * 
     * // Get first 10 BullionPurchases
     * const bullionPurchases = await prisma.bullionPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bullionPurchaseWithIdOnly = await prisma.bullionPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BullionPurchaseFindManyArgs>(args?: SelectSubset<T, BullionPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BullionPurchase.
     * @param {BullionPurchaseCreateArgs} args - Arguments to create a BullionPurchase.
     * @example
     * // Create one BullionPurchase
     * const BullionPurchase = await prisma.bullionPurchase.create({
     *   data: {
     *     // ... data to create a BullionPurchase
     *   }
     * })
     * 
     */
    create<T extends BullionPurchaseCreateArgs>(args: SelectSubset<T, BullionPurchaseCreateArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BullionPurchases.
     * @param {BullionPurchaseCreateManyArgs} args - Arguments to create many BullionPurchases.
     * @example
     * // Create many BullionPurchases
     * const bullionPurchase = await prisma.bullionPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BullionPurchaseCreateManyArgs>(args?: SelectSubset<T, BullionPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BullionPurchase.
     * @param {BullionPurchaseDeleteArgs} args - Arguments to delete one BullionPurchase.
     * @example
     * // Delete one BullionPurchase
     * const BullionPurchase = await prisma.bullionPurchase.delete({
     *   where: {
     *     // ... filter to delete one BullionPurchase
     *   }
     * })
     * 
     */
    delete<T extends BullionPurchaseDeleteArgs>(args: SelectSubset<T, BullionPurchaseDeleteArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BullionPurchase.
     * @param {BullionPurchaseUpdateArgs} args - Arguments to update one BullionPurchase.
     * @example
     * // Update one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BullionPurchaseUpdateArgs>(args: SelectSubset<T, BullionPurchaseUpdateArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BullionPurchases.
     * @param {BullionPurchaseDeleteManyArgs} args - Arguments to filter BullionPurchases to delete.
     * @example
     * // Delete a few BullionPurchases
     * const { count } = await prisma.bullionPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BullionPurchaseDeleteManyArgs>(args?: SelectSubset<T, BullionPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BullionPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BullionPurchases
     * const bullionPurchase = await prisma.bullionPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BullionPurchaseUpdateManyArgs>(args: SelectSubset<T, BullionPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BullionPurchase.
     * @param {BullionPurchaseUpsertArgs} args - Arguments to update or create a BullionPurchase.
     * @example
     * // Update or create a BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.upsert({
     *   create: {
     *     // ... data to create a BullionPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BullionPurchase we want to update
     *   }
     * })
     */
    upsert<T extends BullionPurchaseUpsertArgs>(args: SelectSubset<T, BullionPurchaseUpsertArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BullionPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseCountArgs} args - Arguments to filter BullionPurchases to count.
     * @example
     * // Count the number of BullionPurchases
     * const count = await prisma.bullionPurchase.count({
     *   where: {
     *     // ... the filter for the BullionPurchases we want to count
     *   }
     * })
    **/
    count<T extends BullionPurchaseCountArgs>(
      args?: Subset<T, BullionPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BullionPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BullionPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BullionPurchaseAggregateArgs>(args: Subset<T, BullionPurchaseAggregateArgs>): Prisma.PrismaPromise<GetBullionPurchaseAggregateType<T>>

    /**
     * Group by BullionPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BullionPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BullionPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: BullionPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BullionPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBullionPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BullionPurchase model
   */
  readonly fields: BullionPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BullionPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BullionPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bullion<T extends MasterBullionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MasterBullionDefaultArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    givenDetails<T extends BullionPurchase$givenDetailsArgs<ExtArgs> = {}>(args?: Subset<T, BullionPurchase$givenDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BullionPurchase model
   */
  interface BullionPurchaseFieldRefs {
    readonly id: FieldRef<"BullionPurchase", 'Int'>
    readonly bullionId: FieldRef<"BullionPurchase", 'Int'>
    readonly grams: FieldRef<"BullionPurchase", 'Float'>
    readonly touch: FieldRef<"BullionPurchase", 'Float'>
    readonly purity: FieldRef<"BullionPurchase", 'Float'>
    readonly rate: FieldRef<"BullionPurchase", 'Float'>
    readonly amount: FieldRef<"BullionPurchase", 'Float'>
    readonly balance: FieldRef<"BullionPurchase", 'Float'>
    readonly createdAt: FieldRef<"BullionPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BullionPurchase findUnique
   */
  export type BullionPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase findUniqueOrThrow
   */
  export type BullionPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase findFirst
   */
  export type BullionPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BullionPurchases.
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BullionPurchases.
     */
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * BullionPurchase findFirstOrThrow
   */
  export type BullionPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BullionPurchases.
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BullionPurchases.
     */
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * BullionPurchase findMany
   */
  export type BullionPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchases to fetch.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BullionPurchases.
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * BullionPurchase create
   */
  export type BullionPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a BullionPurchase.
     */
    data: XOR<BullionPurchaseCreateInput, BullionPurchaseUncheckedCreateInput>
  }

  /**
   * BullionPurchase createMany
   */
  export type BullionPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BullionPurchases.
     */
    data: BullionPurchaseCreateManyInput | BullionPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BullionPurchase update
   */
  export type BullionPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a BullionPurchase.
     */
    data: XOR<BullionPurchaseUpdateInput, BullionPurchaseUncheckedUpdateInput>
    /**
     * Choose, which BullionPurchase to update.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase updateMany
   */
  export type BullionPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BullionPurchases.
     */
    data: XOR<BullionPurchaseUpdateManyMutationInput, BullionPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which BullionPurchases to update
     */
    where?: BullionPurchaseWhereInput
    /**
     * Limit how many BullionPurchases to update.
     */
    limit?: number
  }

  /**
   * BullionPurchase upsert
   */
  export type BullionPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the BullionPurchase to update in case it exists.
     */
    where: BullionPurchaseWhereUniqueInput
    /**
     * In case the BullionPurchase found by the `where` argument doesn't exist, create a new BullionPurchase with this data.
     */
    create: XOR<BullionPurchaseCreateInput, BullionPurchaseUncheckedCreateInput>
    /**
     * In case the BullionPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BullionPurchaseUpdateInput, BullionPurchaseUncheckedUpdateInput>
  }

  /**
   * BullionPurchase delete
   */
  export type BullionPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter which BullionPurchase to delete.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase deleteMany
   */
  export type BullionPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BullionPurchases to delete
     */
    where?: BullionPurchaseWhereInput
    /**
     * Limit how many BullionPurchases to delete.
     */
    limit?: number
  }

  /**
   * BullionPurchase.givenDetails
   */
  export type BullionPurchase$givenDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    where?: GivenDetailWhereInput
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    cursor?: GivenDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * BullionPurchase without action
   */
  export type BullionPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model GivenDetail
   */

  export type AggregateGivenDetail = {
    _count: GivenDetailCountAggregateOutputType | null
    _avg: GivenDetailAvgAggregateOutputType | null
    _sum: GivenDetailSumAggregateOutputType | null
    _min: GivenDetailMinAggregateOutputType | null
    _max: GivenDetailMaxAggregateOutputType | null
  }

  export type GivenDetailAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailSumAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailMinAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailCountAggregateOutputType = {
    id: number
    amount: number
    grams: number
    touch: number
    purity: number
    purchaseId: number
    _all: number
  }


  export type GivenDetailAvgAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailSumAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailMinAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailMaxAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailCountAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
    _all?: true
  }

  export type GivenDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GivenDetail to aggregate.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GivenDetails
    **/
    _count?: true | GivenDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GivenDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GivenDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GivenDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GivenDetailMaxAggregateInputType
  }

  export type GetGivenDetailAggregateType<T extends GivenDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateGivenDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGivenDetail[P]>
      : GetScalarType<T[P], AggregateGivenDetail[P]>
  }




  export type GivenDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GivenDetailWhereInput
    orderBy?: GivenDetailOrderByWithAggregationInput | GivenDetailOrderByWithAggregationInput[]
    by: GivenDetailScalarFieldEnum[] | GivenDetailScalarFieldEnum
    having?: GivenDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GivenDetailCountAggregateInputType | true
    _avg?: GivenDetailAvgAggregateInputType
    _sum?: GivenDetailSumAggregateInputType
    _min?: GivenDetailMinAggregateInputType
    _max?: GivenDetailMaxAggregateInputType
  }

  export type GivenDetailGroupByOutputType = {
    id: number
    amount: number
    grams: number
    touch: number | null
    purity: number | null
    purchaseId: number
    _count: GivenDetailCountAggregateOutputType | null
    _avg: GivenDetailAvgAggregateOutputType | null
    _sum: GivenDetailSumAggregateOutputType | null
    _min: GivenDetailMinAggregateOutputType | null
    _max: GivenDetailMaxAggregateOutputType | null
  }

  type GetGivenDetailGroupByPayload<T extends GivenDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GivenDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GivenDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GivenDetailGroupByOutputType[P]>
            : GetScalarType<T[P], GivenDetailGroupByOutputType[P]>
        }
      >
    >


  export type GivenDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    purchaseId?: boolean
    bullionPurchase?: boolean | BullionPurchaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["givenDetail"]>



  export type GivenDetailSelectScalar = {
    id?: boolean
    amount?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    purchaseId?: boolean
  }

  export type GivenDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "grams" | "touch" | "purity" | "purchaseId", ExtArgs["result"]["givenDetail"]>
  export type GivenDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bullionPurchase?: boolean | BullionPurchaseDefaultArgs<ExtArgs>
  }

  export type $GivenDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GivenDetail"
    objects: {
      bullionPurchase: Prisma.$BullionPurchasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      grams: number
      touch: number | null
      purity: number | null
      purchaseId: number
    }, ExtArgs["result"]["givenDetail"]>
    composites: {}
  }

  type GivenDetailGetPayload<S extends boolean | null | undefined | GivenDetailDefaultArgs> = $Result.GetResult<Prisma.$GivenDetailPayload, S>

  type GivenDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GivenDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GivenDetailCountAggregateInputType | true
    }

  export interface GivenDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GivenDetail'], meta: { name: 'GivenDetail' } }
    /**
     * Find zero or one GivenDetail that matches the filter.
     * @param {GivenDetailFindUniqueArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GivenDetailFindUniqueArgs>(args: SelectSubset<T, GivenDetailFindUniqueArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GivenDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GivenDetailFindUniqueOrThrowArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GivenDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, GivenDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailFindFirstArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GivenDetailFindFirstArgs>(args?: SelectSubset<T, GivenDetailFindFirstArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailFindFirstOrThrowArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GivenDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, GivenDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GivenDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GivenDetails
     * const givenDetails = await prisma.givenDetail.findMany()
     * 
     * // Get first 10 GivenDetails
     * const givenDetails = await prisma.givenDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const givenDetailWithIdOnly = await prisma.givenDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GivenDetailFindManyArgs>(args?: SelectSubset<T, GivenDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GivenDetail.
     * @param {GivenDetailCreateArgs} args - Arguments to create a GivenDetail.
     * @example
     * // Create one GivenDetail
     * const GivenDetail = await prisma.givenDetail.create({
     *   data: {
     *     // ... data to create a GivenDetail
     *   }
     * })
     * 
     */
    create<T extends GivenDetailCreateArgs>(args: SelectSubset<T, GivenDetailCreateArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GivenDetails.
     * @param {GivenDetailCreateManyArgs} args - Arguments to create many GivenDetails.
     * @example
     * // Create many GivenDetails
     * const givenDetail = await prisma.givenDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GivenDetailCreateManyArgs>(args?: SelectSubset<T, GivenDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GivenDetail.
     * @param {GivenDetailDeleteArgs} args - Arguments to delete one GivenDetail.
     * @example
     * // Delete one GivenDetail
     * const GivenDetail = await prisma.givenDetail.delete({
     *   where: {
     *     // ... filter to delete one GivenDetail
     *   }
     * })
     * 
     */
    delete<T extends GivenDetailDeleteArgs>(args: SelectSubset<T, GivenDetailDeleteArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GivenDetail.
     * @param {GivenDetailUpdateArgs} args - Arguments to update one GivenDetail.
     * @example
     * // Update one GivenDetail
     * const givenDetail = await prisma.givenDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GivenDetailUpdateArgs>(args: SelectSubset<T, GivenDetailUpdateArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GivenDetails.
     * @param {GivenDetailDeleteManyArgs} args - Arguments to filter GivenDetails to delete.
     * @example
     * // Delete a few GivenDetails
     * const { count } = await prisma.givenDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GivenDetailDeleteManyArgs>(args?: SelectSubset<T, GivenDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GivenDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GivenDetails
     * const givenDetail = await prisma.givenDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GivenDetailUpdateManyArgs>(args: SelectSubset<T, GivenDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GivenDetail.
     * @param {GivenDetailUpsertArgs} args - Arguments to update or create a GivenDetail.
     * @example
     * // Update or create a GivenDetail
     * const givenDetail = await prisma.givenDetail.upsert({
     *   create: {
     *     // ... data to create a GivenDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GivenDetail we want to update
     *   }
     * })
     */
    upsert<T extends GivenDetailUpsertArgs>(args: SelectSubset<T, GivenDetailUpsertArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GivenDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailCountArgs} args - Arguments to filter GivenDetails to count.
     * @example
     * // Count the number of GivenDetails
     * const count = await prisma.givenDetail.count({
     *   where: {
     *     // ... the filter for the GivenDetails we want to count
     *   }
     * })
    **/
    count<T extends GivenDetailCountArgs>(
      args?: Subset<T, GivenDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GivenDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GivenDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GivenDetailAggregateArgs>(args: Subset<T, GivenDetailAggregateArgs>): Prisma.PrismaPromise<GetGivenDetailAggregateType<T>>

    /**
     * Group by GivenDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GivenDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GivenDetailGroupByArgs['orderBy'] }
        : { orderBy?: GivenDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GivenDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGivenDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GivenDetail model
   */
  readonly fields: GivenDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GivenDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GivenDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bullionPurchase<T extends BullionPurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BullionPurchaseDefaultArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GivenDetail model
   */
  interface GivenDetailFieldRefs {
    readonly id: FieldRef<"GivenDetail", 'Int'>
    readonly amount: FieldRef<"GivenDetail", 'Float'>
    readonly grams: FieldRef<"GivenDetail", 'Float'>
    readonly touch: FieldRef<"GivenDetail", 'Float'>
    readonly purity: FieldRef<"GivenDetail", 'Float'>
    readonly purchaseId: FieldRef<"GivenDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GivenDetail findUnique
   */
  export type GivenDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail findUniqueOrThrow
   */
  export type GivenDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail findFirst
   */
  export type GivenDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GivenDetails.
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GivenDetails.
     */
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * GivenDetail findFirstOrThrow
   */
  export type GivenDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GivenDetails.
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GivenDetails.
     */
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * GivenDetail findMany
   */
  export type GivenDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetails to fetch.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GivenDetails.
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * GivenDetail create
   */
  export type GivenDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a GivenDetail.
     */
    data: XOR<GivenDetailCreateInput, GivenDetailUncheckedCreateInput>
  }

  /**
   * GivenDetail createMany
   */
  export type GivenDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GivenDetails.
     */
    data: GivenDetailCreateManyInput | GivenDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GivenDetail update
   */
  export type GivenDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a GivenDetail.
     */
    data: XOR<GivenDetailUpdateInput, GivenDetailUncheckedUpdateInput>
    /**
     * Choose, which GivenDetail to update.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail updateMany
   */
  export type GivenDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GivenDetails.
     */
    data: XOR<GivenDetailUpdateManyMutationInput, GivenDetailUncheckedUpdateManyInput>
    /**
     * Filter which GivenDetails to update
     */
    where?: GivenDetailWhereInput
    /**
     * Limit how many GivenDetails to update.
     */
    limit?: number
  }

  /**
   * GivenDetail upsert
   */
  export type GivenDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the GivenDetail to update in case it exists.
     */
    where: GivenDetailWhereUniqueInput
    /**
     * In case the GivenDetail found by the `where` argument doesn't exist, create a new GivenDetail with this data.
     */
    create: XOR<GivenDetailCreateInput, GivenDetailUncheckedCreateInput>
    /**
     * In case the GivenDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GivenDetailUpdateInput, GivenDetailUncheckedUpdateInput>
  }

  /**
   * GivenDetail delete
   */
  export type GivenDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter which GivenDetail to delete.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail deleteMany
   */
  export type GivenDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GivenDetails to delete
     */
    where?: GivenDetailWhereInput
    /**
     * Limit how many GivenDetails to delete.
     */
    limit?: number
  }

  /**
   * GivenDetail without action
   */
  export type GivenDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
  }


  /**
   * Model Goldsmith
   */

  export type AggregateGoldsmith = {
    _count: GoldsmithCountAggregateOutputType | null
    _avg: GoldsmithAvgAggregateOutputType | null
    _sum: GoldsmithSumAggregateOutputType | null
    _min: GoldsmithMinAggregateOutputType | null
    _max: GoldsmithMaxAggregateOutputType | null
  }

  export type GoldsmithAvgAggregateOutputType = {
    id: number | null
  }

  export type GoldsmithSumAggregateOutputType = {
    id: number | null
  }

  export type GoldsmithMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoldsmithMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoldsmithCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoldsmithAvgAggregateInputType = {
    id?: true
  }

  export type GoldsmithSumAggregateInputType = {
    id?: true
  }

  export type GoldsmithMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoldsmithMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoldsmithCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoldsmithAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goldsmith to aggregate.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goldsmiths
    **/
    _count?: true | GoldsmithCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoldsmithAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoldsmithSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoldsmithMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoldsmithMaxAggregateInputType
  }

  export type GetGoldsmithAggregateType<T extends GoldsmithAggregateArgs> = {
        [P in keyof T & keyof AggregateGoldsmith]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoldsmith[P]>
      : GetScalarType<T[P], AggregateGoldsmith[P]>
  }




  export type GoldsmithGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoldsmithWhereInput
    orderBy?: GoldsmithOrderByWithAggregationInput | GoldsmithOrderByWithAggregationInput[]
    by: GoldsmithScalarFieldEnum[] | GoldsmithScalarFieldEnum
    having?: GoldsmithScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoldsmithCountAggregateInputType | true
    _avg?: GoldsmithAvgAggregateInputType
    _sum?: GoldsmithSumAggregateInputType
    _min?: GoldsmithMinAggregateInputType
    _max?: GoldsmithMaxAggregateInputType
  }

  export type GoldsmithGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: GoldsmithCountAggregateOutputType | null
    _avg: GoldsmithAvgAggregateOutputType | null
    _sum: GoldsmithSumAggregateOutputType | null
    _min: GoldsmithMinAggregateOutputType | null
    _max: GoldsmithMaxAggregateOutputType | null
  }

  type GetGoldsmithGroupByPayload<T extends GoldsmithGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoldsmithGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoldsmithGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoldsmithGroupByOutputType[P]>
            : GetScalarType<T[P], GoldsmithGroupByOutputType[P]>
        }
      >
    >


  export type GoldsmithSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobcards?: boolean | Goldsmith$jobcardsArgs<ExtArgs>
    givenGold?: boolean | Goldsmith$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Goldsmith$deliveriesArgs<ExtArgs>
    received?: boolean | Goldsmith$receivedArgs<ExtArgs>
    totals?: boolean | Goldsmith$totalsArgs<ExtArgs>
    repairs?: boolean | Goldsmith$repairsArgs<ExtArgs>
    summaries?: boolean | Goldsmith$summariesArgs<ExtArgs>
    _count?: boolean | GoldsmithCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goldsmith"]>



  export type GoldsmithSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoldsmithOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["goldsmith"]>
  export type GoldsmithInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobcards?: boolean | Goldsmith$jobcardsArgs<ExtArgs>
    givenGold?: boolean | Goldsmith$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Goldsmith$deliveriesArgs<ExtArgs>
    received?: boolean | Goldsmith$receivedArgs<ExtArgs>
    totals?: boolean | Goldsmith$totalsArgs<ExtArgs>
    repairs?: boolean | Goldsmith$repairsArgs<ExtArgs>
    summaries?: boolean | Goldsmith$summariesArgs<ExtArgs>
    _count?: boolean | GoldsmithCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GoldsmithPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goldsmith"
    objects: {
      jobcards: Prisma.$JobcardPayload<ExtArgs>[]
      givenGold: Prisma.$givenGoldPayload<ExtArgs>[]
      deliveries: Prisma.$itemDeliveryPayload<ExtArgs>[]
      received: Prisma.$ReceivedsectionPayload<ExtArgs>[]
      totals: Prisma.$TotalPayload<ExtArgs>[]
      repairs: Prisma.$RepairPayload<ExtArgs>[]
      summaries: Prisma.$BalancesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goldsmith"]>
    composites: {}
  }

  type GoldsmithGetPayload<S extends boolean | null | undefined | GoldsmithDefaultArgs> = $Result.GetResult<Prisma.$GoldsmithPayload, S>

  type GoldsmithCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoldsmithFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoldsmithCountAggregateInputType | true
    }

  export interface GoldsmithDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goldsmith'], meta: { name: 'Goldsmith' } }
    /**
     * Find zero or one Goldsmith that matches the filter.
     * @param {GoldsmithFindUniqueArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoldsmithFindUniqueArgs>(args: SelectSubset<T, GoldsmithFindUniqueArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Goldsmith that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoldsmithFindUniqueOrThrowArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoldsmithFindUniqueOrThrowArgs>(args: SelectSubset<T, GoldsmithFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goldsmith that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithFindFirstArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoldsmithFindFirstArgs>(args?: SelectSubset<T, GoldsmithFindFirstArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goldsmith that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithFindFirstOrThrowArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoldsmithFindFirstOrThrowArgs>(args?: SelectSubset<T, GoldsmithFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Goldsmiths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goldsmiths
     * const goldsmiths = await prisma.goldsmith.findMany()
     * 
     * // Get first 10 Goldsmiths
     * const goldsmiths = await prisma.goldsmith.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goldsmithWithIdOnly = await prisma.goldsmith.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoldsmithFindManyArgs>(args?: SelectSubset<T, GoldsmithFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Goldsmith.
     * @param {GoldsmithCreateArgs} args - Arguments to create a Goldsmith.
     * @example
     * // Create one Goldsmith
     * const Goldsmith = await prisma.goldsmith.create({
     *   data: {
     *     // ... data to create a Goldsmith
     *   }
     * })
     * 
     */
    create<T extends GoldsmithCreateArgs>(args: SelectSubset<T, GoldsmithCreateArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Goldsmiths.
     * @param {GoldsmithCreateManyArgs} args - Arguments to create many Goldsmiths.
     * @example
     * // Create many Goldsmiths
     * const goldsmith = await prisma.goldsmith.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoldsmithCreateManyArgs>(args?: SelectSubset<T, GoldsmithCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Goldsmith.
     * @param {GoldsmithDeleteArgs} args - Arguments to delete one Goldsmith.
     * @example
     * // Delete one Goldsmith
     * const Goldsmith = await prisma.goldsmith.delete({
     *   where: {
     *     // ... filter to delete one Goldsmith
     *   }
     * })
     * 
     */
    delete<T extends GoldsmithDeleteArgs>(args: SelectSubset<T, GoldsmithDeleteArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Goldsmith.
     * @param {GoldsmithUpdateArgs} args - Arguments to update one Goldsmith.
     * @example
     * // Update one Goldsmith
     * const goldsmith = await prisma.goldsmith.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoldsmithUpdateArgs>(args: SelectSubset<T, GoldsmithUpdateArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Goldsmiths.
     * @param {GoldsmithDeleteManyArgs} args - Arguments to filter Goldsmiths to delete.
     * @example
     * // Delete a few Goldsmiths
     * const { count } = await prisma.goldsmith.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoldsmithDeleteManyArgs>(args?: SelectSubset<T, GoldsmithDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goldsmiths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goldsmiths
     * const goldsmith = await prisma.goldsmith.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoldsmithUpdateManyArgs>(args: SelectSubset<T, GoldsmithUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Goldsmith.
     * @param {GoldsmithUpsertArgs} args - Arguments to update or create a Goldsmith.
     * @example
     * // Update or create a Goldsmith
     * const goldsmith = await prisma.goldsmith.upsert({
     *   create: {
     *     // ... data to create a Goldsmith
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goldsmith we want to update
     *   }
     * })
     */
    upsert<T extends GoldsmithUpsertArgs>(args: SelectSubset<T, GoldsmithUpsertArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Goldsmiths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithCountArgs} args - Arguments to filter Goldsmiths to count.
     * @example
     * // Count the number of Goldsmiths
     * const count = await prisma.goldsmith.count({
     *   where: {
     *     // ... the filter for the Goldsmiths we want to count
     *   }
     * })
    **/
    count<T extends GoldsmithCountArgs>(
      args?: Subset<T, GoldsmithCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoldsmithCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goldsmith.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoldsmithAggregateArgs>(args: Subset<T, GoldsmithAggregateArgs>): Prisma.PrismaPromise<GetGoldsmithAggregateType<T>>

    /**
     * Group by Goldsmith.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoldsmithGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoldsmithGroupByArgs['orderBy'] }
        : { orderBy?: GoldsmithGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoldsmithGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoldsmithGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goldsmith model
   */
  readonly fields: GoldsmithFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goldsmith.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoldsmithClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobcards<T extends Goldsmith$jobcardsArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$jobcardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    givenGold<T extends Goldsmith$givenGoldArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$givenGoldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Goldsmith$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    received<T extends Goldsmith$receivedArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$receivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    totals<T extends Goldsmith$totalsArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$totalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    repairs<T extends Goldsmith$repairsArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$repairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summaries<T extends Goldsmith$summariesArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$summariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goldsmith model
   */
  interface GoldsmithFieldRefs {
    readonly id: FieldRef<"Goldsmith", 'Int'>
    readonly name: FieldRef<"Goldsmith", 'String'>
    readonly phone: FieldRef<"Goldsmith", 'String'>
    readonly address: FieldRef<"Goldsmith", 'String'>
    readonly createdAt: FieldRef<"Goldsmith", 'DateTime'>
    readonly updatedAt: FieldRef<"Goldsmith", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Goldsmith findUnique
   */
  export type GoldsmithFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith findUniqueOrThrow
   */
  export type GoldsmithFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith findFirst
   */
  export type GoldsmithFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goldsmiths.
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goldsmiths.
     */
    distinct?: GoldsmithScalarFieldEnum | GoldsmithScalarFieldEnum[]
  }

  /**
   * Goldsmith findFirstOrThrow
   */
  export type GoldsmithFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goldsmiths.
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goldsmiths.
     */
    distinct?: GoldsmithScalarFieldEnum | GoldsmithScalarFieldEnum[]
  }

  /**
   * Goldsmith findMany
   */
  export type GoldsmithFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmiths to fetch.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goldsmiths.
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    distinct?: GoldsmithScalarFieldEnum | GoldsmithScalarFieldEnum[]
  }

  /**
   * Goldsmith create
   */
  export type GoldsmithCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * The data needed to create a Goldsmith.
     */
    data: XOR<GoldsmithCreateInput, GoldsmithUncheckedCreateInput>
  }

  /**
   * Goldsmith createMany
   */
  export type GoldsmithCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goldsmiths.
     */
    data: GoldsmithCreateManyInput | GoldsmithCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goldsmith update
   */
  export type GoldsmithUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * The data needed to update a Goldsmith.
     */
    data: XOR<GoldsmithUpdateInput, GoldsmithUncheckedUpdateInput>
    /**
     * Choose, which Goldsmith to update.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith updateMany
   */
  export type GoldsmithUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goldsmiths.
     */
    data: XOR<GoldsmithUpdateManyMutationInput, GoldsmithUncheckedUpdateManyInput>
    /**
     * Filter which Goldsmiths to update
     */
    where?: GoldsmithWhereInput
    /**
     * Limit how many Goldsmiths to update.
     */
    limit?: number
  }

  /**
   * Goldsmith upsert
   */
  export type GoldsmithUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * The filter to search for the Goldsmith to update in case it exists.
     */
    where: GoldsmithWhereUniqueInput
    /**
     * In case the Goldsmith found by the `where` argument doesn't exist, create a new Goldsmith with this data.
     */
    create: XOR<GoldsmithCreateInput, GoldsmithUncheckedCreateInput>
    /**
     * In case the Goldsmith was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoldsmithUpdateInput, GoldsmithUncheckedUpdateInput>
  }

  /**
   * Goldsmith delete
   */
  export type GoldsmithDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter which Goldsmith to delete.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith deleteMany
   */
  export type GoldsmithDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goldsmiths to delete
     */
    where?: GoldsmithWhereInput
    /**
     * Limit how many Goldsmiths to delete.
     */
    limit?: number
  }

  /**
   * Goldsmith.jobcards
   */
  export type Goldsmith$jobcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    cursor?: JobcardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Goldsmith.givenGold
   */
  export type Goldsmith$givenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    where?: givenGoldWhereInput
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    cursor?: givenGoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * Goldsmith.deliveries
   */
  export type Goldsmith$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    where?: itemDeliveryWhereInput
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    cursor?: itemDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * Goldsmith.received
   */
  export type Goldsmith$receivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    where?: ReceivedsectionWhereInput
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    cursor?: ReceivedsectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Goldsmith.totals
   */
  export type Goldsmith$totalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    where?: TotalWhereInput
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    cursor?: TotalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Goldsmith.repairs
   */
  export type Goldsmith$repairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    where?: RepairWhereInput
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    cursor?: RepairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Goldsmith.summaries
   */
  export type Goldsmith$summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    where?: BalancesWhereInput
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    cursor?: BalancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Goldsmith without action
   */
  export type GoldsmithDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
  }


  /**
   * Model Jobcard
   */

  export type AggregateJobcard = {
    _count: JobcardCountAggregateOutputType | null
    _avg: JobcardAvgAggregateOutputType | null
    _sum: JobcardSumAggregateOutputType | null
    _min: JobcardMinAggregateOutputType | null
    _max: JobcardMaxAggregateOutputType | null
  }

  export type JobcardAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
  }

  export type JobcardSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
  }

  export type JobcardMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    description: string | null
    stockIsMove: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobcardMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    description: string | null
    stockIsMove: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobcardCountAggregateOutputType = {
    id: number
    goldsmithId: number
    description: number
    stockIsMove: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobcardAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
  }

  export type JobcardSumAggregateInputType = {
    id?: true
    goldsmithId?: true
  }

  export type JobcardMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    description?: true
    stockIsMove?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobcardMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    description?: true
    stockIsMove?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobcardCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    description?: true
    stockIsMove?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobcardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobcard to aggregate.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobcards
    **/
    _count?: true | JobcardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobcardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobcardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobcardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobcardMaxAggregateInputType
  }

  export type GetJobcardAggregateType<T extends JobcardAggregateArgs> = {
        [P in keyof T & keyof AggregateJobcard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobcard[P]>
      : GetScalarType<T[P], AggregateJobcard[P]>
  }




  export type JobcardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobcardWhereInput
    orderBy?: JobcardOrderByWithAggregationInput | JobcardOrderByWithAggregationInput[]
    by: JobcardScalarFieldEnum[] | JobcardScalarFieldEnum
    having?: JobcardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobcardCountAggregateInputType | true
    _avg?: JobcardAvgAggregateInputType
    _sum?: JobcardSumAggregateInputType
    _min?: JobcardMinAggregateInputType
    _max?: JobcardMaxAggregateInputType
  }

  export type JobcardGroupByOutputType = {
    id: number
    goldsmithId: number
    description: string | null
    stockIsMove: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: JobcardCountAggregateOutputType | null
    _avg: JobcardAvgAggregateOutputType | null
    _sum: JobcardSumAggregateOutputType | null
    _min: JobcardMinAggregateOutputType | null
    _max: JobcardMaxAggregateOutputType | null
  }

  type GetJobcardGroupByPayload<T extends JobcardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobcardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobcardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobcardGroupByOutputType[P]>
            : GetScalarType<T[P], JobcardGroupByOutputType[P]>
        }
      >
    >


  export type JobcardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    description?: boolean
    stockIsMove?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
    givenGold?: boolean | Jobcard$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Jobcard$deliveriesArgs<ExtArgs>
    received?: boolean | Jobcard$receivedArgs<ExtArgs>
    productStock?: boolean | Jobcard$productStockArgs<ExtArgs>
    total?: boolean | Jobcard$totalArgs<ExtArgs>
    _count?: boolean | JobcardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobcard"]>



  export type JobcardSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    description?: boolean
    stockIsMove?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobcardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "description" | "stockIsMove" | "createdAt" | "updatedAt", ExtArgs["result"]["jobcard"]>
  export type JobcardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
    givenGold?: boolean | Jobcard$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Jobcard$deliveriesArgs<ExtArgs>
    received?: boolean | Jobcard$receivedArgs<ExtArgs>
    productStock?: boolean | Jobcard$productStockArgs<ExtArgs>
    total?: boolean | Jobcard$totalArgs<ExtArgs>
    _count?: boolean | JobcardCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobcardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobcard"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
      givenGold: Prisma.$givenGoldPayload<ExtArgs>[]
      deliveries: Prisma.$itemDeliveryPayload<ExtArgs>[]
      received: Prisma.$ReceivedsectionPayload<ExtArgs>[]
      productStock: Prisma.$ProductStockPayload<ExtArgs>[]
      total: Prisma.$TotalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number
      description: string | null
      stockIsMove: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobcard"]>
    composites: {}
  }

  type JobcardGetPayload<S extends boolean | null | undefined | JobcardDefaultArgs> = $Result.GetResult<Prisma.$JobcardPayload, S>

  type JobcardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobcardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobcardCountAggregateInputType | true
    }

  export interface JobcardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobcard'], meta: { name: 'Jobcard' } }
    /**
     * Find zero or one Jobcard that matches the filter.
     * @param {JobcardFindUniqueArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobcardFindUniqueArgs>(args: SelectSubset<T, JobcardFindUniqueArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobcard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobcardFindUniqueOrThrowArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobcardFindUniqueOrThrowArgs>(args: SelectSubset<T, JobcardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobcard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardFindFirstArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobcardFindFirstArgs>(args?: SelectSubset<T, JobcardFindFirstArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobcard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardFindFirstOrThrowArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobcardFindFirstOrThrowArgs>(args?: SelectSubset<T, JobcardFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobcards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobcards
     * const jobcards = await prisma.jobcard.findMany()
     * 
     * // Get first 10 Jobcards
     * const jobcards = await prisma.jobcard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobcardWithIdOnly = await prisma.jobcard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobcardFindManyArgs>(args?: SelectSubset<T, JobcardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobcard.
     * @param {JobcardCreateArgs} args - Arguments to create a Jobcard.
     * @example
     * // Create one Jobcard
     * const Jobcard = await prisma.jobcard.create({
     *   data: {
     *     // ... data to create a Jobcard
     *   }
     * })
     * 
     */
    create<T extends JobcardCreateArgs>(args: SelectSubset<T, JobcardCreateArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobcards.
     * @param {JobcardCreateManyArgs} args - Arguments to create many Jobcards.
     * @example
     * // Create many Jobcards
     * const jobcard = await prisma.jobcard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobcardCreateManyArgs>(args?: SelectSubset<T, JobcardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobcard.
     * @param {JobcardDeleteArgs} args - Arguments to delete one Jobcard.
     * @example
     * // Delete one Jobcard
     * const Jobcard = await prisma.jobcard.delete({
     *   where: {
     *     // ... filter to delete one Jobcard
     *   }
     * })
     * 
     */
    delete<T extends JobcardDeleteArgs>(args: SelectSubset<T, JobcardDeleteArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobcard.
     * @param {JobcardUpdateArgs} args - Arguments to update one Jobcard.
     * @example
     * // Update one Jobcard
     * const jobcard = await prisma.jobcard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobcardUpdateArgs>(args: SelectSubset<T, JobcardUpdateArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobcards.
     * @param {JobcardDeleteManyArgs} args - Arguments to filter Jobcards to delete.
     * @example
     * // Delete a few Jobcards
     * const { count } = await prisma.jobcard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobcardDeleteManyArgs>(args?: SelectSubset<T, JobcardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobcards
     * const jobcard = await prisma.jobcard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobcardUpdateManyArgs>(args: SelectSubset<T, JobcardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobcard.
     * @param {JobcardUpsertArgs} args - Arguments to update or create a Jobcard.
     * @example
     * // Update or create a Jobcard
     * const jobcard = await prisma.jobcard.upsert({
     *   create: {
     *     // ... data to create a Jobcard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobcard we want to update
     *   }
     * })
     */
    upsert<T extends JobcardUpsertArgs>(args: SelectSubset<T, JobcardUpsertArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardCountArgs} args - Arguments to filter Jobcards to count.
     * @example
     * // Count the number of Jobcards
     * const count = await prisma.jobcard.count({
     *   where: {
     *     // ... the filter for the Jobcards we want to count
     *   }
     * })
    **/
    count<T extends JobcardCountArgs>(
      args?: Subset<T, JobcardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobcardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobcardAggregateArgs>(args: Subset<T, JobcardAggregateArgs>): Prisma.PrismaPromise<GetJobcardAggregateType<T>>

    /**
     * Group by Jobcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobcardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobcardGroupByArgs['orderBy'] }
        : { orderBy?: JobcardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobcardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobcardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobcard model
   */
  readonly fields: JobcardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobcard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobcardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    givenGold<T extends Jobcard$givenGoldArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$givenGoldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Jobcard$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    received<T extends Jobcard$receivedArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$receivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productStock<T extends Jobcard$productStockArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$productStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    total<T extends Jobcard$totalArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$totalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobcard model
   */
  interface JobcardFieldRefs {
    readonly id: FieldRef<"Jobcard", 'Int'>
    readonly goldsmithId: FieldRef<"Jobcard", 'Int'>
    readonly description: FieldRef<"Jobcard", 'String'>
    readonly stockIsMove: FieldRef<"Jobcard", 'Boolean'>
    readonly createdAt: FieldRef<"Jobcard", 'DateTime'>
    readonly updatedAt: FieldRef<"Jobcard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Jobcard findUnique
   */
  export type JobcardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard findUniqueOrThrow
   */
  export type JobcardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard findFirst
   */
  export type JobcardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobcards.
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobcards.
     */
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Jobcard findFirstOrThrow
   */
  export type JobcardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobcards.
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobcards.
     */
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Jobcard findMany
   */
  export type JobcardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcards to fetch.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobcards.
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Jobcard create
   */
  export type JobcardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * The data needed to create a Jobcard.
     */
    data: XOR<JobcardCreateInput, JobcardUncheckedCreateInput>
  }

  /**
   * Jobcard createMany
   */
  export type JobcardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobcards.
     */
    data: JobcardCreateManyInput | JobcardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jobcard update
   */
  export type JobcardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * The data needed to update a Jobcard.
     */
    data: XOR<JobcardUpdateInput, JobcardUncheckedUpdateInput>
    /**
     * Choose, which Jobcard to update.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard updateMany
   */
  export type JobcardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobcards.
     */
    data: XOR<JobcardUpdateManyMutationInput, JobcardUncheckedUpdateManyInput>
    /**
     * Filter which Jobcards to update
     */
    where?: JobcardWhereInput
    /**
     * Limit how many Jobcards to update.
     */
    limit?: number
  }

  /**
   * Jobcard upsert
   */
  export type JobcardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * The filter to search for the Jobcard to update in case it exists.
     */
    where: JobcardWhereUniqueInput
    /**
     * In case the Jobcard found by the `where` argument doesn't exist, create a new Jobcard with this data.
     */
    create: XOR<JobcardCreateInput, JobcardUncheckedCreateInput>
    /**
     * In case the Jobcard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobcardUpdateInput, JobcardUncheckedUpdateInput>
  }

  /**
   * Jobcard delete
   */
  export type JobcardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter which Jobcard to delete.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard deleteMany
   */
  export type JobcardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobcards to delete
     */
    where?: JobcardWhereInput
    /**
     * Limit how many Jobcards to delete.
     */
    limit?: number
  }

  /**
   * Jobcard.givenGold
   */
  export type Jobcard$givenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    where?: givenGoldWhereInput
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    cursor?: givenGoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * Jobcard.deliveries
   */
  export type Jobcard$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    where?: itemDeliveryWhereInput
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    cursor?: itemDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * Jobcard.received
   */
  export type Jobcard$receivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    where?: ReceivedsectionWhereInput
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    cursor?: ReceivedsectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Jobcard.productStock
   */
  export type Jobcard$productStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    cursor?: ProductStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * Jobcard.total
   */
  export type Jobcard$totalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    where?: TotalWhereInput
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    cursor?: TotalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Jobcard without action
   */
  export type JobcardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
  }


  /**
   * Model givenGold
   */

  export type AggregateGivenGold = {
    _count: GivenGoldCountAggregateOutputType | null
    _avg: GivenGoldAvgAggregateOutputType | null
    _sum: GivenGoldSumAggregateOutputType | null
    _min: GivenGoldMinAggregateOutputType | null
    _max: GivenGoldMaxAggregateOutputType | null
  }

  export type GivenGoldAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    logId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    finaltouch: number | null
    finalPurity: number | null
    copperPurity: number | null
  }

  export type GivenGoldSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    logId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    finaltouch: number | null
    finalPurity: number | null
    copperPurity: number | null
  }

  export type GivenGoldMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    logId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    finaltouch: number | null
    finalPurity: number | null
    copperPurity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GivenGoldMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    logId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    finaltouch: number | null
    finalPurity: number | null
    copperPurity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GivenGoldCountAggregateOutputType = {
    id: number
    goldsmithId: number
    jobcardId: number
    logId: number
    weight: number
    touch: number
    purity: number
    finaltouch: number
    finalPurity: number
    copperPurity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GivenGoldAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    logId?: true
    weight?: true
    touch?: true
    purity?: true
    finaltouch?: true
    finalPurity?: true
    copperPurity?: true
  }

  export type GivenGoldSumAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    logId?: true
    weight?: true
    touch?: true
    purity?: true
    finaltouch?: true
    finalPurity?: true
    copperPurity?: true
  }

  export type GivenGoldMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    logId?: true
    weight?: true
    touch?: true
    purity?: true
    finaltouch?: true
    finalPurity?: true
    copperPurity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GivenGoldMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    logId?: true
    weight?: true
    touch?: true
    purity?: true
    finaltouch?: true
    finalPurity?: true
    copperPurity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GivenGoldCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    logId?: true
    weight?: true
    touch?: true
    purity?: true
    finaltouch?: true
    finalPurity?: true
    copperPurity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GivenGoldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which givenGold to aggregate.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned givenGolds
    **/
    _count?: true | GivenGoldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GivenGoldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GivenGoldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GivenGoldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GivenGoldMaxAggregateInputType
  }

  export type GetGivenGoldAggregateType<T extends GivenGoldAggregateArgs> = {
        [P in keyof T & keyof AggregateGivenGold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGivenGold[P]>
      : GetScalarType<T[P], AggregateGivenGold[P]>
  }




  export type givenGoldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: givenGoldWhereInput
    orderBy?: givenGoldOrderByWithAggregationInput | givenGoldOrderByWithAggregationInput[]
    by: GivenGoldScalarFieldEnum[] | GivenGoldScalarFieldEnum
    having?: givenGoldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GivenGoldCountAggregateInputType | true
    _avg?: GivenGoldAvgAggregateInputType
    _sum?: GivenGoldSumAggregateInputType
    _min?: GivenGoldMinAggregateInputType
    _max?: GivenGoldMaxAggregateInputType
  }

  export type GivenGoldGroupByOutputType = {
    id: number
    goldsmithId: number | null
    jobcardId: number | null
    logId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    finaltouch: number | null
    finalPurity: number | null
    copperPurity: number | null
    createdAt: Date
    updatedAt: Date
    _count: GivenGoldCountAggregateOutputType | null
    _avg: GivenGoldAvgAggregateOutputType | null
    _sum: GivenGoldSumAggregateOutputType | null
    _min: GivenGoldMinAggregateOutputType | null
    _max: GivenGoldMaxAggregateOutputType | null
  }

  type GetGivenGoldGroupByPayload<T extends givenGoldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GivenGoldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GivenGoldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GivenGoldGroupByOutputType[P]>
            : GetScalarType<T[P], GivenGoldGroupByOutputType[P]>
        }
      >
    >


  export type givenGoldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    logId?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    finaltouch?: boolean
    finalPurity?: boolean
    copperPurity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | givenGold$goldsmithArgs<ExtArgs>
    jobcard?: boolean | givenGold$jobcardArgs<ExtArgs>
    rawGoldLogs?: boolean | givenGold$rawGoldLogsArgs<ExtArgs>
  }, ExtArgs["result"]["givenGold"]>



  export type givenGoldSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    logId?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    finaltouch?: boolean
    finalPurity?: boolean
    copperPurity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type givenGoldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "jobcardId" | "logId" | "weight" | "touch" | "purity" | "finaltouch" | "finalPurity" | "copperPurity" | "createdAt" | "updatedAt", ExtArgs["result"]["givenGold"]>
  export type givenGoldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | givenGold$goldsmithArgs<ExtArgs>
    jobcard?: boolean | givenGold$jobcardArgs<ExtArgs>
    rawGoldLogs?: boolean | givenGold$rawGoldLogsArgs<ExtArgs>
  }

  export type $givenGoldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "givenGold"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs> | null
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
      rawGoldLogs: Prisma.$RawGoldLogsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number | null
      jobcardId: number | null
      logId: number | null
      weight: number | null
      touch: number | null
      purity: number | null
      finaltouch: number | null
      finalPurity: number | null
      copperPurity: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["givenGold"]>
    composites: {}
  }

  type givenGoldGetPayload<S extends boolean | null | undefined | givenGoldDefaultArgs> = $Result.GetResult<Prisma.$givenGoldPayload, S>

  type givenGoldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<givenGoldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GivenGoldCountAggregateInputType | true
    }

  export interface givenGoldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['givenGold'], meta: { name: 'givenGold' } }
    /**
     * Find zero or one GivenGold that matches the filter.
     * @param {givenGoldFindUniqueArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends givenGoldFindUniqueArgs>(args: SelectSubset<T, givenGoldFindUniqueArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GivenGold that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {givenGoldFindUniqueOrThrowArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends givenGoldFindUniqueOrThrowArgs>(args: SelectSubset<T, givenGoldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenGold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldFindFirstArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends givenGoldFindFirstArgs>(args?: SelectSubset<T, givenGoldFindFirstArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenGold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldFindFirstOrThrowArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends givenGoldFindFirstOrThrowArgs>(args?: SelectSubset<T, givenGoldFindFirstOrThrowArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GivenGolds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GivenGolds
     * const givenGolds = await prisma.givenGold.findMany()
     * 
     * // Get first 10 GivenGolds
     * const givenGolds = await prisma.givenGold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const givenGoldWithIdOnly = await prisma.givenGold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends givenGoldFindManyArgs>(args?: SelectSubset<T, givenGoldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GivenGold.
     * @param {givenGoldCreateArgs} args - Arguments to create a GivenGold.
     * @example
     * // Create one GivenGold
     * const GivenGold = await prisma.givenGold.create({
     *   data: {
     *     // ... data to create a GivenGold
     *   }
     * })
     * 
     */
    create<T extends givenGoldCreateArgs>(args: SelectSubset<T, givenGoldCreateArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GivenGolds.
     * @param {givenGoldCreateManyArgs} args - Arguments to create many GivenGolds.
     * @example
     * // Create many GivenGolds
     * const givenGold = await prisma.givenGold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends givenGoldCreateManyArgs>(args?: SelectSubset<T, givenGoldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GivenGold.
     * @param {givenGoldDeleteArgs} args - Arguments to delete one GivenGold.
     * @example
     * // Delete one GivenGold
     * const GivenGold = await prisma.givenGold.delete({
     *   where: {
     *     // ... filter to delete one GivenGold
     *   }
     * })
     * 
     */
    delete<T extends givenGoldDeleteArgs>(args: SelectSubset<T, givenGoldDeleteArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GivenGold.
     * @param {givenGoldUpdateArgs} args - Arguments to update one GivenGold.
     * @example
     * // Update one GivenGold
     * const givenGold = await prisma.givenGold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends givenGoldUpdateArgs>(args: SelectSubset<T, givenGoldUpdateArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GivenGolds.
     * @param {givenGoldDeleteManyArgs} args - Arguments to filter GivenGolds to delete.
     * @example
     * // Delete a few GivenGolds
     * const { count } = await prisma.givenGold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends givenGoldDeleteManyArgs>(args?: SelectSubset<T, givenGoldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GivenGolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GivenGolds
     * const givenGold = await prisma.givenGold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends givenGoldUpdateManyArgs>(args: SelectSubset<T, givenGoldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GivenGold.
     * @param {givenGoldUpsertArgs} args - Arguments to update or create a GivenGold.
     * @example
     * // Update or create a GivenGold
     * const givenGold = await prisma.givenGold.upsert({
     *   create: {
     *     // ... data to create a GivenGold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GivenGold we want to update
     *   }
     * })
     */
    upsert<T extends givenGoldUpsertArgs>(args: SelectSubset<T, givenGoldUpsertArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GivenGolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldCountArgs} args - Arguments to filter GivenGolds to count.
     * @example
     * // Count the number of GivenGolds
     * const count = await prisma.givenGold.count({
     *   where: {
     *     // ... the filter for the GivenGolds we want to count
     *   }
     * })
    **/
    count<T extends givenGoldCountArgs>(
      args?: Subset<T, givenGoldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GivenGoldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GivenGold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenGoldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GivenGoldAggregateArgs>(args: Subset<T, GivenGoldAggregateArgs>): Prisma.PrismaPromise<GetGivenGoldAggregateType<T>>

    /**
     * Group by GivenGold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends givenGoldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: givenGoldGroupByArgs['orderBy'] }
        : { orderBy?: givenGoldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, givenGoldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGivenGoldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the givenGold model
   */
  readonly fields: givenGoldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for givenGold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__givenGoldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends givenGold$goldsmithArgs<ExtArgs> = {}>(args?: Subset<T, givenGold$goldsmithArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobcard<T extends givenGold$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, givenGold$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rawGoldLogs<T extends givenGold$rawGoldLogsArgs<ExtArgs> = {}>(args?: Subset<T, givenGold$rawGoldLogsArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the givenGold model
   */
  interface givenGoldFieldRefs {
    readonly id: FieldRef<"givenGold", 'Int'>
    readonly goldsmithId: FieldRef<"givenGold", 'Int'>
    readonly jobcardId: FieldRef<"givenGold", 'Int'>
    readonly logId: FieldRef<"givenGold", 'Int'>
    readonly weight: FieldRef<"givenGold", 'Float'>
    readonly touch: FieldRef<"givenGold", 'Float'>
    readonly purity: FieldRef<"givenGold", 'Float'>
    readonly finaltouch: FieldRef<"givenGold", 'Float'>
    readonly finalPurity: FieldRef<"givenGold", 'Float'>
    readonly copperPurity: FieldRef<"givenGold", 'Float'>
    readonly createdAt: FieldRef<"givenGold", 'DateTime'>
    readonly updatedAt: FieldRef<"givenGold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * givenGold findUnique
   */
  export type givenGoldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold findUniqueOrThrow
   */
  export type givenGoldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold findFirst
   */
  export type givenGoldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for givenGolds.
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of givenGolds.
     */
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * givenGold findFirstOrThrow
   */
  export type givenGoldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for givenGolds.
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of givenGolds.
     */
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * givenGold findMany
   */
  export type givenGoldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGolds to fetch.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing givenGolds.
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * givenGold create
   */
  export type givenGoldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * The data needed to create a givenGold.
     */
    data?: XOR<givenGoldCreateInput, givenGoldUncheckedCreateInput>
  }

  /**
   * givenGold createMany
   */
  export type givenGoldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many givenGolds.
     */
    data: givenGoldCreateManyInput | givenGoldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * givenGold update
   */
  export type givenGoldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * The data needed to update a givenGold.
     */
    data: XOR<givenGoldUpdateInput, givenGoldUncheckedUpdateInput>
    /**
     * Choose, which givenGold to update.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold updateMany
   */
  export type givenGoldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update givenGolds.
     */
    data: XOR<givenGoldUpdateManyMutationInput, givenGoldUncheckedUpdateManyInput>
    /**
     * Filter which givenGolds to update
     */
    where?: givenGoldWhereInput
    /**
     * Limit how many givenGolds to update.
     */
    limit?: number
  }

  /**
   * givenGold upsert
   */
  export type givenGoldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * The filter to search for the givenGold to update in case it exists.
     */
    where: givenGoldWhereUniqueInput
    /**
     * In case the givenGold found by the `where` argument doesn't exist, create a new givenGold with this data.
     */
    create: XOR<givenGoldCreateInput, givenGoldUncheckedCreateInput>
    /**
     * In case the givenGold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<givenGoldUpdateInput, givenGoldUncheckedUpdateInput>
  }

  /**
   * givenGold delete
   */
  export type givenGoldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter which givenGold to delete.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold deleteMany
   */
  export type givenGoldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which givenGolds to delete
     */
    where?: givenGoldWhereInput
    /**
     * Limit how many givenGolds to delete.
     */
    limit?: number
  }

  /**
   * givenGold.goldsmith
   */
  export type givenGold$goldsmithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    where?: GoldsmithWhereInput
  }

  /**
   * givenGold.jobcard
   */
  export type givenGold$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * givenGold.rawGoldLogs
   */
  export type givenGold$rawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    where?: RawGoldLogsWhereInput
  }

  /**
   * givenGold without action
   */
  export type givenGoldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
  }


  /**
   * Model itemDelivery
   */

  export type AggregateItemDelivery = {
    _count: ItemDeliveryCountAggregateOutputType | null
    _avg: ItemDeliveryAvgAggregateOutputType | null
    _sum: ItemDeliverySumAggregateOutputType | null
    _min: ItemDeliveryMinAggregateOutputType | null
    _max: ItemDeliveryMaxAggregateOutputType | null
  }

  export type ItemDeliveryAvgAggregateOutputType = {
    id: number | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    netWeight: number | null
    wastageValue: number | null
    wastagePure: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
  }

  export type ItemDeliverySumAggregateOutputType = {
    id: number | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    netWeight: number | null
    wastageValue: number | null
    wastagePure: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
  }

  export type ItemDeliveryMinAggregateOutputType = {
    id: number | null
    itemName: string | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    sealName: string | null
    netWeight: number | null
    wastageType: string | null
    wastageValue: number | null
    wastagePure: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemDeliveryMaxAggregateOutputType = {
    id: number | null
    itemName: string | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    sealName: string | null
    netWeight: number | null
    wastageType: string | null
    wastageValue: number | null
    wastagePure: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemDeliveryCountAggregateOutputType = {
    id: number
    itemName: number
    itemWeight: number
    count: number
    touch: number
    sealName: number
    netWeight: number
    wastageType: number
    wastageValue: number
    wastagePure: number
    finalPurity: number
    goldsmithId: number
    jobcardId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemDeliveryAvgAggregateInputType = {
    id?: true
    itemWeight?: true
    count?: true
    touch?: true
    netWeight?: true
    wastageValue?: true
    wastagePure?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
  }

  export type ItemDeliverySumAggregateInputType = {
    id?: true
    itemWeight?: true
    count?: true
    touch?: true
    netWeight?: true
    wastageValue?: true
    wastagePure?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
  }

  export type ItemDeliveryMinAggregateInputType = {
    id?: true
    itemName?: true
    itemWeight?: true
    count?: true
    touch?: true
    sealName?: true
    netWeight?: true
    wastageType?: true
    wastageValue?: true
    wastagePure?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemDeliveryMaxAggregateInputType = {
    id?: true
    itemName?: true
    itemWeight?: true
    count?: true
    touch?: true
    sealName?: true
    netWeight?: true
    wastageType?: true
    wastageValue?: true
    wastagePure?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemDeliveryCountAggregateInputType = {
    id?: true
    itemName?: true
    itemWeight?: true
    count?: true
    touch?: true
    sealName?: true
    netWeight?: true
    wastageType?: true
    wastageValue?: true
    wastagePure?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemDelivery to aggregate.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned itemDeliveries
    **/
    _count?: true | ItemDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemDeliveryMaxAggregateInputType
  }

  export type GetItemDeliveryAggregateType<T extends ItemDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemDelivery[P]>
      : GetScalarType<T[P], AggregateItemDelivery[P]>
  }




  export type itemDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemDeliveryWhereInput
    orderBy?: itemDeliveryOrderByWithAggregationInput | itemDeliveryOrderByWithAggregationInput[]
    by: ItemDeliveryScalarFieldEnum[] | ItemDeliveryScalarFieldEnum
    having?: itemDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemDeliveryCountAggregateInputType | true
    _avg?: ItemDeliveryAvgAggregateInputType
    _sum?: ItemDeliverySumAggregateInputType
    _min?: ItemDeliveryMinAggregateInputType
    _max?: ItemDeliveryMaxAggregateInputType
  }

  export type ItemDeliveryGroupByOutputType = {
    id: number
    itemName: string | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    sealName: string | null
    netWeight: number | null
    wastageType: string | null
    wastageValue: number | null
    wastagePure: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ItemDeliveryCountAggregateOutputType | null
    _avg: ItemDeliveryAvgAggregateOutputType | null
    _sum: ItemDeliverySumAggregateOutputType | null
    _min: ItemDeliveryMinAggregateOutputType | null
    _max: ItemDeliveryMaxAggregateOutputType | null
  }

  type GetItemDeliveryGroupByPayload<T extends itemDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type itemDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemName?: boolean
    itemWeight?: boolean
    count?: boolean
    touch?: boolean
    sealName?: boolean
    netWeight?: boolean
    wastageType?: boolean
    wastageValue?: boolean
    wastagePure?: boolean
    finalPurity?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | itemDelivery$goldsmithArgs<ExtArgs>
    jobcard?: boolean | itemDelivery$jobcardArgs<ExtArgs>
    deduction?: boolean | itemDelivery$deductionArgs<ExtArgs>
    _count?: boolean | ItemDeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemDelivery"]>



  export type itemDeliverySelectScalar = {
    id?: boolean
    itemName?: boolean
    itemWeight?: boolean
    count?: boolean
    touch?: boolean
    sealName?: boolean
    netWeight?: boolean
    wastageType?: boolean
    wastageValue?: boolean
    wastagePure?: boolean
    finalPurity?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type itemDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemName" | "itemWeight" | "count" | "touch" | "sealName" | "netWeight" | "wastageType" | "wastageValue" | "wastagePure" | "finalPurity" | "goldsmithId" | "jobcardId" | "createdAt" | "updatedAt", ExtArgs["result"]["itemDelivery"]>
  export type itemDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | itemDelivery$goldsmithArgs<ExtArgs>
    jobcard?: boolean | itemDelivery$jobcardArgs<ExtArgs>
    deduction?: boolean | itemDelivery$deductionArgs<ExtArgs>
    _count?: boolean | ItemDeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $itemDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "itemDelivery"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs> | null
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
      deduction: Prisma.$deductionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemName: string | null
      itemWeight: number | null
      count: number | null
      touch: number | null
      sealName: string | null
      netWeight: number | null
      wastageType: string | null
      wastageValue: number | null
      wastagePure: number | null
      finalPurity: number | null
      goldsmithId: number | null
      jobcardId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemDelivery"]>
    composites: {}
  }

  type itemDeliveryGetPayload<S extends boolean | null | undefined | itemDeliveryDefaultArgs> = $Result.GetResult<Prisma.$itemDeliveryPayload, S>

  type itemDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemDeliveryCountAggregateInputType | true
    }

  export interface itemDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['itemDelivery'], meta: { name: 'itemDelivery' } }
    /**
     * Find zero or one ItemDelivery that matches the filter.
     * @param {itemDeliveryFindUniqueArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemDeliveryFindUniqueArgs>(args: SelectSubset<T, itemDeliveryFindUniqueArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemDeliveryFindUniqueOrThrowArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, itemDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryFindFirstArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemDeliveryFindFirstArgs>(args?: SelectSubset<T, itemDeliveryFindFirstArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryFindFirstOrThrowArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, itemDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemDeliveries
     * const itemDeliveries = await prisma.itemDelivery.findMany()
     * 
     * // Get first 10 ItemDeliveries
     * const itemDeliveries = await prisma.itemDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemDeliveryWithIdOnly = await prisma.itemDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemDeliveryFindManyArgs>(args?: SelectSubset<T, itemDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemDelivery.
     * @param {itemDeliveryCreateArgs} args - Arguments to create a ItemDelivery.
     * @example
     * // Create one ItemDelivery
     * const ItemDelivery = await prisma.itemDelivery.create({
     *   data: {
     *     // ... data to create a ItemDelivery
     *   }
     * })
     * 
     */
    create<T extends itemDeliveryCreateArgs>(args: SelectSubset<T, itemDeliveryCreateArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemDeliveries.
     * @param {itemDeliveryCreateManyArgs} args - Arguments to create many ItemDeliveries.
     * @example
     * // Create many ItemDeliveries
     * const itemDelivery = await prisma.itemDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemDeliveryCreateManyArgs>(args?: SelectSubset<T, itemDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemDelivery.
     * @param {itemDeliveryDeleteArgs} args - Arguments to delete one ItemDelivery.
     * @example
     * // Delete one ItemDelivery
     * const ItemDelivery = await prisma.itemDelivery.delete({
     *   where: {
     *     // ... filter to delete one ItemDelivery
     *   }
     * })
     * 
     */
    delete<T extends itemDeliveryDeleteArgs>(args: SelectSubset<T, itemDeliveryDeleteArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemDelivery.
     * @param {itemDeliveryUpdateArgs} args - Arguments to update one ItemDelivery.
     * @example
     * // Update one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemDeliveryUpdateArgs>(args: SelectSubset<T, itemDeliveryUpdateArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemDeliveries.
     * @param {itemDeliveryDeleteManyArgs} args - Arguments to filter ItemDeliveries to delete.
     * @example
     * // Delete a few ItemDeliveries
     * const { count } = await prisma.itemDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemDeliveryDeleteManyArgs>(args?: SelectSubset<T, itemDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemDeliveries
     * const itemDelivery = await prisma.itemDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemDeliveryUpdateManyArgs>(args: SelectSubset<T, itemDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemDelivery.
     * @param {itemDeliveryUpsertArgs} args - Arguments to update or create a ItemDelivery.
     * @example
     * // Update or create a ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.upsert({
     *   create: {
     *     // ... data to create a ItemDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemDelivery we want to update
     *   }
     * })
     */
    upsert<T extends itemDeliveryUpsertArgs>(args: SelectSubset<T, itemDeliveryUpsertArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryCountArgs} args - Arguments to filter ItemDeliveries to count.
     * @example
     * // Count the number of ItemDeliveries
     * const count = await prisma.itemDelivery.count({
     *   where: {
     *     // ... the filter for the ItemDeliveries we want to count
     *   }
     * })
    **/
    count<T extends itemDeliveryCountArgs>(
      args?: Subset<T, itemDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemDeliveryAggregateArgs>(args: Subset<T, ItemDeliveryAggregateArgs>): Prisma.PrismaPromise<GetItemDeliveryAggregateType<T>>

    /**
     * Group by ItemDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: itemDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the itemDelivery model
   */
  readonly fields: itemDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itemDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends itemDelivery$goldsmithArgs<ExtArgs> = {}>(args?: Subset<T, itemDelivery$goldsmithArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobcard<T extends itemDelivery$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, itemDelivery$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deduction<T extends itemDelivery$deductionArgs<ExtArgs> = {}>(args?: Subset<T, itemDelivery$deductionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the itemDelivery model
   */
  interface itemDeliveryFieldRefs {
    readonly id: FieldRef<"itemDelivery", 'Int'>
    readonly itemName: FieldRef<"itemDelivery", 'String'>
    readonly itemWeight: FieldRef<"itemDelivery", 'Float'>
    readonly count: FieldRef<"itemDelivery", 'Int'>
    readonly touch: FieldRef<"itemDelivery", 'Float'>
    readonly sealName: FieldRef<"itemDelivery", 'String'>
    readonly netWeight: FieldRef<"itemDelivery", 'Float'>
    readonly wastageType: FieldRef<"itemDelivery", 'String'>
    readonly wastageValue: FieldRef<"itemDelivery", 'Float'>
    readonly wastagePure: FieldRef<"itemDelivery", 'Float'>
    readonly finalPurity: FieldRef<"itemDelivery", 'Float'>
    readonly goldsmithId: FieldRef<"itemDelivery", 'Int'>
    readonly jobcardId: FieldRef<"itemDelivery", 'Int'>
    readonly createdAt: FieldRef<"itemDelivery", 'DateTime'>
    readonly updatedAt: FieldRef<"itemDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * itemDelivery findUnique
   */
  export type itemDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery findUniqueOrThrow
   */
  export type itemDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery findFirst
   */
  export type itemDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemDeliveries.
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemDeliveries.
     */
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * itemDelivery findFirstOrThrow
   */
  export type itemDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemDeliveries.
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemDeliveries.
     */
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * itemDelivery findMany
   */
  export type itemDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDeliveries to fetch.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing itemDeliveries.
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * itemDelivery create
   */
  export type itemDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a itemDelivery.
     */
    data?: XOR<itemDeliveryCreateInput, itemDeliveryUncheckedCreateInput>
  }

  /**
   * itemDelivery createMany
   */
  export type itemDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many itemDeliveries.
     */
    data: itemDeliveryCreateManyInput | itemDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * itemDelivery update
   */
  export type itemDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a itemDelivery.
     */
    data: XOR<itemDeliveryUpdateInput, itemDeliveryUncheckedUpdateInput>
    /**
     * Choose, which itemDelivery to update.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery updateMany
   */
  export type itemDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update itemDeliveries.
     */
    data: XOR<itemDeliveryUpdateManyMutationInput, itemDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which itemDeliveries to update
     */
    where?: itemDeliveryWhereInput
    /**
     * Limit how many itemDeliveries to update.
     */
    limit?: number
  }

  /**
   * itemDelivery upsert
   */
  export type itemDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the itemDelivery to update in case it exists.
     */
    where: itemDeliveryWhereUniqueInput
    /**
     * In case the itemDelivery found by the `where` argument doesn't exist, create a new itemDelivery with this data.
     */
    create: XOR<itemDeliveryCreateInput, itemDeliveryUncheckedCreateInput>
    /**
     * In case the itemDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemDeliveryUpdateInput, itemDeliveryUncheckedUpdateInput>
  }

  /**
   * itemDelivery delete
   */
  export type itemDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter which itemDelivery to delete.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery deleteMany
   */
  export type itemDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemDeliveries to delete
     */
    where?: itemDeliveryWhereInput
    /**
     * Limit how many itemDeliveries to delete.
     */
    limit?: number
  }

  /**
   * itemDelivery.goldsmith
   */
  export type itemDelivery$goldsmithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    where?: GoldsmithWhereInput
  }

  /**
   * itemDelivery.jobcard
   */
  export type itemDelivery$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * itemDelivery.deduction
   */
  export type itemDelivery$deductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    where?: deductionWhereInput
    orderBy?: deductionOrderByWithRelationInput | deductionOrderByWithRelationInput[]
    cursor?: deductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeductionScalarFieldEnum | DeductionScalarFieldEnum[]
  }

  /**
   * itemDelivery without action
   */
  export type itemDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model deduction
   */

  export type AggregateDeduction = {
    _count: DeductionCountAggregateOutputType | null
    _avg: DeductionAvgAggregateOutputType | null
    _sum: DeductionSumAggregateOutputType | null
    _min: DeductionMinAggregateOutputType | null
    _max: DeductionMaxAggregateOutputType | null
  }

  export type DeductionAvgAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    weight: number | null
    stoneWt: number | null
  }

  export type DeductionSumAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    weight: number | null
    stoneWt: number | null
  }

  export type DeductionMinAggregateOutputType = {
    id: number | null
    type: string | null
    deliveryId: number | null
    weight: number | null
    stoneWt: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeductionMaxAggregateOutputType = {
    id: number | null
    type: string | null
    deliveryId: number | null
    weight: number | null
    stoneWt: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeductionCountAggregateOutputType = {
    id: number
    type: number
    deliveryId: number
    weight: number
    stoneWt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeductionAvgAggregateInputType = {
    id?: true
    deliveryId?: true
    weight?: true
    stoneWt?: true
  }

  export type DeductionSumAggregateInputType = {
    id?: true
    deliveryId?: true
    weight?: true
    stoneWt?: true
  }

  export type DeductionMinAggregateInputType = {
    id?: true
    type?: true
    deliveryId?: true
    weight?: true
    stoneWt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeductionMaxAggregateInputType = {
    id?: true
    type?: true
    deliveryId?: true
    weight?: true
    stoneWt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeductionCountAggregateInputType = {
    id?: true
    type?: true
    deliveryId?: true
    weight?: true
    stoneWt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deduction to aggregate.
     */
    where?: deductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductions to fetch.
     */
    orderBy?: deductionOrderByWithRelationInput | deductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deductions
    **/
    _count?: true | DeductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeductionMaxAggregateInputType
  }

  export type GetDeductionAggregateType<T extends DeductionAggregateArgs> = {
        [P in keyof T & keyof AggregateDeduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeduction[P]>
      : GetScalarType<T[P], AggregateDeduction[P]>
  }




  export type deductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deductionWhereInput
    orderBy?: deductionOrderByWithAggregationInput | deductionOrderByWithAggregationInput[]
    by: DeductionScalarFieldEnum[] | DeductionScalarFieldEnum
    having?: deductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeductionCountAggregateInputType | true
    _avg?: DeductionAvgAggregateInputType
    _sum?: DeductionSumAggregateInputType
    _min?: DeductionMinAggregateInputType
    _max?: DeductionMaxAggregateInputType
  }

  export type DeductionGroupByOutputType = {
    id: number
    type: string | null
    deliveryId: number
    weight: number | null
    stoneWt: number | null
    createdAt: Date
    updatedAt: Date
    _count: DeductionCountAggregateOutputType | null
    _avg: DeductionAvgAggregateOutputType | null
    _sum: DeductionSumAggregateOutputType | null
    _min: DeductionMinAggregateOutputType | null
    _max: DeductionMaxAggregateOutputType | null
  }

  type GetDeductionGroupByPayload<T extends deductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeductionGroupByOutputType[P]>
            : GetScalarType<T[P], DeductionGroupByOutputType[P]>
        }
      >
    >


  export type deductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    deliveryId?: boolean
    weight?: boolean
    stoneWt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemDelivery?: boolean | itemDeliveryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deduction"]>



  export type deductionSelectScalar = {
    id?: boolean
    type?: boolean
    deliveryId?: boolean
    weight?: boolean
    stoneWt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type deductionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "deliveryId" | "weight" | "stoneWt" | "createdAt" | "updatedAt", ExtArgs["result"]["deduction"]>
  export type deductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemDelivery?: boolean | itemDeliveryDefaultArgs<ExtArgs>
  }

  export type $deductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deduction"
    objects: {
      itemDelivery: Prisma.$itemDeliveryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      deliveryId: number
      weight: number | null
      stoneWt: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deduction"]>
    composites: {}
  }

  type deductionGetPayload<S extends boolean | null | undefined | deductionDefaultArgs> = $Result.GetResult<Prisma.$deductionPayload, S>

  type deductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<deductionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeductionCountAggregateInputType | true
    }

  export interface deductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deduction'], meta: { name: 'deduction' } }
    /**
     * Find zero or one Deduction that matches the filter.
     * @param {deductionFindUniqueArgs} args - Arguments to find a Deduction
     * @example
     * // Get one Deduction
     * const deduction = await prisma.deduction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deductionFindUniqueArgs>(args: SelectSubset<T, deductionFindUniqueArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deduction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {deductionFindUniqueOrThrowArgs} args - Arguments to find a Deduction
     * @example
     * // Get one Deduction
     * const deduction = await prisma.deduction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deductionFindUniqueOrThrowArgs>(args: SelectSubset<T, deductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deduction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionFindFirstArgs} args - Arguments to find a Deduction
     * @example
     * // Get one Deduction
     * const deduction = await prisma.deduction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deductionFindFirstArgs>(args?: SelectSubset<T, deductionFindFirstArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deduction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionFindFirstOrThrowArgs} args - Arguments to find a Deduction
     * @example
     * // Get one Deduction
     * const deduction = await prisma.deduction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deductionFindFirstOrThrowArgs>(args?: SelectSubset<T, deductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deductions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deductions
     * const deductions = await prisma.deduction.findMany()
     * 
     * // Get first 10 Deductions
     * const deductions = await prisma.deduction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deductionWithIdOnly = await prisma.deduction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deductionFindManyArgs>(args?: SelectSubset<T, deductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deduction.
     * @param {deductionCreateArgs} args - Arguments to create a Deduction.
     * @example
     * // Create one Deduction
     * const Deduction = await prisma.deduction.create({
     *   data: {
     *     // ... data to create a Deduction
     *   }
     * })
     * 
     */
    create<T extends deductionCreateArgs>(args: SelectSubset<T, deductionCreateArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deductions.
     * @param {deductionCreateManyArgs} args - Arguments to create many Deductions.
     * @example
     * // Create many Deductions
     * const deduction = await prisma.deduction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deductionCreateManyArgs>(args?: SelectSubset<T, deductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deduction.
     * @param {deductionDeleteArgs} args - Arguments to delete one Deduction.
     * @example
     * // Delete one Deduction
     * const Deduction = await prisma.deduction.delete({
     *   where: {
     *     // ... filter to delete one Deduction
     *   }
     * })
     * 
     */
    delete<T extends deductionDeleteArgs>(args: SelectSubset<T, deductionDeleteArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deduction.
     * @param {deductionUpdateArgs} args - Arguments to update one Deduction.
     * @example
     * // Update one Deduction
     * const deduction = await prisma.deduction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deductionUpdateArgs>(args: SelectSubset<T, deductionUpdateArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deductions.
     * @param {deductionDeleteManyArgs} args - Arguments to filter Deductions to delete.
     * @example
     * // Delete a few Deductions
     * const { count } = await prisma.deduction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deductionDeleteManyArgs>(args?: SelectSubset<T, deductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deductions
     * const deduction = await prisma.deduction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deductionUpdateManyArgs>(args: SelectSubset<T, deductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deduction.
     * @param {deductionUpsertArgs} args - Arguments to update or create a Deduction.
     * @example
     * // Update or create a Deduction
     * const deduction = await prisma.deduction.upsert({
     *   create: {
     *     // ... data to create a Deduction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deduction we want to update
     *   }
     * })
     */
    upsert<T extends deductionUpsertArgs>(args: SelectSubset<T, deductionUpsertArgs<ExtArgs>>): Prisma__deductionClient<$Result.GetResult<Prisma.$deductionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionCountArgs} args - Arguments to filter Deductions to count.
     * @example
     * // Count the number of Deductions
     * const count = await prisma.deduction.count({
     *   where: {
     *     // ... the filter for the Deductions we want to count
     *   }
     * })
    **/
    count<T extends deductionCountArgs>(
      args?: Subset<T, deductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeductionAggregateArgs>(args: Subset<T, DeductionAggregateArgs>): Prisma.PrismaPromise<GetDeductionAggregateType<T>>

    /**
     * Group by Deduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deductionGroupByArgs['orderBy'] }
        : { orderBy?: deductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deduction model
   */
  readonly fields: deductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deduction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemDelivery<T extends itemDeliveryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemDeliveryDefaultArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deduction model
   */
  interface deductionFieldRefs {
    readonly id: FieldRef<"deduction", 'Int'>
    readonly type: FieldRef<"deduction", 'String'>
    readonly deliveryId: FieldRef<"deduction", 'Int'>
    readonly weight: FieldRef<"deduction", 'Float'>
    readonly stoneWt: FieldRef<"deduction", 'Float'>
    readonly createdAt: FieldRef<"deduction", 'DateTime'>
    readonly updatedAt: FieldRef<"deduction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * deduction findUnique
   */
  export type deductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * Filter, which deduction to fetch.
     */
    where: deductionWhereUniqueInput
  }

  /**
   * deduction findUniqueOrThrow
   */
  export type deductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * Filter, which deduction to fetch.
     */
    where: deductionWhereUniqueInput
  }

  /**
   * deduction findFirst
   */
  export type deductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * Filter, which deduction to fetch.
     */
    where?: deductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductions to fetch.
     */
    orderBy?: deductionOrderByWithRelationInput | deductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deductions.
     */
    cursor?: deductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deductions.
     */
    distinct?: DeductionScalarFieldEnum | DeductionScalarFieldEnum[]
  }

  /**
   * deduction findFirstOrThrow
   */
  export type deductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * Filter, which deduction to fetch.
     */
    where?: deductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductions to fetch.
     */
    orderBy?: deductionOrderByWithRelationInput | deductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deductions.
     */
    cursor?: deductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deductions.
     */
    distinct?: DeductionScalarFieldEnum | DeductionScalarFieldEnum[]
  }

  /**
   * deduction findMany
   */
  export type deductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * Filter, which deductions to fetch.
     */
    where?: deductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductions to fetch.
     */
    orderBy?: deductionOrderByWithRelationInput | deductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deductions.
     */
    cursor?: deductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductions.
     */
    skip?: number
    distinct?: DeductionScalarFieldEnum | DeductionScalarFieldEnum[]
  }

  /**
   * deduction create
   */
  export type deductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * The data needed to create a deduction.
     */
    data: XOR<deductionCreateInput, deductionUncheckedCreateInput>
  }

  /**
   * deduction createMany
   */
  export type deductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deductions.
     */
    data: deductionCreateManyInput | deductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * deduction update
   */
  export type deductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * The data needed to update a deduction.
     */
    data: XOR<deductionUpdateInput, deductionUncheckedUpdateInput>
    /**
     * Choose, which deduction to update.
     */
    where: deductionWhereUniqueInput
  }

  /**
   * deduction updateMany
   */
  export type deductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deductions.
     */
    data: XOR<deductionUpdateManyMutationInput, deductionUncheckedUpdateManyInput>
    /**
     * Filter which deductions to update
     */
    where?: deductionWhereInput
    /**
     * Limit how many deductions to update.
     */
    limit?: number
  }

  /**
   * deduction upsert
   */
  export type deductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * The filter to search for the deduction to update in case it exists.
     */
    where: deductionWhereUniqueInput
    /**
     * In case the deduction found by the `where` argument doesn't exist, create a new deduction with this data.
     */
    create: XOR<deductionCreateInput, deductionUncheckedCreateInput>
    /**
     * In case the deduction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deductionUpdateInput, deductionUncheckedUpdateInput>
  }

  /**
   * deduction delete
   */
  export type deductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
    /**
     * Filter which deduction to delete.
     */
    where: deductionWhereUniqueInput
  }

  /**
   * deduction deleteMany
   */
  export type deductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deductions to delete
     */
    where?: deductionWhereInput
    /**
     * Limit how many deductions to delete.
     */
    limit?: number
  }

  /**
   * deduction without action
   */
  export type deductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deduction
     */
    select?: deductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deduction
     */
    omit?: deductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deductionInclude<ExtArgs> | null
  }


  /**
   * Model Total
   */

  export type AggregateTotal = {
    _count: TotalCountAggregateOutputType | null
    _avg: TotalAvgAggregateOutputType | null
    _sum: TotalSumAggregateOutputType | null
    _min: TotalMinAggregateOutputType | null
    _max: TotalMaxAggregateOutputType | null
  }

  export type TotalAvgAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    goldsmithId: number | null
    givenTotal: number | null
    deliveryTotal: number | null
    stoneTotalWt: number | null
    openingBalance: number | null
    jobCardBalance: number | null
    receivedTotal: number | null
  }

  export type TotalSumAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    goldsmithId: number | null
    givenTotal: number | null
    deliveryTotal: number | null
    stoneTotalWt: number | null
    openingBalance: number | null
    jobCardBalance: number | null
    receivedTotal: number | null
  }

  export type TotalMinAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    goldsmithId: number | null
    givenTotal: number | null
    deliveryTotal: number | null
    stoneTotalWt: number | null
    openingBalance: number | null
    jobCardBalance: number | null
    receivedTotal: number | null
    isFinished: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TotalMaxAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    goldsmithId: number | null
    givenTotal: number | null
    deliveryTotal: number | null
    stoneTotalWt: number | null
    openingBalance: number | null
    jobCardBalance: number | null
    receivedTotal: number | null
    isFinished: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TotalCountAggregateOutputType = {
    id: number
    jobcardId: number
    goldsmithId: number
    givenTotal: number
    deliveryTotal: number
    stoneTotalWt: number
    openingBalance: number
    jobCardBalance: number
    receivedTotal: number
    isFinished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TotalAvgAggregateInputType = {
    id?: true
    jobcardId?: true
    goldsmithId?: true
    givenTotal?: true
    deliveryTotal?: true
    stoneTotalWt?: true
    openingBalance?: true
    jobCardBalance?: true
    receivedTotal?: true
  }

  export type TotalSumAggregateInputType = {
    id?: true
    jobcardId?: true
    goldsmithId?: true
    givenTotal?: true
    deliveryTotal?: true
    stoneTotalWt?: true
    openingBalance?: true
    jobCardBalance?: true
    receivedTotal?: true
  }

  export type TotalMinAggregateInputType = {
    id?: true
    jobcardId?: true
    goldsmithId?: true
    givenTotal?: true
    deliveryTotal?: true
    stoneTotalWt?: true
    openingBalance?: true
    jobCardBalance?: true
    receivedTotal?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TotalMaxAggregateInputType = {
    id?: true
    jobcardId?: true
    goldsmithId?: true
    givenTotal?: true
    deliveryTotal?: true
    stoneTotalWt?: true
    openingBalance?: true
    jobCardBalance?: true
    receivedTotal?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TotalCountAggregateInputType = {
    id?: true
    jobcardId?: true
    goldsmithId?: true
    givenTotal?: true
    deliveryTotal?: true
    stoneTotalWt?: true
    openingBalance?: true
    jobCardBalance?: true
    receivedTotal?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TotalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Total to aggregate.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Totals
    **/
    _count?: true | TotalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TotalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TotalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TotalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TotalMaxAggregateInputType
  }

  export type GetTotalAggregateType<T extends TotalAggregateArgs> = {
        [P in keyof T & keyof AggregateTotal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTotal[P]>
      : GetScalarType<T[P], AggregateTotal[P]>
  }




  export type TotalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TotalWhereInput
    orderBy?: TotalOrderByWithAggregationInput | TotalOrderByWithAggregationInput[]
    by: TotalScalarFieldEnum[] | TotalScalarFieldEnum
    having?: TotalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TotalCountAggregateInputType | true
    _avg?: TotalAvgAggregateInputType
    _sum?: TotalSumAggregateInputType
    _min?: TotalMinAggregateInputType
    _max?: TotalMaxAggregateInputType
  }

  export type TotalGroupByOutputType = {
    id: number
    jobcardId: number | null
    goldsmithId: number
    givenTotal: number | null
    deliveryTotal: number | null
    stoneTotalWt: number | null
    openingBalance: number | null
    jobCardBalance: number | null
    receivedTotal: number | null
    isFinished: string | null
    createdAt: Date
    updatedAt: Date
    _count: TotalCountAggregateOutputType | null
    _avg: TotalAvgAggregateOutputType | null
    _sum: TotalSumAggregateOutputType | null
    _min: TotalMinAggregateOutputType | null
    _max: TotalMaxAggregateOutputType | null
  }

  type GetTotalGroupByPayload<T extends TotalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TotalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TotalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TotalGroupByOutputType[P]>
            : GetScalarType<T[P], TotalGroupByOutputType[P]>
        }
      >
    >


  export type TotalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobcardId?: boolean
    goldsmithId?: boolean
    givenTotal?: boolean
    deliveryTotal?: boolean
    stoneTotalWt?: boolean
    openingBalance?: boolean
    jobCardBalance?: boolean
    receivedTotal?: boolean
    isFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobcard?: boolean | Total$jobcardArgs<ExtArgs>
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["total"]>



  export type TotalSelectScalar = {
    id?: boolean
    jobcardId?: boolean
    goldsmithId?: boolean
    givenTotal?: boolean
    deliveryTotal?: boolean
    stoneTotalWt?: boolean
    openingBalance?: boolean
    jobCardBalance?: boolean
    receivedTotal?: boolean
    isFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TotalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobcardId" | "goldsmithId" | "givenTotal" | "deliveryTotal" | "stoneTotalWt" | "openingBalance" | "jobCardBalance" | "receivedTotal" | "isFinished" | "createdAt" | "updatedAt", ExtArgs["result"]["total"]>
  export type TotalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobcard?: boolean | Total$jobcardArgs<ExtArgs>
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }

  export type $TotalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Total"
    objects: {
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobcardId: number | null
      goldsmithId: number
      givenTotal: number | null
      deliveryTotal: number | null
      stoneTotalWt: number | null
      openingBalance: number | null
      jobCardBalance: number | null
      receivedTotal: number | null
      isFinished: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["total"]>
    composites: {}
  }

  type TotalGetPayload<S extends boolean | null | undefined | TotalDefaultArgs> = $Result.GetResult<Prisma.$TotalPayload, S>

  type TotalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TotalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TotalCountAggregateInputType | true
    }

  export interface TotalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Total'], meta: { name: 'Total' } }
    /**
     * Find zero or one Total that matches the filter.
     * @param {TotalFindUniqueArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TotalFindUniqueArgs>(args: SelectSubset<T, TotalFindUniqueArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Total that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TotalFindUniqueOrThrowArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TotalFindUniqueOrThrowArgs>(args: SelectSubset<T, TotalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Total that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFindFirstArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TotalFindFirstArgs>(args?: SelectSubset<T, TotalFindFirstArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Total that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFindFirstOrThrowArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TotalFindFirstOrThrowArgs>(args?: SelectSubset<T, TotalFindFirstOrThrowArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Totals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Totals
     * const totals = await prisma.total.findMany()
     * 
     * // Get first 10 Totals
     * const totals = await prisma.total.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const totalWithIdOnly = await prisma.total.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TotalFindManyArgs>(args?: SelectSubset<T, TotalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Total.
     * @param {TotalCreateArgs} args - Arguments to create a Total.
     * @example
     * // Create one Total
     * const Total = await prisma.total.create({
     *   data: {
     *     // ... data to create a Total
     *   }
     * })
     * 
     */
    create<T extends TotalCreateArgs>(args: SelectSubset<T, TotalCreateArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Totals.
     * @param {TotalCreateManyArgs} args - Arguments to create many Totals.
     * @example
     * // Create many Totals
     * const total = await prisma.total.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TotalCreateManyArgs>(args?: SelectSubset<T, TotalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Total.
     * @param {TotalDeleteArgs} args - Arguments to delete one Total.
     * @example
     * // Delete one Total
     * const Total = await prisma.total.delete({
     *   where: {
     *     // ... filter to delete one Total
     *   }
     * })
     * 
     */
    delete<T extends TotalDeleteArgs>(args: SelectSubset<T, TotalDeleteArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Total.
     * @param {TotalUpdateArgs} args - Arguments to update one Total.
     * @example
     * // Update one Total
     * const total = await prisma.total.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TotalUpdateArgs>(args: SelectSubset<T, TotalUpdateArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Totals.
     * @param {TotalDeleteManyArgs} args - Arguments to filter Totals to delete.
     * @example
     * // Delete a few Totals
     * const { count } = await prisma.total.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TotalDeleteManyArgs>(args?: SelectSubset<T, TotalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Totals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Totals
     * const total = await prisma.total.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TotalUpdateManyArgs>(args: SelectSubset<T, TotalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Total.
     * @param {TotalUpsertArgs} args - Arguments to update or create a Total.
     * @example
     * // Update or create a Total
     * const total = await prisma.total.upsert({
     *   create: {
     *     // ... data to create a Total
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Total we want to update
     *   }
     * })
     */
    upsert<T extends TotalUpsertArgs>(args: SelectSubset<T, TotalUpsertArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Totals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCountArgs} args - Arguments to filter Totals to count.
     * @example
     * // Count the number of Totals
     * const count = await prisma.total.count({
     *   where: {
     *     // ... the filter for the Totals we want to count
     *   }
     * })
    **/
    count<T extends TotalCountArgs>(
      args?: Subset<T, TotalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TotalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Total.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TotalAggregateArgs>(args: Subset<T, TotalAggregateArgs>): Prisma.PrismaPromise<GetTotalAggregateType<T>>

    /**
     * Group by Total.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TotalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TotalGroupByArgs['orderBy'] }
        : { orderBy?: TotalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TotalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTotalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Total model
   */
  readonly fields: TotalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Total.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TotalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobcard<T extends Total$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, Total$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Total model
   */
  interface TotalFieldRefs {
    readonly id: FieldRef<"Total", 'Int'>
    readonly jobcardId: FieldRef<"Total", 'Int'>
    readonly goldsmithId: FieldRef<"Total", 'Int'>
    readonly givenTotal: FieldRef<"Total", 'Float'>
    readonly deliveryTotal: FieldRef<"Total", 'Float'>
    readonly stoneTotalWt: FieldRef<"Total", 'Float'>
    readonly openingBalance: FieldRef<"Total", 'Float'>
    readonly jobCardBalance: FieldRef<"Total", 'Float'>
    readonly receivedTotal: FieldRef<"Total", 'Float'>
    readonly isFinished: FieldRef<"Total", 'String'>
    readonly createdAt: FieldRef<"Total", 'DateTime'>
    readonly updatedAt: FieldRef<"Total", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Total findUnique
   */
  export type TotalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total findUniqueOrThrow
   */
  export type TotalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total findFirst
   */
  export type TotalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Totals.
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Totals.
     */
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Total findFirstOrThrow
   */
  export type TotalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Totals.
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Totals.
     */
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Total findMany
   */
  export type TotalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Totals to fetch.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Totals.
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Total create
   */
  export type TotalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * The data needed to create a Total.
     */
    data: XOR<TotalCreateInput, TotalUncheckedCreateInput>
  }

  /**
   * Total createMany
   */
  export type TotalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Totals.
     */
    data: TotalCreateManyInput | TotalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Total update
   */
  export type TotalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * The data needed to update a Total.
     */
    data: XOR<TotalUpdateInput, TotalUncheckedUpdateInput>
    /**
     * Choose, which Total to update.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total updateMany
   */
  export type TotalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Totals.
     */
    data: XOR<TotalUpdateManyMutationInput, TotalUncheckedUpdateManyInput>
    /**
     * Filter which Totals to update
     */
    where?: TotalWhereInput
    /**
     * Limit how many Totals to update.
     */
    limit?: number
  }

  /**
   * Total upsert
   */
  export type TotalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * The filter to search for the Total to update in case it exists.
     */
    where: TotalWhereUniqueInput
    /**
     * In case the Total found by the `where` argument doesn't exist, create a new Total with this data.
     */
    create: XOR<TotalCreateInput, TotalUncheckedCreateInput>
    /**
     * In case the Total was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TotalUpdateInput, TotalUncheckedUpdateInput>
  }

  /**
   * Total delete
   */
  export type TotalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter which Total to delete.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total deleteMany
   */
  export type TotalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Totals to delete
     */
    where?: TotalWhereInput
    /**
     * Limit how many Totals to delete.
     */
    limit?: number
  }

  /**
   * Total.jobcard
   */
  export type Total$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * Total without action
   */
  export type TotalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
  }


  /**
   * Model Receivedsection
   */

  export type AggregateReceivedsection = {
    _count: ReceivedsectionCountAggregateOutputType | null
    _avg: ReceivedsectionAvgAggregateOutputType | null
    _sum: ReceivedsectionSumAggregateOutputType | null
    _min: ReceivedsectionMinAggregateOutputType | null
    _max: ReceivedsectionMaxAggregateOutputType | null
  }

  export type ReceivedsectionAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    logId: number | null
    jobcardId: number | null
    goldsmithId: number | null
  }

  export type ReceivedsectionSumAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    logId: number | null
    jobcardId: number | null
    goldsmithId: number | null
  }

  export type ReceivedsectionMinAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    logId: number | null
    jobcardId: number | null
    goldsmithId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceivedsectionMaxAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    logId: number | null
    jobcardId: number | null
    goldsmithId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceivedsectionCountAggregateOutputType = {
    id: number
    weight: number
    touch: number
    purity: number
    logId: number
    jobcardId: number
    goldsmithId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceivedsectionAvgAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    logId?: true
    jobcardId?: true
    goldsmithId?: true
  }

  export type ReceivedsectionSumAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    logId?: true
    jobcardId?: true
    goldsmithId?: true
  }

  export type ReceivedsectionMinAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    logId?: true
    jobcardId?: true
    goldsmithId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceivedsectionMaxAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    logId?: true
    jobcardId?: true
    goldsmithId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceivedsectionCountAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    logId?: true
    jobcardId?: true
    goldsmithId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceivedsectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivedsection to aggregate.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receivedsections
    **/
    _count?: true | ReceivedsectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceivedsectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceivedsectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceivedsectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceivedsectionMaxAggregateInputType
  }

  export type GetReceivedsectionAggregateType<T extends ReceivedsectionAggregateArgs> = {
        [P in keyof T & keyof AggregateReceivedsection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceivedsection[P]>
      : GetScalarType<T[P], AggregateReceivedsection[P]>
  }




  export type ReceivedsectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivedsectionWhereInput
    orderBy?: ReceivedsectionOrderByWithAggregationInput | ReceivedsectionOrderByWithAggregationInput[]
    by: ReceivedsectionScalarFieldEnum[] | ReceivedsectionScalarFieldEnum
    having?: ReceivedsectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceivedsectionCountAggregateInputType | true
    _avg?: ReceivedsectionAvgAggregateInputType
    _sum?: ReceivedsectionSumAggregateInputType
    _min?: ReceivedsectionMinAggregateInputType
    _max?: ReceivedsectionMaxAggregateInputType
  }

  export type ReceivedsectionGroupByOutputType = {
    id: number
    weight: number | null
    touch: number | null
    purity: number | null
    logId: number | null
    jobcardId: number
    goldsmithId: number
    createdAt: Date
    updatedAt: Date
    _count: ReceivedsectionCountAggregateOutputType | null
    _avg: ReceivedsectionAvgAggregateOutputType | null
    _sum: ReceivedsectionSumAggregateOutputType | null
    _min: ReceivedsectionMinAggregateOutputType | null
    _max: ReceivedsectionMaxAggregateOutputType | null
  }

  type GetReceivedsectionGroupByPayload<T extends ReceivedsectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceivedsectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceivedsectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceivedsectionGroupByOutputType[P]>
            : GetScalarType<T[P], ReceivedsectionGroupByOutputType[P]>
        }
      >
    >


  export type ReceivedsectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    logId?: boolean
    jobcardId?: boolean
    goldsmithId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rawGoldLogs?: boolean | Receivedsection$rawGoldLogsArgs<ExtArgs>
    jobcard?: boolean | Receivedsection$jobcardArgs<ExtArgs>
    goldsmith?: boolean | Receivedsection$goldsmithArgs<ExtArgs>
  }, ExtArgs["result"]["receivedsection"]>



  export type ReceivedsectionSelectScalar = {
    id?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    logId?: boolean
    jobcardId?: boolean
    goldsmithId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceivedsectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "weight" | "touch" | "purity" | "logId" | "jobcardId" | "goldsmithId" | "createdAt" | "updatedAt", ExtArgs["result"]["receivedsection"]>
  export type ReceivedsectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawGoldLogs?: boolean | Receivedsection$rawGoldLogsArgs<ExtArgs>
    jobcard?: boolean | Receivedsection$jobcardArgs<ExtArgs>
    goldsmith?: boolean | Receivedsection$goldsmithArgs<ExtArgs>
  }

  export type $ReceivedsectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receivedsection"
    objects: {
      rawGoldLogs: Prisma.$RawGoldLogsPayload<ExtArgs> | null
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      weight: number | null
      touch: number | null
      purity: number | null
      logId: number | null
      jobcardId: number
      goldsmithId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["receivedsection"]>
    composites: {}
  }

  type ReceivedsectionGetPayload<S extends boolean | null | undefined | ReceivedsectionDefaultArgs> = $Result.GetResult<Prisma.$ReceivedsectionPayload, S>

  type ReceivedsectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceivedsectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceivedsectionCountAggregateInputType | true
    }

  export interface ReceivedsectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receivedsection'], meta: { name: 'Receivedsection' } }
    /**
     * Find zero or one Receivedsection that matches the filter.
     * @param {ReceivedsectionFindUniqueArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceivedsectionFindUniqueArgs>(args: SelectSubset<T, ReceivedsectionFindUniqueArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receivedsection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceivedsectionFindUniqueOrThrowArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceivedsectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceivedsectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receivedsection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionFindFirstArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceivedsectionFindFirstArgs>(args?: SelectSubset<T, ReceivedsectionFindFirstArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receivedsection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionFindFirstOrThrowArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceivedsectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceivedsectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receivedsections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receivedsections
     * const receivedsections = await prisma.receivedsection.findMany()
     * 
     * // Get first 10 Receivedsections
     * const receivedsections = await prisma.receivedsection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receivedsectionWithIdOnly = await prisma.receivedsection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceivedsectionFindManyArgs>(args?: SelectSubset<T, ReceivedsectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receivedsection.
     * @param {ReceivedsectionCreateArgs} args - Arguments to create a Receivedsection.
     * @example
     * // Create one Receivedsection
     * const Receivedsection = await prisma.receivedsection.create({
     *   data: {
     *     // ... data to create a Receivedsection
     *   }
     * })
     * 
     */
    create<T extends ReceivedsectionCreateArgs>(args: SelectSubset<T, ReceivedsectionCreateArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receivedsections.
     * @param {ReceivedsectionCreateManyArgs} args - Arguments to create many Receivedsections.
     * @example
     * // Create many Receivedsections
     * const receivedsection = await prisma.receivedsection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceivedsectionCreateManyArgs>(args?: SelectSubset<T, ReceivedsectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receivedsection.
     * @param {ReceivedsectionDeleteArgs} args - Arguments to delete one Receivedsection.
     * @example
     * // Delete one Receivedsection
     * const Receivedsection = await prisma.receivedsection.delete({
     *   where: {
     *     // ... filter to delete one Receivedsection
     *   }
     * })
     * 
     */
    delete<T extends ReceivedsectionDeleteArgs>(args: SelectSubset<T, ReceivedsectionDeleteArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receivedsection.
     * @param {ReceivedsectionUpdateArgs} args - Arguments to update one Receivedsection.
     * @example
     * // Update one Receivedsection
     * const receivedsection = await prisma.receivedsection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceivedsectionUpdateArgs>(args: SelectSubset<T, ReceivedsectionUpdateArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receivedsections.
     * @param {ReceivedsectionDeleteManyArgs} args - Arguments to filter Receivedsections to delete.
     * @example
     * // Delete a few Receivedsections
     * const { count } = await prisma.receivedsection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceivedsectionDeleteManyArgs>(args?: SelectSubset<T, ReceivedsectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receivedsections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receivedsections
     * const receivedsection = await prisma.receivedsection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceivedsectionUpdateManyArgs>(args: SelectSubset<T, ReceivedsectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receivedsection.
     * @param {ReceivedsectionUpsertArgs} args - Arguments to update or create a Receivedsection.
     * @example
     * // Update or create a Receivedsection
     * const receivedsection = await prisma.receivedsection.upsert({
     *   create: {
     *     // ... data to create a Receivedsection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receivedsection we want to update
     *   }
     * })
     */
    upsert<T extends ReceivedsectionUpsertArgs>(args: SelectSubset<T, ReceivedsectionUpsertArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receivedsections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionCountArgs} args - Arguments to filter Receivedsections to count.
     * @example
     * // Count the number of Receivedsections
     * const count = await prisma.receivedsection.count({
     *   where: {
     *     // ... the filter for the Receivedsections we want to count
     *   }
     * })
    **/
    count<T extends ReceivedsectionCountArgs>(
      args?: Subset<T, ReceivedsectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceivedsectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receivedsection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceivedsectionAggregateArgs>(args: Subset<T, ReceivedsectionAggregateArgs>): Prisma.PrismaPromise<GetReceivedsectionAggregateType<T>>

    /**
     * Group by Receivedsection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceivedsectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceivedsectionGroupByArgs['orderBy'] }
        : { orderBy?: ReceivedsectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceivedsectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceivedsectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receivedsection model
   */
  readonly fields: ReceivedsectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receivedsection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceivedsectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawGoldLogs<T extends Receivedsection$rawGoldLogsArgs<ExtArgs> = {}>(args?: Subset<T, Receivedsection$rawGoldLogsArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobcard<T extends Receivedsection$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, Receivedsection$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    goldsmith<T extends Receivedsection$goldsmithArgs<ExtArgs> = {}>(args?: Subset<T, Receivedsection$goldsmithArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receivedsection model
   */
  interface ReceivedsectionFieldRefs {
    readonly id: FieldRef<"Receivedsection", 'Int'>
    readonly weight: FieldRef<"Receivedsection", 'Float'>
    readonly touch: FieldRef<"Receivedsection", 'Float'>
    readonly purity: FieldRef<"Receivedsection", 'Float'>
    readonly logId: FieldRef<"Receivedsection", 'Int'>
    readonly jobcardId: FieldRef<"Receivedsection", 'Int'>
    readonly goldsmithId: FieldRef<"Receivedsection", 'Int'>
    readonly createdAt: FieldRef<"Receivedsection", 'DateTime'>
    readonly updatedAt: FieldRef<"Receivedsection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receivedsection findUnique
   */
  export type ReceivedsectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection findUniqueOrThrow
   */
  export type ReceivedsectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection findFirst
   */
  export type ReceivedsectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivedsections.
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivedsections.
     */
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Receivedsection findFirstOrThrow
   */
  export type ReceivedsectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivedsections.
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivedsections.
     */
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Receivedsection findMany
   */
  export type ReceivedsectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsections to fetch.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receivedsections.
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Receivedsection create
   */
  export type ReceivedsectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Receivedsection.
     */
    data: XOR<ReceivedsectionCreateInput, ReceivedsectionUncheckedCreateInput>
  }

  /**
   * Receivedsection createMany
   */
  export type ReceivedsectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receivedsections.
     */
    data: ReceivedsectionCreateManyInput | ReceivedsectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receivedsection update
   */
  export type ReceivedsectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Receivedsection.
     */
    data: XOR<ReceivedsectionUpdateInput, ReceivedsectionUncheckedUpdateInput>
    /**
     * Choose, which Receivedsection to update.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection updateMany
   */
  export type ReceivedsectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receivedsections.
     */
    data: XOR<ReceivedsectionUpdateManyMutationInput, ReceivedsectionUncheckedUpdateManyInput>
    /**
     * Filter which Receivedsections to update
     */
    where?: ReceivedsectionWhereInput
    /**
     * Limit how many Receivedsections to update.
     */
    limit?: number
  }

  /**
   * Receivedsection upsert
   */
  export type ReceivedsectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Receivedsection to update in case it exists.
     */
    where: ReceivedsectionWhereUniqueInput
    /**
     * In case the Receivedsection found by the `where` argument doesn't exist, create a new Receivedsection with this data.
     */
    create: XOR<ReceivedsectionCreateInput, ReceivedsectionUncheckedCreateInput>
    /**
     * In case the Receivedsection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceivedsectionUpdateInput, ReceivedsectionUncheckedUpdateInput>
  }

  /**
   * Receivedsection delete
   */
  export type ReceivedsectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter which Receivedsection to delete.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection deleteMany
   */
  export type ReceivedsectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivedsections to delete
     */
    where?: ReceivedsectionWhereInput
    /**
     * Limit how many Receivedsections to delete.
     */
    limit?: number
  }

  /**
   * Receivedsection.rawGoldLogs
   */
  export type Receivedsection$rawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    where?: RawGoldLogsWhereInput
  }

  /**
   * Receivedsection.jobcard
   */
  export type Receivedsection$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * Receivedsection.goldsmith
   */
  export type Receivedsection$goldsmithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    where?: GoldsmithWhereInput
  }

  /**
   * Receivedsection without action
   */
  export type ReceivedsectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
  }


  /**
   * Model RawgoldStock
   */

  export type AggregateRawgoldStock = {
    _count: RawgoldStockCountAggregateOutputType | null
    _avg: RawgoldStockAvgAggregateOutputType | null
    _sum: RawgoldStockSumAggregateOutputType | null
    _min: RawgoldStockMinAggregateOutputType | null
    _max: RawgoldStockMaxAggregateOutputType | null
  }

  export type RawgoldStockAvgAggregateOutputType = {
    id: number | null
    touchId: number | null
    touch: number | null
    weight: number | null
    remainingWt: number | null
  }

  export type RawgoldStockSumAggregateOutputType = {
    id: number | null
    touchId: number | null
    touch: number | null
    weight: number | null
    remainingWt: number | null
  }

  export type RawgoldStockMinAggregateOutputType = {
    id: number | null
    touchId: number | null
    touch: number | null
    weight: number | null
    remainingWt: number | null
  }

  export type RawgoldStockMaxAggregateOutputType = {
    id: number | null
    touchId: number | null
    touch: number | null
    weight: number | null
    remainingWt: number | null
  }

  export type RawgoldStockCountAggregateOutputType = {
    id: number
    touchId: number
    touch: number
    weight: number
    remainingWt: number
    _all: number
  }


  export type RawgoldStockAvgAggregateInputType = {
    id?: true
    touchId?: true
    touch?: true
    weight?: true
    remainingWt?: true
  }

  export type RawgoldStockSumAggregateInputType = {
    id?: true
    touchId?: true
    touch?: true
    weight?: true
    remainingWt?: true
  }

  export type RawgoldStockMinAggregateInputType = {
    id?: true
    touchId?: true
    touch?: true
    weight?: true
    remainingWt?: true
  }

  export type RawgoldStockMaxAggregateInputType = {
    id?: true
    touchId?: true
    touch?: true
    weight?: true
    remainingWt?: true
  }

  export type RawgoldStockCountAggregateInputType = {
    id?: true
    touchId?: true
    touch?: true
    weight?: true
    remainingWt?: true
    _all?: true
  }

  export type RawgoldStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawgoldStock to aggregate.
     */
    where?: RawgoldStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawgoldStocks to fetch.
     */
    orderBy?: RawgoldStockOrderByWithRelationInput | RawgoldStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawgoldStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawgoldStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawgoldStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawgoldStocks
    **/
    _count?: true | RawgoldStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RawgoldStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RawgoldStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawgoldStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawgoldStockMaxAggregateInputType
  }

  export type GetRawgoldStockAggregateType<T extends RawgoldStockAggregateArgs> = {
        [P in keyof T & keyof AggregateRawgoldStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawgoldStock[P]>
      : GetScalarType<T[P], AggregateRawgoldStock[P]>
  }




  export type RawgoldStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawgoldStockWhereInput
    orderBy?: RawgoldStockOrderByWithAggregationInput | RawgoldStockOrderByWithAggregationInput[]
    by: RawgoldStockScalarFieldEnum[] | RawgoldStockScalarFieldEnum
    having?: RawgoldStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawgoldStockCountAggregateInputType | true
    _avg?: RawgoldStockAvgAggregateInputType
    _sum?: RawgoldStockSumAggregateInputType
    _min?: RawgoldStockMinAggregateInputType
    _max?: RawgoldStockMaxAggregateInputType
  }

  export type RawgoldStockGroupByOutputType = {
    id: number
    touchId: number
    touch: number | null
    weight: number | null
    remainingWt: number | null
    _count: RawgoldStockCountAggregateOutputType | null
    _avg: RawgoldStockAvgAggregateOutputType | null
    _sum: RawgoldStockSumAggregateOutputType | null
    _min: RawgoldStockMinAggregateOutputType | null
    _max: RawgoldStockMaxAggregateOutputType | null
  }

  type GetRawgoldStockGroupByPayload<T extends RawgoldStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawgoldStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawgoldStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawgoldStockGroupByOutputType[P]>
            : GetScalarType<T[P], RawgoldStockGroupByOutputType[P]>
        }
      >
    >


  export type RawgoldStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    touchId?: boolean
    touch?: boolean
    weight?: boolean
    remainingWt?: boolean
    masterTouch?: boolean | RawgoldStock$masterTouchArgs<ExtArgs>
    rawGoldLogs?: boolean | RawgoldStock$rawGoldLogsArgs<ExtArgs>
    _count?: boolean | RawgoldStockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawgoldStock"]>



  export type RawgoldStockSelectScalar = {
    id?: boolean
    touchId?: boolean
    touch?: boolean
    weight?: boolean
    remainingWt?: boolean
  }

  export type RawgoldStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "touchId" | "touch" | "weight" | "remainingWt", ExtArgs["result"]["rawgoldStock"]>
  export type RawgoldStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    masterTouch?: boolean | RawgoldStock$masterTouchArgs<ExtArgs>
    rawGoldLogs?: boolean | RawgoldStock$rawGoldLogsArgs<ExtArgs>
    _count?: boolean | RawgoldStockCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RawgoldStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawgoldStock"
    objects: {
      masterTouch: Prisma.$MasterTouchPayload<ExtArgs> | null
      rawGoldLogs: Prisma.$RawGoldLogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      touchId: number
      touch: number | null
      weight: number | null
      remainingWt: number | null
    }, ExtArgs["result"]["rawgoldStock"]>
    composites: {}
  }

  type RawgoldStockGetPayload<S extends boolean | null | undefined | RawgoldStockDefaultArgs> = $Result.GetResult<Prisma.$RawgoldStockPayload, S>

  type RawgoldStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RawgoldStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RawgoldStockCountAggregateInputType | true
    }

  export interface RawgoldStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawgoldStock'], meta: { name: 'RawgoldStock' } }
    /**
     * Find zero or one RawgoldStock that matches the filter.
     * @param {RawgoldStockFindUniqueArgs} args - Arguments to find a RawgoldStock
     * @example
     * // Get one RawgoldStock
     * const rawgoldStock = await prisma.rawgoldStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawgoldStockFindUniqueArgs>(args: SelectSubset<T, RawgoldStockFindUniqueArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RawgoldStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RawgoldStockFindUniqueOrThrowArgs} args - Arguments to find a RawgoldStock
     * @example
     * // Get one RawgoldStock
     * const rawgoldStock = await prisma.rawgoldStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawgoldStockFindUniqueOrThrowArgs>(args: SelectSubset<T, RawgoldStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawgoldStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawgoldStockFindFirstArgs} args - Arguments to find a RawgoldStock
     * @example
     * // Get one RawgoldStock
     * const rawgoldStock = await prisma.rawgoldStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawgoldStockFindFirstArgs>(args?: SelectSubset<T, RawgoldStockFindFirstArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawgoldStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawgoldStockFindFirstOrThrowArgs} args - Arguments to find a RawgoldStock
     * @example
     * // Get one RawgoldStock
     * const rawgoldStock = await prisma.rawgoldStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawgoldStockFindFirstOrThrowArgs>(args?: SelectSubset<T, RawgoldStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RawgoldStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawgoldStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawgoldStocks
     * const rawgoldStocks = await prisma.rawgoldStock.findMany()
     * 
     * // Get first 10 RawgoldStocks
     * const rawgoldStocks = await prisma.rawgoldStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rawgoldStockWithIdOnly = await prisma.rawgoldStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RawgoldStockFindManyArgs>(args?: SelectSubset<T, RawgoldStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RawgoldStock.
     * @param {RawgoldStockCreateArgs} args - Arguments to create a RawgoldStock.
     * @example
     * // Create one RawgoldStock
     * const RawgoldStock = await prisma.rawgoldStock.create({
     *   data: {
     *     // ... data to create a RawgoldStock
     *   }
     * })
     * 
     */
    create<T extends RawgoldStockCreateArgs>(args: SelectSubset<T, RawgoldStockCreateArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RawgoldStocks.
     * @param {RawgoldStockCreateManyArgs} args - Arguments to create many RawgoldStocks.
     * @example
     * // Create many RawgoldStocks
     * const rawgoldStock = await prisma.rawgoldStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawgoldStockCreateManyArgs>(args?: SelectSubset<T, RawgoldStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RawgoldStock.
     * @param {RawgoldStockDeleteArgs} args - Arguments to delete one RawgoldStock.
     * @example
     * // Delete one RawgoldStock
     * const RawgoldStock = await prisma.rawgoldStock.delete({
     *   where: {
     *     // ... filter to delete one RawgoldStock
     *   }
     * })
     * 
     */
    delete<T extends RawgoldStockDeleteArgs>(args: SelectSubset<T, RawgoldStockDeleteArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RawgoldStock.
     * @param {RawgoldStockUpdateArgs} args - Arguments to update one RawgoldStock.
     * @example
     * // Update one RawgoldStock
     * const rawgoldStock = await prisma.rawgoldStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawgoldStockUpdateArgs>(args: SelectSubset<T, RawgoldStockUpdateArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RawgoldStocks.
     * @param {RawgoldStockDeleteManyArgs} args - Arguments to filter RawgoldStocks to delete.
     * @example
     * // Delete a few RawgoldStocks
     * const { count } = await prisma.rawgoldStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawgoldStockDeleteManyArgs>(args?: SelectSubset<T, RawgoldStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawgoldStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawgoldStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawgoldStocks
     * const rawgoldStock = await prisma.rawgoldStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawgoldStockUpdateManyArgs>(args: SelectSubset<T, RawgoldStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RawgoldStock.
     * @param {RawgoldStockUpsertArgs} args - Arguments to update or create a RawgoldStock.
     * @example
     * // Update or create a RawgoldStock
     * const rawgoldStock = await prisma.rawgoldStock.upsert({
     *   create: {
     *     // ... data to create a RawgoldStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawgoldStock we want to update
     *   }
     * })
     */
    upsert<T extends RawgoldStockUpsertArgs>(args: SelectSubset<T, RawgoldStockUpsertArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RawgoldStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawgoldStockCountArgs} args - Arguments to filter RawgoldStocks to count.
     * @example
     * // Count the number of RawgoldStocks
     * const count = await prisma.rawgoldStock.count({
     *   where: {
     *     // ... the filter for the RawgoldStocks we want to count
     *   }
     * })
    **/
    count<T extends RawgoldStockCountArgs>(
      args?: Subset<T, RawgoldStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawgoldStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawgoldStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawgoldStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawgoldStockAggregateArgs>(args: Subset<T, RawgoldStockAggregateArgs>): Prisma.PrismaPromise<GetRawgoldStockAggregateType<T>>

    /**
     * Group by RawgoldStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawgoldStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawgoldStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawgoldStockGroupByArgs['orderBy'] }
        : { orderBy?: RawgoldStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawgoldStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawgoldStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawgoldStock model
   */
  readonly fields: RawgoldStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawgoldStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawgoldStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    masterTouch<T extends RawgoldStock$masterTouchArgs<ExtArgs> = {}>(args?: Subset<T, RawgoldStock$masterTouchArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rawGoldLogs<T extends RawgoldStock$rawGoldLogsArgs<ExtArgs> = {}>(args?: Subset<T, RawgoldStock$rawGoldLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawgoldStock model
   */
  interface RawgoldStockFieldRefs {
    readonly id: FieldRef<"RawgoldStock", 'Int'>
    readonly touchId: FieldRef<"RawgoldStock", 'Int'>
    readonly touch: FieldRef<"RawgoldStock", 'Float'>
    readonly weight: FieldRef<"RawgoldStock", 'Float'>
    readonly remainingWt: FieldRef<"RawgoldStock", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RawgoldStock findUnique
   */
  export type RawgoldStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * Filter, which RawgoldStock to fetch.
     */
    where: RawgoldStockWhereUniqueInput
  }

  /**
   * RawgoldStock findUniqueOrThrow
   */
  export type RawgoldStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * Filter, which RawgoldStock to fetch.
     */
    where: RawgoldStockWhereUniqueInput
  }

  /**
   * RawgoldStock findFirst
   */
  export type RawgoldStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * Filter, which RawgoldStock to fetch.
     */
    where?: RawgoldStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawgoldStocks to fetch.
     */
    orderBy?: RawgoldStockOrderByWithRelationInput | RawgoldStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawgoldStocks.
     */
    cursor?: RawgoldStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawgoldStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawgoldStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawgoldStocks.
     */
    distinct?: RawgoldStockScalarFieldEnum | RawgoldStockScalarFieldEnum[]
  }

  /**
   * RawgoldStock findFirstOrThrow
   */
  export type RawgoldStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * Filter, which RawgoldStock to fetch.
     */
    where?: RawgoldStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawgoldStocks to fetch.
     */
    orderBy?: RawgoldStockOrderByWithRelationInput | RawgoldStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawgoldStocks.
     */
    cursor?: RawgoldStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawgoldStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawgoldStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawgoldStocks.
     */
    distinct?: RawgoldStockScalarFieldEnum | RawgoldStockScalarFieldEnum[]
  }

  /**
   * RawgoldStock findMany
   */
  export type RawgoldStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * Filter, which RawgoldStocks to fetch.
     */
    where?: RawgoldStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawgoldStocks to fetch.
     */
    orderBy?: RawgoldStockOrderByWithRelationInput | RawgoldStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawgoldStocks.
     */
    cursor?: RawgoldStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawgoldStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawgoldStocks.
     */
    skip?: number
    distinct?: RawgoldStockScalarFieldEnum | RawgoldStockScalarFieldEnum[]
  }

  /**
   * RawgoldStock create
   */
  export type RawgoldStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * The data needed to create a RawgoldStock.
     */
    data: XOR<RawgoldStockCreateInput, RawgoldStockUncheckedCreateInput>
  }

  /**
   * RawgoldStock createMany
   */
  export type RawgoldStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawgoldStocks.
     */
    data: RawgoldStockCreateManyInput | RawgoldStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RawgoldStock update
   */
  export type RawgoldStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * The data needed to update a RawgoldStock.
     */
    data: XOR<RawgoldStockUpdateInput, RawgoldStockUncheckedUpdateInput>
    /**
     * Choose, which RawgoldStock to update.
     */
    where: RawgoldStockWhereUniqueInput
  }

  /**
   * RawgoldStock updateMany
   */
  export type RawgoldStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawgoldStocks.
     */
    data: XOR<RawgoldStockUpdateManyMutationInput, RawgoldStockUncheckedUpdateManyInput>
    /**
     * Filter which RawgoldStocks to update
     */
    where?: RawgoldStockWhereInput
    /**
     * Limit how many RawgoldStocks to update.
     */
    limit?: number
  }

  /**
   * RawgoldStock upsert
   */
  export type RawgoldStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * The filter to search for the RawgoldStock to update in case it exists.
     */
    where: RawgoldStockWhereUniqueInput
    /**
     * In case the RawgoldStock found by the `where` argument doesn't exist, create a new RawgoldStock with this data.
     */
    create: XOR<RawgoldStockCreateInput, RawgoldStockUncheckedCreateInput>
    /**
     * In case the RawgoldStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawgoldStockUpdateInput, RawgoldStockUncheckedUpdateInput>
  }

  /**
   * RawgoldStock delete
   */
  export type RawgoldStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    /**
     * Filter which RawgoldStock to delete.
     */
    where: RawgoldStockWhereUniqueInput
  }

  /**
   * RawgoldStock deleteMany
   */
  export type RawgoldStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawgoldStocks to delete
     */
    where?: RawgoldStockWhereInput
    /**
     * Limit how many RawgoldStocks to delete.
     */
    limit?: number
  }

  /**
   * RawgoldStock.masterTouch
   */
  export type RawgoldStock$masterTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterTouchInclude<ExtArgs> | null
    where?: MasterTouchWhereInput
  }

  /**
   * RawgoldStock.rawGoldLogs
   */
  export type RawgoldStock$rawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    where?: RawGoldLogsWhereInput
    orderBy?: RawGoldLogsOrderByWithRelationInput | RawGoldLogsOrderByWithRelationInput[]
    cursor?: RawGoldLogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawGoldLogsScalarFieldEnum | RawGoldLogsScalarFieldEnum[]
  }

  /**
   * RawgoldStock without action
   */
  export type RawgoldStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
  }


  /**
   * Model RawGoldLogs
   */

  export type AggregateRawGoldLogs = {
    _count: RawGoldLogsCountAggregateOutputType | null
    _avg: RawGoldLogsAvgAggregateOutputType | null
    _sum: RawGoldLogsSumAggregateOutputType | null
    _min: RawGoldLogsMinAggregateOutputType | null
    _max: RawGoldLogsMaxAggregateOutputType | null
  }

  export type RawGoldLogsAvgAggregateOutputType = {
    id: number | null
    rawGoldStockId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
  }

  export type RawGoldLogsSumAggregateOutputType = {
    id: number | null
    rawGoldStockId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
  }

  export type RawGoldLogsMinAggregateOutputType = {
    id: number | null
    rawGoldStockId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
  }

  export type RawGoldLogsMaxAggregateOutputType = {
    id: number | null
    rawGoldStockId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
  }

  export type RawGoldLogsCountAggregateOutputType = {
    id: number
    rawGoldStockId: number
    weight: number
    touch: number
    purity: number
    _all: number
  }


  export type RawGoldLogsAvgAggregateInputType = {
    id?: true
    rawGoldStockId?: true
    weight?: true
    touch?: true
    purity?: true
  }

  export type RawGoldLogsSumAggregateInputType = {
    id?: true
    rawGoldStockId?: true
    weight?: true
    touch?: true
    purity?: true
  }

  export type RawGoldLogsMinAggregateInputType = {
    id?: true
    rawGoldStockId?: true
    weight?: true
    touch?: true
    purity?: true
  }

  export type RawGoldLogsMaxAggregateInputType = {
    id?: true
    rawGoldStockId?: true
    weight?: true
    touch?: true
    purity?: true
  }

  export type RawGoldLogsCountAggregateInputType = {
    id?: true
    rawGoldStockId?: true
    weight?: true
    touch?: true
    purity?: true
    _all?: true
  }

  export type RawGoldLogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawGoldLogs to aggregate.
     */
    where?: RawGoldLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawGoldLogs to fetch.
     */
    orderBy?: RawGoldLogsOrderByWithRelationInput | RawGoldLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawGoldLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawGoldLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawGoldLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawGoldLogs
    **/
    _count?: true | RawGoldLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RawGoldLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RawGoldLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawGoldLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawGoldLogsMaxAggregateInputType
  }

  export type GetRawGoldLogsAggregateType<T extends RawGoldLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateRawGoldLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawGoldLogs[P]>
      : GetScalarType<T[P], AggregateRawGoldLogs[P]>
  }




  export type RawGoldLogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawGoldLogsWhereInput
    orderBy?: RawGoldLogsOrderByWithAggregationInput | RawGoldLogsOrderByWithAggregationInput[]
    by: RawGoldLogsScalarFieldEnum[] | RawGoldLogsScalarFieldEnum
    having?: RawGoldLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawGoldLogsCountAggregateInputType | true
    _avg?: RawGoldLogsAvgAggregateInputType
    _sum?: RawGoldLogsSumAggregateInputType
    _min?: RawGoldLogsMinAggregateInputType
    _max?: RawGoldLogsMaxAggregateInputType
  }

  export type RawGoldLogsGroupByOutputType = {
    id: number
    rawGoldStockId: number
    weight: number | null
    touch: number | null
    purity: number | null
    _count: RawGoldLogsCountAggregateOutputType | null
    _avg: RawGoldLogsAvgAggregateOutputType | null
    _sum: RawGoldLogsSumAggregateOutputType | null
    _min: RawGoldLogsMinAggregateOutputType | null
    _max: RawGoldLogsMaxAggregateOutputType | null
  }

  type GetRawGoldLogsGroupByPayload<T extends RawGoldLogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawGoldLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawGoldLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawGoldLogsGroupByOutputType[P]>
            : GetScalarType<T[P], RawGoldLogsGroupByOutputType[P]>
        }
      >
    >


  export type RawGoldLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rawGoldStockId?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    rawGoldStock?: boolean | RawGoldLogs$rawGoldStockArgs<ExtArgs>
    givenGold?: boolean | RawGoldLogs$givenGoldArgs<ExtArgs>
    receivedSections?: boolean | RawGoldLogs$receivedSectionsArgs<ExtArgs>
    billReceive?: boolean | RawGoldLogs$billReceiveArgs<ExtArgs>
    receiptVoucher?: boolean | RawGoldLogs$receiptVoucherArgs<ExtArgs>
    transactions?: boolean | RawGoldLogs$transactionsArgs<ExtArgs>
    expenseTracker?: boolean | RawGoldLogs$expenseTrackerArgs<ExtArgs>
    _count?: boolean | RawGoldLogsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawGoldLogs"]>



  export type RawGoldLogsSelectScalar = {
    id?: boolean
    rawGoldStockId?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
  }

  export type RawGoldLogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rawGoldStockId" | "weight" | "touch" | "purity", ExtArgs["result"]["rawGoldLogs"]>
  export type RawGoldLogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawGoldStock?: boolean | RawGoldLogs$rawGoldStockArgs<ExtArgs>
    givenGold?: boolean | RawGoldLogs$givenGoldArgs<ExtArgs>
    receivedSections?: boolean | RawGoldLogs$receivedSectionsArgs<ExtArgs>
    billReceive?: boolean | RawGoldLogs$billReceiveArgs<ExtArgs>
    receiptVoucher?: boolean | RawGoldLogs$receiptVoucherArgs<ExtArgs>
    transactions?: boolean | RawGoldLogs$transactionsArgs<ExtArgs>
    expenseTracker?: boolean | RawGoldLogs$expenseTrackerArgs<ExtArgs>
    _count?: boolean | RawGoldLogsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RawGoldLogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawGoldLogs"
    objects: {
      rawGoldStock: Prisma.$RawgoldStockPayload<ExtArgs> | null
      givenGold: Prisma.$givenGoldPayload<ExtArgs>[]
      receivedSections: Prisma.$ReceivedsectionPayload<ExtArgs>[]
      billReceive: Prisma.$billReceivedPayload<ExtArgs>[]
      receiptVoucher: Prisma.$receiptVoucherPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      expenseTracker: Prisma.$ExpenseTrackerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rawGoldStockId: number
      weight: number | null
      touch: number | null
      purity: number | null
    }, ExtArgs["result"]["rawGoldLogs"]>
    composites: {}
  }

  type RawGoldLogsGetPayload<S extends boolean | null | undefined | RawGoldLogsDefaultArgs> = $Result.GetResult<Prisma.$RawGoldLogsPayload, S>

  type RawGoldLogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RawGoldLogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RawGoldLogsCountAggregateInputType | true
    }

  export interface RawGoldLogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawGoldLogs'], meta: { name: 'RawGoldLogs' } }
    /**
     * Find zero or one RawGoldLogs that matches the filter.
     * @param {RawGoldLogsFindUniqueArgs} args - Arguments to find a RawGoldLogs
     * @example
     * // Get one RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawGoldLogsFindUniqueArgs>(args: SelectSubset<T, RawGoldLogsFindUniqueArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RawGoldLogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RawGoldLogsFindUniqueOrThrowArgs} args - Arguments to find a RawGoldLogs
     * @example
     * // Get one RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawGoldLogsFindUniqueOrThrowArgs>(args: SelectSubset<T, RawGoldLogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawGoldLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawGoldLogsFindFirstArgs} args - Arguments to find a RawGoldLogs
     * @example
     * // Get one RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawGoldLogsFindFirstArgs>(args?: SelectSubset<T, RawGoldLogsFindFirstArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawGoldLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawGoldLogsFindFirstOrThrowArgs} args - Arguments to find a RawGoldLogs
     * @example
     * // Get one RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawGoldLogsFindFirstOrThrowArgs>(args?: SelectSubset<T, RawGoldLogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RawGoldLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawGoldLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.findMany()
     * 
     * // Get first 10 RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rawGoldLogsWithIdOnly = await prisma.rawGoldLogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RawGoldLogsFindManyArgs>(args?: SelectSubset<T, RawGoldLogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RawGoldLogs.
     * @param {RawGoldLogsCreateArgs} args - Arguments to create a RawGoldLogs.
     * @example
     * // Create one RawGoldLogs
     * const RawGoldLogs = await prisma.rawGoldLogs.create({
     *   data: {
     *     // ... data to create a RawGoldLogs
     *   }
     * })
     * 
     */
    create<T extends RawGoldLogsCreateArgs>(args: SelectSubset<T, RawGoldLogsCreateArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RawGoldLogs.
     * @param {RawGoldLogsCreateManyArgs} args - Arguments to create many RawGoldLogs.
     * @example
     * // Create many RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawGoldLogsCreateManyArgs>(args?: SelectSubset<T, RawGoldLogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RawGoldLogs.
     * @param {RawGoldLogsDeleteArgs} args - Arguments to delete one RawGoldLogs.
     * @example
     * // Delete one RawGoldLogs
     * const RawGoldLogs = await prisma.rawGoldLogs.delete({
     *   where: {
     *     // ... filter to delete one RawGoldLogs
     *   }
     * })
     * 
     */
    delete<T extends RawGoldLogsDeleteArgs>(args: SelectSubset<T, RawGoldLogsDeleteArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RawGoldLogs.
     * @param {RawGoldLogsUpdateArgs} args - Arguments to update one RawGoldLogs.
     * @example
     * // Update one RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawGoldLogsUpdateArgs>(args: SelectSubset<T, RawGoldLogsUpdateArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RawGoldLogs.
     * @param {RawGoldLogsDeleteManyArgs} args - Arguments to filter RawGoldLogs to delete.
     * @example
     * // Delete a few RawGoldLogs
     * const { count } = await prisma.rawGoldLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawGoldLogsDeleteManyArgs>(args?: SelectSubset<T, RawGoldLogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawGoldLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawGoldLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawGoldLogsUpdateManyArgs>(args: SelectSubset<T, RawGoldLogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RawGoldLogs.
     * @param {RawGoldLogsUpsertArgs} args - Arguments to update or create a RawGoldLogs.
     * @example
     * // Update or create a RawGoldLogs
     * const rawGoldLogs = await prisma.rawGoldLogs.upsert({
     *   create: {
     *     // ... data to create a RawGoldLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawGoldLogs we want to update
     *   }
     * })
     */
    upsert<T extends RawGoldLogsUpsertArgs>(args: SelectSubset<T, RawGoldLogsUpsertArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RawGoldLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawGoldLogsCountArgs} args - Arguments to filter RawGoldLogs to count.
     * @example
     * // Count the number of RawGoldLogs
     * const count = await prisma.rawGoldLogs.count({
     *   where: {
     *     // ... the filter for the RawGoldLogs we want to count
     *   }
     * })
    **/
    count<T extends RawGoldLogsCountArgs>(
      args?: Subset<T, RawGoldLogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawGoldLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawGoldLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawGoldLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawGoldLogsAggregateArgs>(args: Subset<T, RawGoldLogsAggregateArgs>): Prisma.PrismaPromise<GetRawGoldLogsAggregateType<T>>

    /**
     * Group by RawGoldLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawGoldLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawGoldLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawGoldLogsGroupByArgs['orderBy'] }
        : { orderBy?: RawGoldLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawGoldLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawGoldLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawGoldLogs model
   */
  readonly fields: RawGoldLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawGoldLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawGoldLogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawGoldStock<T extends RawGoldLogs$rawGoldStockArgs<ExtArgs> = {}>(args?: Subset<T, RawGoldLogs$rawGoldStockArgs<ExtArgs>>): Prisma__RawgoldStockClient<$Result.GetResult<Prisma.$RawgoldStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    givenGold<T extends RawGoldLogs$givenGoldArgs<ExtArgs> = {}>(args?: Subset<T, RawGoldLogs$givenGoldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedSections<T extends RawGoldLogs$receivedSectionsArgs<ExtArgs> = {}>(args?: Subset<T, RawGoldLogs$receivedSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billReceive<T extends RawGoldLogs$billReceiveArgs<ExtArgs> = {}>(args?: Subset<T, RawGoldLogs$billReceiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receiptVoucher<T extends RawGoldLogs$receiptVoucherArgs<ExtArgs> = {}>(args?: Subset<T, RawGoldLogs$receiptVoucherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends RawGoldLogs$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, RawGoldLogs$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenseTracker<T extends RawGoldLogs$expenseTrackerArgs<ExtArgs> = {}>(args?: Subset<T, RawGoldLogs$expenseTrackerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawGoldLogs model
   */
  interface RawGoldLogsFieldRefs {
    readonly id: FieldRef<"RawGoldLogs", 'Int'>
    readonly rawGoldStockId: FieldRef<"RawGoldLogs", 'Int'>
    readonly weight: FieldRef<"RawGoldLogs", 'Float'>
    readonly touch: FieldRef<"RawGoldLogs", 'Float'>
    readonly purity: FieldRef<"RawGoldLogs", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RawGoldLogs findUnique
   */
  export type RawGoldLogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * Filter, which RawGoldLogs to fetch.
     */
    where: RawGoldLogsWhereUniqueInput
  }

  /**
   * RawGoldLogs findUniqueOrThrow
   */
  export type RawGoldLogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * Filter, which RawGoldLogs to fetch.
     */
    where: RawGoldLogsWhereUniqueInput
  }

  /**
   * RawGoldLogs findFirst
   */
  export type RawGoldLogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * Filter, which RawGoldLogs to fetch.
     */
    where?: RawGoldLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawGoldLogs to fetch.
     */
    orderBy?: RawGoldLogsOrderByWithRelationInput | RawGoldLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawGoldLogs.
     */
    cursor?: RawGoldLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawGoldLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawGoldLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawGoldLogs.
     */
    distinct?: RawGoldLogsScalarFieldEnum | RawGoldLogsScalarFieldEnum[]
  }

  /**
   * RawGoldLogs findFirstOrThrow
   */
  export type RawGoldLogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * Filter, which RawGoldLogs to fetch.
     */
    where?: RawGoldLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawGoldLogs to fetch.
     */
    orderBy?: RawGoldLogsOrderByWithRelationInput | RawGoldLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawGoldLogs.
     */
    cursor?: RawGoldLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawGoldLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawGoldLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawGoldLogs.
     */
    distinct?: RawGoldLogsScalarFieldEnum | RawGoldLogsScalarFieldEnum[]
  }

  /**
   * RawGoldLogs findMany
   */
  export type RawGoldLogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * Filter, which RawGoldLogs to fetch.
     */
    where?: RawGoldLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawGoldLogs to fetch.
     */
    orderBy?: RawGoldLogsOrderByWithRelationInput | RawGoldLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawGoldLogs.
     */
    cursor?: RawGoldLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawGoldLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawGoldLogs.
     */
    skip?: number
    distinct?: RawGoldLogsScalarFieldEnum | RawGoldLogsScalarFieldEnum[]
  }

  /**
   * RawGoldLogs create
   */
  export type RawGoldLogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * The data needed to create a RawGoldLogs.
     */
    data: XOR<RawGoldLogsCreateInput, RawGoldLogsUncheckedCreateInput>
  }

  /**
   * RawGoldLogs createMany
   */
  export type RawGoldLogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawGoldLogs.
     */
    data: RawGoldLogsCreateManyInput | RawGoldLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RawGoldLogs update
   */
  export type RawGoldLogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * The data needed to update a RawGoldLogs.
     */
    data: XOR<RawGoldLogsUpdateInput, RawGoldLogsUncheckedUpdateInput>
    /**
     * Choose, which RawGoldLogs to update.
     */
    where: RawGoldLogsWhereUniqueInput
  }

  /**
   * RawGoldLogs updateMany
   */
  export type RawGoldLogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawGoldLogs.
     */
    data: XOR<RawGoldLogsUpdateManyMutationInput, RawGoldLogsUncheckedUpdateManyInput>
    /**
     * Filter which RawGoldLogs to update
     */
    where?: RawGoldLogsWhereInput
    /**
     * Limit how many RawGoldLogs to update.
     */
    limit?: number
  }

  /**
   * RawGoldLogs upsert
   */
  export type RawGoldLogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * The filter to search for the RawGoldLogs to update in case it exists.
     */
    where: RawGoldLogsWhereUniqueInput
    /**
     * In case the RawGoldLogs found by the `where` argument doesn't exist, create a new RawGoldLogs with this data.
     */
    create: XOR<RawGoldLogsCreateInput, RawGoldLogsUncheckedCreateInput>
    /**
     * In case the RawGoldLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawGoldLogsUpdateInput, RawGoldLogsUncheckedUpdateInput>
  }

  /**
   * RawGoldLogs delete
   */
  export type RawGoldLogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    /**
     * Filter which RawGoldLogs to delete.
     */
    where: RawGoldLogsWhereUniqueInput
  }

  /**
   * RawGoldLogs deleteMany
   */
  export type RawGoldLogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawGoldLogs to delete
     */
    where?: RawGoldLogsWhereInput
    /**
     * Limit how many RawGoldLogs to delete.
     */
    limit?: number
  }

  /**
   * RawGoldLogs.rawGoldStock
   */
  export type RawGoldLogs$rawGoldStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawgoldStock
     */
    select?: RawgoldStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawgoldStock
     */
    omit?: RawgoldStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawgoldStockInclude<ExtArgs> | null
    where?: RawgoldStockWhereInput
  }

  /**
   * RawGoldLogs.givenGold
   */
  export type RawGoldLogs$givenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    where?: givenGoldWhereInput
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    cursor?: givenGoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * RawGoldLogs.receivedSections
   */
  export type RawGoldLogs$receivedSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    where?: ReceivedsectionWhereInput
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    cursor?: ReceivedsectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * RawGoldLogs.billReceive
   */
  export type RawGoldLogs$billReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    where?: billReceivedWhereInput
    orderBy?: billReceivedOrderByWithRelationInput | billReceivedOrderByWithRelationInput[]
    cursor?: billReceivedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillReceivedScalarFieldEnum | BillReceivedScalarFieldEnum[]
  }

  /**
   * RawGoldLogs.receiptVoucher
   */
  export type RawGoldLogs$receiptVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    where?: receiptVoucherWhereInput
    orderBy?: receiptVoucherOrderByWithRelationInput | receiptVoucherOrderByWithRelationInput[]
    cursor?: receiptVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptVoucherScalarFieldEnum | ReceiptVoucherScalarFieldEnum[]
  }

  /**
   * RawGoldLogs.transactions
   */
  export type RawGoldLogs$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * RawGoldLogs.expenseTracker
   */
  export type RawGoldLogs$expenseTrackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    where?: ExpenseTrackerWhereInput
    orderBy?: ExpenseTrackerOrderByWithRelationInput | ExpenseTrackerOrderByWithRelationInput[]
    cursor?: ExpenseTrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseTrackerScalarFieldEnum | ExpenseTrackerScalarFieldEnum[]
  }

  /**
   * RawGoldLogs without action
   */
  export type RawGoldLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseTracker
   */

  export type AggregateExpenseTracker = {
    _count: ExpenseTrackerCountAggregateOutputType | null
    _avg: ExpenseTrackerAvgAggregateOutputType | null
    _sum: ExpenseTrackerSumAggregateOutputType | null
    _min: ExpenseTrackerMinAggregateOutputType | null
    _max: ExpenseTrackerMaxAggregateOutputType | null
  }

  export type ExpenseTrackerAvgAggregateOutputType = {
    id: number | null
    logId: number | null
    gold: number | null
    touch: number | null
    purity: number | null
  }

  export type ExpenseTrackerSumAggregateOutputType = {
    id: number | null
    logId: number | null
    gold: number | null
    touch: number | null
    purity: number | null
  }

  export type ExpenseTrackerMinAggregateOutputType = {
    id: number | null
    logId: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseTrackerMaxAggregateOutputType = {
    id: number | null
    logId: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseTrackerCountAggregateOutputType = {
    id: number
    logId: number
    gold: number
    touch: number
    purity: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseTrackerAvgAggregateInputType = {
    id?: true
    logId?: true
    gold?: true
    touch?: true
    purity?: true
  }

  export type ExpenseTrackerSumAggregateInputType = {
    id?: true
    logId?: true
    gold?: true
    touch?: true
    purity?: true
  }

  export type ExpenseTrackerMinAggregateInputType = {
    id?: true
    logId?: true
    gold?: true
    touch?: true
    purity?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseTrackerMaxAggregateInputType = {
    id?: true
    logId?: true
    gold?: true
    touch?: true
    purity?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseTrackerCountAggregateInputType = {
    id?: true
    logId?: true
    gold?: true
    touch?: true
    purity?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseTrackerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseTracker to aggregate.
     */
    where?: ExpenseTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseTrackers to fetch.
     */
    orderBy?: ExpenseTrackerOrderByWithRelationInput | ExpenseTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseTrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseTrackers
    **/
    _count?: true | ExpenseTrackerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseTrackerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseTrackerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseTrackerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseTrackerMaxAggregateInputType
  }

  export type GetExpenseTrackerAggregateType<T extends ExpenseTrackerAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseTracker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseTracker[P]>
      : GetScalarType<T[P], AggregateExpenseTracker[P]>
  }




  export type ExpenseTrackerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseTrackerWhereInput
    orderBy?: ExpenseTrackerOrderByWithAggregationInput | ExpenseTrackerOrderByWithAggregationInput[]
    by: ExpenseTrackerScalarFieldEnum[] | ExpenseTrackerScalarFieldEnum
    having?: ExpenseTrackerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseTrackerCountAggregateInputType | true
    _avg?: ExpenseTrackerAvgAggregateInputType
    _sum?: ExpenseTrackerSumAggregateInputType
    _min?: ExpenseTrackerMinAggregateInputType
    _max?: ExpenseTrackerMaxAggregateInputType
  }

  export type ExpenseTrackerGroupByOutputType = {
    id: number
    logId: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExpenseTrackerCountAggregateOutputType | null
    _avg: ExpenseTrackerAvgAggregateOutputType | null
    _sum: ExpenseTrackerSumAggregateOutputType | null
    _min: ExpenseTrackerMinAggregateOutputType | null
    _max: ExpenseTrackerMaxAggregateOutputType | null
  }

  type GetExpenseTrackerGroupByPayload<T extends ExpenseTrackerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseTrackerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseTrackerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseTrackerGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseTrackerGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseTrackerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logId?: boolean
    gold?: boolean
    touch?: boolean
    purity?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rawGoldLogs?: boolean | ExpenseTracker$rawGoldLogsArgs<ExtArgs>
  }, ExtArgs["result"]["expenseTracker"]>



  export type ExpenseTrackerSelectScalar = {
    id?: boolean
    logId?: boolean
    gold?: boolean
    touch?: boolean
    purity?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseTrackerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logId" | "gold" | "touch" | "purity" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["expenseTracker"]>
  export type ExpenseTrackerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawGoldLogs?: boolean | ExpenseTracker$rawGoldLogsArgs<ExtArgs>
  }

  export type $ExpenseTrackerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseTracker"
    objects: {
      rawGoldLogs: Prisma.$RawGoldLogsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logId: number | null
      gold: number | null
      touch: number | null
      purity: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expenseTracker"]>
    composites: {}
  }

  type ExpenseTrackerGetPayload<S extends boolean | null | undefined | ExpenseTrackerDefaultArgs> = $Result.GetResult<Prisma.$ExpenseTrackerPayload, S>

  type ExpenseTrackerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseTrackerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseTrackerCountAggregateInputType | true
    }

  export interface ExpenseTrackerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseTracker'], meta: { name: 'ExpenseTracker' } }
    /**
     * Find zero or one ExpenseTracker that matches the filter.
     * @param {ExpenseTrackerFindUniqueArgs} args - Arguments to find a ExpenseTracker
     * @example
     * // Get one ExpenseTracker
     * const expenseTracker = await prisma.expenseTracker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseTrackerFindUniqueArgs>(args: SelectSubset<T, ExpenseTrackerFindUniqueArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseTracker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseTrackerFindUniqueOrThrowArgs} args - Arguments to find a ExpenseTracker
     * @example
     * // Get one ExpenseTracker
     * const expenseTracker = await prisma.expenseTracker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseTrackerFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseTrackerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseTracker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseTrackerFindFirstArgs} args - Arguments to find a ExpenseTracker
     * @example
     * // Get one ExpenseTracker
     * const expenseTracker = await prisma.expenseTracker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseTrackerFindFirstArgs>(args?: SelectSubset<T, ExpenseTrackerFindFirstArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseTracker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseTrackerFindFirstOrThrowArgs} args - Arguments to find a ExpenseTracker
     * @example
     * // Get one ExpenseTracker
     * const expenseTracker = await prisma.expenseTracker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseTrackerFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseTrackerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseTrackers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseTrackerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseTrackers
     * const expenseTrackers = await prisma.expenseTracker.findMany()
     * 
     * // Get first 10 ExpenseTrackers
     * const expenseTrackers = await prisma.expenseTracker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseTrackerWithIdOnly = await prisma.expenseTracker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseTrackerFindManyArgs>(args?: SelectSubset<T, ExpenseTrackerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseTracker.
     * @param {ExpenseTrackerCreateArgs} args - Arguments to create a ExpenseTracker.
     * @example
     * // Create one ExpenseTracker
     * const ExpenseTracker = await prisma.expenseTracker.create({
     *   data: {
     *     // ... data to create a ExpenseTracker
     *   }
     * })
     * 
     */
    create<T extends ExpenseTrackerCreateArgs>(args: SelectSubset<T, ExpenseTrackerCreateArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseTrackers.
     * @param {ExpenseTrackerCreateManyArgs} args - Arguments to create many ExpenseTrackers.
     * @example
     * // Create many ExpenseTrackers
     * const expenseTracker = await prisma.expenseTracker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseTrackerCreateManyArgs>(args?: SelectSubset<T, ExpenseTrackerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExpenseTracker.
     * @param {ExpenseTrackerDeleteArgs} args - Arguments to delete one ExpenseTracker.
     * @example
     * // Delete one ExpenseTracker
     * const ExpenseTracker = await prisma.expenseTracker.delete({
     *   where: {
     *     // ... filter to delete one ExpenseTracker
     *   }
     * })
     * 
     */
    delete<T extends ExpenseTrackerDeleteArgs>(args: SelectSubset<T, ExpenseTrackerDeleteArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseTracker.
     * @param {ExpenseTrackerUpdateArgs} args - Arguments to update one ExpenseTracker.
     * @example
     * // Update one ExpenseTracker
     * const expenseTracker = await prisma.expenseTracker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseTrackerUpdateArgs>(args: SelectSubset<T, ExpenseTrackerUpdateArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseTrackers.
     * @param {ExpenseTrackerDeleteManyArgs} args - Arguments to filter ExpenseTrackers to delete.
     * @example
     * // Delete a few ExpenseTrackers
     * const { count } = await prisma.expenseTracker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseTrackerDeleteManyArgs>(args?: SelectSubset<T, ExpenseTrackerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseTrackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseTrackerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseTrackers
     * const expenseTracker = await prisma.expenseTracker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseTrackerUpdateManyArgs>(args: SelectSubset<T, ExpenseTrackerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpenseTracker.
     * @param {ExpenseTrackerUpsertArgs} args - Arguments to update or create a ExpenseTracker.
     * @example
     * // Update or create a ExpenseTracker
     * const expenseTracker = await prisma.expenseTracker.upsert({
     *   create: {
     *     // ... data to create a ExpenseTracker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseTracker we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseTrackerUpsertArgs>(args: SelectSubset<T, ExpenseTrackerUpsertArgs<ExtArgs>>): Prisma__ExpenseTrackerClient<$Result.GetResult<Prisma.$ExpenseTrackerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseTrackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseTrackerCountArgs} args - Arguments to filter ExpenseTrackers to count.
     * @example
     * // Count the number of ExpenseTrackers
     * const count = await prisma.expenseTracker.count({
     *   where: {
     *     // ... the filter for the ExpenseTrackers we want to count
     *   }
     * })
    **/
    count<T extends ExpenseTrackerCountArgs>(
      args?: Subset<T, ExpenseTrackerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseTrackerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseTracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseTrackerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseTrackerAggregateArgs>(args: Subset<T, ExpenseTrackerAggregateArgs>): Prisma.PrismaPromise<GetExpenseTrackerAggregateType<T>>

    /**
     * Group by ExpenseTracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseTrackerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseTrackerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseTrackerGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseTrackerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseTrackerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseTrackerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseTracker model
   */
  readonly fields: ExpenseTrackerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseTracker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseTrackerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawGoldLogs<T extends ExpenseTracker$rawGoldLogsArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseTracker$rawGoldLogsArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseTracker model
   */
  interface ExpenseTrackerFieldRefs {
    readonly id: FieldRef<"ExpenseTracker", 'Int'>
    readonly logId: FieldRef<"ExpenseTracker", 'Int'>
    readonly gold: FieldRef<"ExpenseTracker", 'Float'>
    readonly touch: FieldRef<"ExpenseTracker", 'Float'>
    readonly purity: FieldRef<"ExpenseTracker", 'Float'>
    readonly description: FieldRef<"ExpenseTracker", 'String'>
    readonly createdAt: FieldRef<"ExpenseTracker", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpenseTracker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseTracker findUnique
   */
  export type ExpenseTrackerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseTracker to fetch.
     */
    where: ExpenseTrackerWhereUniqueInput
  }

  /**
   * ExpenseTracker findUniqueOrThrow
   */
  export type ExpenseTrackerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseTracker to fetch.
     */
    where: ExpenseTrackerWhereUniqueInput
  }

  /**
   * ExpenseTracker findFirst
   */
  export type ExpenseTrackerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseTracker to fetch.
     */
    where?: ExpenseTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseTrackers to fetch.
     */
    orderBy?: ExpenseTrackerOrderByWithRelationInput | ExpenseTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseTrackers.
     */
    cursor?: ExpenseTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseTrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseTrackers.
     */
    distinct?: ExpenseTrackerScalarFieldEnum | ExpenseTrackerScalarFieldEnum[]
  }

  /**
   * ExpenseTracker findFirstOrThrow
   */
  export type ExpenseTrackerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseTracker to fetch.
     */
    where?: ExpenseTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseTrackers to fetch.
     */
    orderBy?: ExpenseTrackerOrderByWithRelationInput | ExpenseTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseTrackers.
     */
    cursor?: ExpenseTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseTrackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseTrackers.
     */
    distinct?: ExpenseTrackerScalarFieldEnum | ExpenseTrackerScalarFieldEnum[]
  }

  /**
   * ExpenseTracker findMany
   */
  export type ExpenseTrackerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseTrackers to fetch.
     */
    where?: ExpenseTrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseTrackers to fetch.
     */
    orderBy?: ExpenseTrackerOrderByWithRelationInput | ExpenseTrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseTrackers.
     */
    cursor?: ExpenseTrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseTrackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseTrackers.
     */
    skip?: number
    distinct?: ExpenseTrackerScalarFieldEnum | ExpenseTrackerScalarFieldEnum[]
  }

  /**
   * ExpenseTracker create
   */
  export type ExpenseTrackerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseTracker.
     */
    data?: XOR<ExpenseTrackerCreateInput, ExpenseTrackerUncheckedCreateInput>
  }

  /**
   * ExpenseTracker createMany
   */
  export type ExpenseTrackerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseTrackers.
     */
    data: ExpenseTrackerCreateManyInput | ExpenseTrackerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseTracker update
   */
  export type ExpenseTrackerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseTracker.
     */
    data: XOR<ExpenseTrackerUpdateInput, ExpenseTrackerUncheckedUpdateInput>
    /**
     * Choose, which ExpenseTracker to update.
     */
    where: ExpenseTrackerWhereUniqueInput
  }

  /**
   * ExpenseTracker updateMany
   */
  export type ExpenseTrackerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseTrackers.
     */
    data: XOR<ExpenseTrackerUpdateManyMutationInput, ExpenseTrackerUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseTrackers to update
     */
    where?: ExpenseTrackerWhereInput
    /**
     * Limit how many ExpenseTrackers to update.
     */
    limit?: number
  }

  /**
   * ExpenseTracker upsert
   */
  export type ExpenseTrackerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseTracker to update in case it exists.
     */
    where: ExpenseTrackerWhereUniqueInput
    /**
     * In case the ExpenseTracker found by the `where` argument doesn't exist, create a new ExpenseTracker with this data.
     */
    create: XOR<ExpenseTrackerCreateInput, ExpenseTrackerUncheckedCreateInput>
    /**
     * In case the ExpenseTracker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseTrackerUpdateInput, ExpenseTrackerUncheckedUpdateInput>
  }

  /**
   * ExpenseTracker delete
   */
  export type ExpenseTrackerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
    /**
     * Filter which ExpenseTracker to delete.
     */
    where: ExpenseTrackerWhereUniqueInput
  }

  /**
   * ExpenseTracker deleteMany
   */
  export type ExpenseTrackerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseTrackers to delete
     */
    where?: ExpenseTrackerWhereInput
    /**
     * Limit how many ExpenseTrackers to delete.
     */
    limit?: number
  }

  /**
   * ExpenseTracker.rawGoldLogs
   */
  export type ExpenseTracker$rawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    where?: RawGoldLogsWhereInput
  }

  /**
   * ExpenseTracker without action
   */
  export type ExpenseTrackerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseTracker
     */
    select?: ExpenseTrackerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseTracker
     */
    omit?: ExpenseTrackerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseTrackerInclude<ExtArgs> | null
  }


  /**
   * Model Balances
   */

  export type AggregateBalances = {
    _count: BalancesCountAggregateOutputType | null
    _avg: BalancesAvgAggregateOutputType | null
    _sum: BalancesSumAggregateOutputType | null
    _min: BalancesMinAggregateOutputType | null
    _max: BalancesMaxAggregateOutputType | null
  }

  export type BalancesAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
  }

  export type BalancesSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
  }

  export type BalancesMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalancesMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalancesCountAggregateOutputType = {
    id: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BalancesAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
  }

  export type BalancesSumAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
  }

  export type BalancesMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalancesMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalancesCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BalancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to aggregate.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalancesMaxAggregateInputType
  }

  export type GetBalancesAggregateType<T extends BalancesAggregateArgs> = {
        [P in keyof T & keyof AggregateBalances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalances[P]>
      : GetScalarType<T[P], AggregateBalances[P]>
  }




  export type BalancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalancesWhereInput
    orderBy?: BalancesOrderByWithAggregationInput | BalancesOrderByWithAggregationInput[]
    by: BalancesScalarFieldEnum[] | BalancesScalarFieldEnum
    having?: BalancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalancesCountAggregateInputType | true
    _avg?: BalancesAvgAggregateInputType
    _sum?: BalancesSumAggregateInputType
    _min?: BalancesMinAggregateInputType
    _max?: BalancesMaxAggregateInputType
  }

  export type BalancesGroupByOutputType = {
    id: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt: Date
    updatedAt: Date
    _count: BalancesCountAggregateOutputType | null
    _avg: BalancesAvgAggregateOutputType | null
    _sum: BalancesSumAggregateOutputType | null
    _min: BalancesMinAggregateOutputType | null
    _max: BalancesMaxAggregateOutputType | null
  }

  type GetBalancesGroupByPayload<T extends BalancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalancesGroupByOutputType[P]>
            : GetScalarType<T[P], BalancesGroupByOutputType[P]>
        }
      >
    >


  export type BalancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    totalDeliveries?: boolean
    totalItemWeight?: boolean
    totalNetWeight?: boolean
    totalPurity?: boolean
    totalReceivedWeight?: boolean
    totalReceivedTouch?: boolean
    totalReceivedPurity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balances"]>



  export type BalancesSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    totalDeliveries?: boolean
    totalItemWeight?: boolean
    totalNetWeight?: boolean
    totalPurity?: boolean
    totalReceivedWeight?: boolean
    totalReceivedTouch?: boolean
    totalReceivedPurity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BalancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "totalDeliveries" | "totalItemWeight" | "totalNetWeight" | "totalPurity" | "totalReceivedWeight" | "totalReceivedTouch" | "totalReceivedPurity" | "createdAt" | "updatedAt", ExtArgs["result"]["balances"]>
  export type BalancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }

  export type $BalancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balances"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number
      totalDeliveries: number
      totalItemWeight: number
      totalNetWeight: number
      totalPurity: number
      totalReceivedWeight: number
      totalReceivedTouch: number
      totalReceivedPurity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["balances"]>
    composites: {}
  }

  type BalancesGetPayload<S extends boolean | null | undefined | BalancesDefaultArgs> = $Result.GetResult<Prisma.$BalancesPayload, S>

  type BalancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalancesCountAggregateInputType | true
    }

  export interface BalancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balances'], meta: { name: 'Balances' } }
    /**
     * Find zero or one Balances that matches the filter.
     * @param {BalancesFindUniqueArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalancesFindUniqueArgs>(args: SelectSubset<T, BalancesFindUniqueArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalancesFindUniqueOrThrowArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalancesFindUniqueOrThrowArgs>(args: SelectSubset<T, BalancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesFindFirstArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalancesFindFirstArgs>(args?: SelectSubset<T, BalancesFindFirstArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesFindFirstOrThrowArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalancesFindFirstOrThrowArgs>(args?: SelectSubset<T, BalancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balances.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balancesWithIdOnly = await prisma.balances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalancesFindManyArgs>(args?: SelectSubset<T, BalancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balances.
     * @param {BalancesCreateArgs} args - Arguments to create a Balances.
     * @example
     * // Create one Balances
     * const Balances = await prisma.balances.create({
     *   data: {
     *     // ... data to create a Balances
     *   }
     * })
     * 
     */
    create<T extends BalancesCreateArgs>(args: SelectSubset<T, BalancesCreateArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balances.
     * @param {BalancesCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balances = await prisma.balances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalancesCreateManyArgs>(args?: SelectSubset<T, BalancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Balances.
     * @param {BalancesDeleteArgs} args - Arguments to delete one Balances.
     * @example
     * // Delete one Balances
     * const Balances = await prisma.balances.delete({
     *   where: {
     *     // ... filter to delete one Balances
     *   }
     * })
     * 
     */
    delete<T extends BalancesDeleteArgs>(args: SelectSubset<T, BalancesDeleteArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balances.
     * @param {BalancesUpdateArgs} args - Arguments to update one Balances.
     * @example
     * // Update one Balances
     * const balances = await prisma.balances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalancesUpdateArgs>(args: SelectSubset<T, BalancesUpdateArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balances.
     * @param {BalancesDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalancesDeleteManyArgs>(args?: SelectSubset<T, BalancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balances = await prisma.balances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalancesUpdateManyArgs>(args: SelectSubset<T, BalancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Balances.
     * @param {BalancesUpsertArgs} args - Arguments to update or create a Balances.
     * @example
     * // Update or create a Balances
     * const balances = await prisma.balances.upsert({
     *   create: {
     *     // ... data to create a Balances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balances we want to update
     *   }
     * })
     */
    upsert<T extends BalancesUpsertArgs>(args: SelectSubset<T, BalancesUpsertArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balances.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalancesCountArgs>(
      args?: Subset<T, BalancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalancesAggregateArgs>(args: Subset<T, BalancesAggregateArgs>): Prisma.PrismaPromise<GetBalancesAggregateType<T>>

    /**
     * Group by Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalancesGroupByArgs['orderBy'] }
        : { orderBy?: BalancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balances model
   */
  readonly fields: BalancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balances model
   */
  interface BalancesFieldRefs {
    readonly id: FieldRef<"Balances", 'Int'>
    readonly goldsmithId: FieldRef<"Balances", 'Int'>
    readonly totalDeliveries: FieldRef<"Balances", 'Int'>
    readonly totalItemWeight: FieldRef<"Balances", 'Float'>
    readonly totalNetWeight: FieldRef<"Balances", 'Float'>
    readonly totalPurity: FieldRef<"Balances", 'Float'>
    readonly totalReceivedWeight: FieldRef<"Balances", 'Float'>
    readonly totalReceivedTouch: FieldRef<"Balances", 'Float'>
    readonly totalReceivedPurity: FieldRef<"Balances", 'Float'>
    readonly createdAt: FieldRef<"Balances", 'DateTime'>
    readonly updatedAt: FieldRef<"Balances", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Balances findUnique
   */
  export type BalancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances findUniqueOrThrow
   */
  export type BalancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances findFirst
   */
  export type BalancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Balances findFirstOrThrow
   */
  export type BalancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Balances findMany
   */
  export type BalancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Balances create
   */
  export type BalancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * The data needed to create a Balances.
     */
    data: XOR<BalancesCreateInput, BalancesUncheckedCreateInput>
  }

  /**
   * Balances createMany
   */
  export type BalancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalancesCreateManyInput | BalancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Balances update
   */
  export type BalancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * The data needed to update a Balances.
     */
    data: XOR<BalancesUpdateInput, BalancesUncheckedUpdateInput>
    /**
     * Choose, which Balances to update.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances updateMany
   */
  export type BalancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalancesUpdateManyMutationInput, BalancesUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalancesWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
  }

  /**
   * Balances upsert
   */
  export type BalancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * The filter to search for the Balances to update in case it exists.
     */
    where: BalancesWhereUniqueInput
    /**
     * In case the Balances found by the `where` argument doesn't exist, create a new Balances with this data.
     */
    create: XOR<BalancesCreateInput, BalancesUncheckedCreateInput>
    /**
     * In case the Balances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalancesUpdateInput, BalancesUncheckedUpdateInput>
  }

  /**
   * Balances delete
   */
  export type BalancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter which Balances to delete.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances deleteMany
   */
  export type BalancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalancesWhereInput
    /**
     * Limit how many Balances to delete.
     */
    limit?: number
  }

  /**
   * Balances without action
   */
  export type BalancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
  }


  /**
   * Model Repair
   */

  export type AggregateRepair = {
    _count: RepairCountAggregateOutputType | null
    _avg: RepairAvgAggregateOutputType | null
    _sum: RepairSumAggregateOutputType | null
    _min: RepairMinAggregateOutputType | null
    _max: RepairMaxAggregateOutputType | null
  }

  export type RepairAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    touch: number | null
    netWeight: number | null
  }

  export type RepairSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    touch: number | null
    netWeight: number | null
  }

  export type RepairMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    wastageType: string | null
    touch: number | null
    netWeight: number | null
    createdAt: Date | null
  }

  export type RepairMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    wastageType: string | null
    touch: number | null
    netWeight: number | null
    createdAt: Date | null
  }

  export type RepairCountAggregateOutputType = {
    id: number
    goldsmithId: number
    givenWeights: number
    totalGiven: number
    itemWeights: number
    totalItem: number
    stone: number
    wastageType: number
    touch: number
    netWeight: number
    createdAt: number
    _all: number
  }


  export type RepairAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    touch?: true
    netWeight?: true
  }

  export type RepairSumAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    touch?: true
    netWeight?: true
  }

  export type RepairMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    wastageType?: true
    touch?: true
    netWeight?: true
    createdAt?: true
  }

  export type RepairMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    wastageType?: true
    touch?: true
    netWeight?: true
    createdAt?: true
  }

  export type RepairCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    givenWeights?: true
    totalGiven?: true
    itemWeights?: true
    totalItem?: true
    stone?: true
    wastageType?: true
    touch?: true
    netWeight?: true
    createdAt?: true
    _all?: true
  }

  export type RepairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repair to aggregate.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Repairs
    **/
    _count?: true | RepairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairMaxAggregateInputType
  }

  export type GetRepairAggregateType<T extends RepairAggregateArgs> = {
        [P in keyof T & keyof AggregateRepair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepair[P]>
      : GetScalarType<T[P], AggregateRepair[P]>
  }




  export type RepairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairWhereInput
    orderBy?: RepairOrderByWithAggregationInput | RepairOrderByWithAggregationInput[]
    by: RepairScalarFieldEnum[] | RepairScalarFieldEnum
    having?: RepairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairCountAggregateInputType | true
    _avg?: RepairAvgAggregateInputType
    _sum?: RepairSumAggregateInputType
    _min?: RepairMinAggregateInputType
    _max?: RepairMaxAggregateInputType
  }

  export type RepairGroupByOutputType = {
    id: number
    goldsmithId: number
    givenWeights: JsonValue
    totalGiven: number
    itemWeights: JsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt: Date
    _count: RepairCountAggregateOutputType | null
    _avg: RepairAvgAggregateOutputType | null
    _sum: RepairSumAggregateOutputType | null
    _min: RepairMinAggregateOutputType | null
    _max: RepairMaxAggregateOutputType | null
  }

  type GetRepairGroupByPayload<T extends RepairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairGroupByOutputType[P]>
            : GetScalarType<T[P], RepairGroupByOutputType[P]>
        }
      >
    >


  export type RepairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    givenWeights?: boolean
    totalGiven?: boolean
    itemWeights?: boolean
    totalItem?: boolean
    stone?: boolean
    wastageType?: boolean
    touch?: boolean
    netWeight?: boolean
    createdAt?: boolean
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repair"]>



  export type RepairSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    givenWeights?: boolean
    totalGiven?: boolean
    itemWeights?: boolean
    totalItem?: boolean
    stone?: boolean
    wastageType?: boolean
    touch?: boolean
    netWeight?: boolean
    createdAt?: boolean
  }

  export type RepairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "givenWeights" | "totalGiven" | "itemWeights" | "totalItem" | "stone" | "wastageType" | "touch" | "netWeight" | "createdAt", ExtArgs["result"]["repair"]>
  export type RepairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }

  export type $RepairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Repair"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number
      givenWeights: Prisma.JsonValue
      totalGiven: number
      itemWeights: Prisma.JsonValue
      totalItem: number
      stone: number
      wastageType: string
      touch: number
      netWeight: number
      createdAt: Date
    }, ExtArgs["result"]["repair"]>
    composites: {}
  }

  type RepairGetPayload<S extends boolean | null | undefined | RepairDefaultArgs> = $Result.GetResult<Prisma.$RepairPayload, S>

  type RepairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RepairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RepairCountAggregateInputType | true
    }

  export interface RepairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Repair'], meta: { name: 'Repair' } }
    /**
     * Find zero or one Repair that matches the filter.
     * @param {RepairFindUniqueArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepairFindUniqueArgs>(args: SelectSubset<T, RepairFindUniqueArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Repair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RepairFindUniqueOrThrowArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepairFindUniqueOrThrowArgs>(args: SelectSubset<T, RepairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairFindFirstArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepairFindFirstArgs>(args?: SelectSubset<T, RepairFindFirstArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairFindFirstOrThrowArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepairFindFirstOrThrowArgs>(args?: SelectSubset<T, RepairFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Repairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repairs
     * const repairs = await prisma.repair.findMany()
     * 
     * // Get first 10 Repairs
     * const repairs = await prisma.repair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairWithIdOnly = await prisma.repair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepairFindManyArgs>(args?: SelectSubset<T, RepairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Repair.
     * @param {RepairCreateArgs} args - Arguments to create a Repair.
     * @example
     * // Create one Repair
     * const Repair = await prisma.repair.create({
     *   data: {
     *     // ... data to create a Repair
     *   }
     * })
     * 
     */
    create<T extends RepairCreateArgs>(args: SelectSubset<T, RepairCreateArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Repairs.
     * @param {RepairCreateManyArgs} args - Arguments to create many Repairs.
     * @example
     * // Create many Repairs
     * const repair = await prisma.repair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepairCreateManyArgs>(args?: SelectSubset<T, RepairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Repair.
     * @param {RepairDeleteArgs} args - Arguments to delete one Repair.
     * @example
     * // Delete one Repair
     * const Repair = await prisma.repair.delete({
     *   where: {
     *     // ... filter to delete one Repair
     *   }
     * })
     * 
     */
    delete<T extends RepairDeleteArgs>(args: SelectSubset<T, RepairDeleteArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Repair.
     * @param {RepairUpdateArgs} args - Arguments to update one Repair.
     * @example
     * // Update one Repair
     * const repair = await prisma.repair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepairUpdateArgs>(args: SelectSubset<T, RepairUpdateArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Repairs.
     * @param {RepairDeleteManyArgs} args - Arguments to filter Repairs to delete.
     * @example
     * // Delete a few Repairs
     * const { count } = await prisma.repair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepairDeleteManyArgs>(args?: SelectSubset<T, RepairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repairs
     * const repair = await prisma.repair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepairUpdateManyArgs>(args: SelectSubset<T, RepairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Repair.
     * @param {RepairUpsertArgs} args - Arguments to update or create a Repair.
     * @example
     * // Update or create a Repair
     * const repair = await prisma.repair.upsert({
     *   create: {
     *     // ... data to create a Repair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repair we want to update
     *   }
     * })
     */
    upsert<T extends RepairUpsertArgs>(args: SelectSubset<T, RepairUpsertArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Repairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairCountArgs} args - Arguments to filter Repairs to count.
     * @example
     * // Count the number of Repairs
     * const count = await prisma.repair.count({
     *   where: {
     *     // ... the filter for the Repairs we want to count
     *   }
     * })
    **/
    count<T extends RepairCountArgs>(
      args?: Subset<T, RepairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairAggregateArgs>(args: Subset<T, RepairAggregateArgs>): Prisma.PrismaPromise<GetRepairAggregateType<T>>

    /**
     * Group by Repair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairGroupByArgs['orderBy'] }
        : { orderBy?: RepairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Repair model
   */
  readonly fields: RepairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Repair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Repair model
   */
  interface RepairFieldRefs {
    readonly id: FieldRef<"Repair", 'Int'>
    readonly goldsmithId: FieldRef<"Repair", 'Int'>
    readonly givenWeights: FieldRef<"Repair", 'Json'>
    readonly totalGiven: FieldRef<"Repair", 'Float'>
    readonly itemWeights: FieldRef<"Repair", 'Json'>
    readonly totalItem: FieldRef<"Repair", 'Float'>
    readonly stone: FieldRef<"Repair", 'Float'>
    readonly wastageType: FieldRef<"Repair", 'String'>
    readonly touch: FieldRef<"Repair", 'Float'>
    readonly netWeight: FieldRef<"Repair", 'Float'>
    readonly createdAt: FieldRef<"Repair", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Repair findUnique
   */
  export type RepairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair findUniqueOrThrow
   */
  export type RepairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair findFirst
   */
  export type RepairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repairs.
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repairs.
     */
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Repair findFirstOrThrow
   */
  export type RepairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repairs.
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repairs.
     */
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Repair findMany
   */
  export type RepairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repairs to fetch.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Repairs.
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Repair create
   */
  export type RepairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * The data needed to create a Repair.
     */
    data: XOR<RepairCreateInput, RepairUncheckedCreateInput>
  }

  /**
   * Repair createMany
   */
  export type RepairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Repairs.
     */
    data: RepairCreateManyInput | RepairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Repair update
   */
  export type RepairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * The data needed to update a Repair.
     */
    data: XOR<RepairUpdateInput, RepairUncheckedUpdateInput>
    /**
     * Choose, which Repair to update.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair updateMany
   */
  export type RepairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Repairs.
     */
    data: XOR<RepairUpdateManyMutationInput, RepairUncheckedUpdateManyInput>
    /**
     * Filter which Repairs to update
     */
    where?: RepairWhereInput
    /**
     * Limit how many Repairs to update.
     */
    limit?: number
  }

  /**
   * Repair upsert
   */
  export type RepairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * The filter to search for the Repair to update in case it exists.
     */
    where: RepairWhereUniqueInput
    /**
     * In case the Repair found by the `where` argument doesn't exist, create a new Repair with this data.
     */
    create: XOR<RepairCreateInput, RepairUncheckedCreateInput>
    /**
     * In case the Repair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairUpdateInput, RepairUncheckedUpdateInput>
  }

  /**
   * Repair delete
   */
  export type RepairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter which Repair to delete.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair deleteMany
   */
  export type RepairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repairs to delete
     */
    where?: RepairWhereInput
    /**
     * Limit how many Repairs to delete.
     */
    limit?: number
  }

  /**
   * Repair without action
   */
  export type RepairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
  }


  /**
   * Model ProductStock
   */

  export type AggregateProductStock = {
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  export type ProductStockAvgAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    stoneWeight: number | null
    wastageValue: number | null
    netWeight: number | null
    wastagePure: number | null
    finalWeight: number | null
  }

  export type ProductStockSumAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    stoneWeight: number | null
    wastageValue: number | null
    netWeight: number | null
    wastagePure: number | null
    finalWeight: number | null
  }

  export type ProductStockMinAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    itemName: string | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    stoneWeight: number | null
    wastageValue: number | null
    netWeight: number | null
    wastagePure: number | null
    finalWeight: number | null
    createdAt: Date | null
  }

  export type ProductStockMaxAggregateOutputType = {
    id: number | null
    jobcardId: number | null
    itemName: string | null
    itemWeight: number | null
    count: number | null
    touch: number | null
    stoneWeight: number | null
    wastageValue: number | null
    netWeight: number | null
    wastagePure: number | null
    finalWeight: number | null
    createdAt: Date | null
  }

  export type ProductStockCountAggregateOutputType = {
    id: number
    jobcardId: number
    itemName: number
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight: number
    wastagePure: number
    finalWeight: number
    createdAt: number
    _all: number
  }


  export type ProductStockAvgAggregateInputType = {
    id?: true
    jobcardId?: true
    itemWeight?: true
    count?: true
    touch?: true
    stoneWeight?: true
    wastageValue?: true
    netWeight?: true
    wastagePure?: true
    finalWeight?: true
  }

  export type ProductStockSumAggregateInputType = {
    id?: true
    jobcardId?: true
    itemWeight?: true
    count?: true
    touch?: true
    stoneWeight?: true
    wastageValue?: true
    netWeight?: true
    wastagePure?: true
    finalWeight?: true
  }

  export type ProductStockMinAggregateInputType = {
    id?: true
    jobcardId?: true
    itemName?: true
    itemWeight?: true
    count?: true
    touch?: true
    stoneWeight?: true
    wastageValue?: true
    netWeight?: true
    wastagePure?: true
    finalWeight?: true
    createdAt?: true
  }

  export type ProductStockMaxAggregateInputType = {
    id?: true
    jobcardId?: true
    itemName?: true
    itemWeight?: true
    count?: true
    touch?: true
    stoneWeight?: true
    wastageValue?: true
    netWeight?: true
    wastagePure?: true
    finalWeight?: true
    createdAt?: true
  }

  export type ProductStockCountAggregateInputType = {
    id?: true
    jobcardId?: true
    itemName?: true
    itemWeight?: true
    count?: true
    touch?: true
    stoneWeight?: true
    wastageValue?: true
    netWeight?: true
    wastagePure?: true
    finalWeight?: true
    createdAt?: true
    _all?: true
  }

  export type ProductStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStock to aggregate.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStocks
    **/
    _count?: true | ProductStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStockMaxAggregateInputType
  }

  export type GetProductStockAggregateType<T extends ProductStockAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStock[P]>
      : GetScalarType<T[P], AggregateProductStock[P]>
  }




  export type ProductStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithAggregationInput | ProductStockOrderByWithAggregationInput[]
    by: ProductStockScalarFieldEnum[] | ProductStockScalarFieldEnum
    having?: ProductStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStockCountAggregateInputType | true
    _avg?: ProductStockAvgAggregateInputType
    _sum?: ProductStockSumAggregateInputType
    _min?: ProductStockMinAggregateInputType
    _max?: ProductStockMaxAggregateInputType
  }

  export type ProductStockGroupByOutputType = {
    id: number
    jobcardId: number
    itemName: string
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight: number | null
    wastagePure: number | null
    finalWeight: number
    createdAt: Date
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  type GetProductStockGroupByPayload<T extends ProductStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
        }
      >
    >


  export type ProductStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobcardId?: boolean
    itemName?: boolean
    itemWeight?: boolean
    count?: boolean
    touch?: boolean
    stoneWeight?: boolean
    wastageValue?: boolean
    netWeight?: boolean
    wastagePure?: boolean
    finalWeight?: boolean
    createdAt?: boolean
    jobcard?: boolean | ProductStock$jobcardArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>



  export type ProductStockSelectScalar = {
    id?: boolean
    jobcardId?: boolean
    itemName?: boolean
    itemWeight?: boolean
    count?: boolean
    touch?: boolean
    stoneWeight?: boolean
    wastageValue?: boolean
    netWeight?: boolean
    wastagePure?: boolean
    finalWeight?: boolean
    createdAt?: boolean
  }

  export type ProductStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobcardId" | "itemName" | "itemWeight" | "count" | "touch" | "stoneWeight" | "wastageValue" | "netWeight" | "wastagePure" | "finalWeight" | "createdAt", ExtArgs["result"]["productStock"]>
  export type ProductStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobcard?: boolean | ProductStock$jobcardArgs<ExtArgs>
  }

  export type $ProductStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStock"
    objects: {
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobcardId: number
      itemName: string
      itemWeight: number
      count: number
      touch: number
      stoneWeight: number
      wastageValue: number
      netWeight: number | null
      wastagePure: number | null
      finalWeight: number
      createdAt: Date
    }, ExtArgs["result"]["productStock"]>
    composites: {}
  }

  type ProductStockGetPayload<S extends boolean | null | undefined | ProductStockDefaultArgs> = $Result.GetResult<Prisma.$ProductStockPayload, S>

  type ProductStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductStockCountAggregateInputType | true
    }

  export interface ProductStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStock'], meta: { name: 'ProductStock' } }
    /**
     * Find zero or one ProductStock that matches the filter.
     * @param {ProductStockFindUniqueArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStockFindUniqueArgs>(args: SelectSubset<T, ProductStockFindUniqueArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductStockFindUniqueOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStockFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStockFindFirstArgs>(args?: SelectSubset<T, ProductStockFindFirstArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStockFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStocks
     * const productStocks = await prisma.productStock.findMany()
     * 
     * // Get first 10 ProductStocks
     * const productStocks = await prisma.productStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productStockWithIdOnly = await prisma.productStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductStockFindManyArgs>(args?: SelectSubset<T, ProductStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductStock.
     * @param {ProductStockCreateArgs} args - Arguments to create a ProductStock.
     * @example
     * // Create one ProductStock
     * const ProductStock = await prisma.productStock.create({
     *   data: {
     *     // ... data to create a ProductStock
     *   }
     * })
     * 
     */
    create<T extends ProductStockCreateArgs>(args: SelectSubset<T, ProductStockCreateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductStocks.
     * @param {ProductStockCreateManyArgs} args - Arguments to create many ProductStocks.
     * @example
     * // Create many ProductStocks
     * const productStock = await prisma.productStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStockCreateManyArgs>(args?: SelectSubset<T, ProductStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductStock.
     * @param {ProductStockDeleteArgs} args - Arguments to delete one ProductStock.
     * @example
     * // Delete one ProductStock
     * const ProductStock = await prisma.productStock.delete({
     *   where: {
     *     // ... filter to delete one ProductStock
     *   }
     * })
     * 
     */
    delete<T extends ProductStockDeleteArgs>(args: SelectSubset<T, ProductStockDeleteArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductStock.
     * @param {ProductStockUpdateArgs} args - Arguments to update one ProductStock.
     * @example
     * // Update one ProductStock
     * const productStock = await prisma.productStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStockUpdateArgs>(args: SelectSubset<T, ProductStockUpdateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductStocks.
     * @param {ProductStockDeleteManyArgs} args - Arguments to filter ProductStocks to delete.
     * @example
     * // Delete a few ProductStocks
     * const { count } = await prisma.productStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStockDeleteManyArgs>(args?: SelectSubset<T, ProductStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStocks
     * const productStock = await prisma.productStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStockUpdateManyArgs>(args: SelectSubset<T, ProductStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductStock.
     * @param {ProductStockUpsertArgs} args - Arguments to update or create a ProductStock.
     * @example
     * // Update or create a ProductStock
     * const productStock = await prisma.productStock.upsert({
     *   create: {
     *     // ... data to create a ProductStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStock we want to update
     *   }
     * })
     */
    upsert<T extends ProductStockUpsertArgs>(args: SelectSubset<T, ProductStockUpsertArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockCountArgs} args - Arguments to filter ProductStocks to count.
     * @example
     * // Count the number of ProductStocks
     * const count = await prisma.productStock.count({
     *   where: {
     *     // ... the filter for the ProductStocks we want to count
     *   }
     * })
    **/
    count<T extends ProductStockCountArgs>(
      args?: Subset<T, ProductStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStockAggregateArgs>(args: Subset<T, ProductStockAggregateArgs>): Prisma.PrismaPromise<GetProductStockAggregateType<T>>

    /**
     * Group by ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStockGroupByArgs['orderBy'] }
        : { orderBy?: ProductStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStock model
   */
  readonly fields: ProductStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobcard<T extends ProductStock$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, ProductStock$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStock model
   */
  interface ProductStockFieldRefs {
    readonly id: FieldRef<"ProductStock", 'Int'>
    readonly jobcardId: FieldRef<"ProductStock", 'Int'>
    readonly itemName: FieldRef<"ProductStock", 'String'>
    readonly itemWeight: FieldRef<"ProductStock", 'Float'>
    readonly count: FieldRef<"ProductStock", 'Int'>
    readonly touch: FieldRef<"ProductStock", 'Float'>
    readonly stoneWeight: FieldRef<"ProductStock", 'Float'>
    readonly wastageValue: FieldRef<"ProductStock", 'Float'>
    readonly netWeight: FieldRef<"ProductStock", 'Float'>
    readonly wastagePure: FieldRef<"ProductStock", 'Float'>
    readonly finalWeight: FieldRef<"ProductStock", 'Float'>
    readonly createdAt: FieldRef<"ProductStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductStock findUnique
   */
  export type ProductStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findUniqueOrThrow
   */
  export type ProductStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findFirst
   */
  export type ProductStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findFirstOrThrow
   */
  export type ProductStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findMany
   */
  export type ProductStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStocks to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock create
   */
  export type ProductStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStock.
     */
    data: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
  }

  /**
   * ProductStock createMany
   */
  export type ProductStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStocks.
     */
    data: ProductStockCreateManyInput | ProductStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductStock update
   */
  export type ProductStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStock.
     */
    data: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
    /**
     * Choose, which ProductStock to update.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock updateMany
   */
  export type ProductStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStocks.
     */
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyInput>
    /**
     * Filter which ProductStocks to update
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to update.
     */
    limit?: number
  }

  /**
   * ProductStock upsert
   */
  export type ProductStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStock to update in case it exists.
     */
    where: ProductStockWhereUniqueInput
    /**
     * In case the ProductStock found by the `where` argument doesn't exist, create a new ProductStock with this data.
     */
    create: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
    /**
     * In case the ProductStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
  }

  /**
   * ProductStock delete
   */
  export type ProductStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter which ProductStock to delete.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock deleteMany
   */
  export type ProductStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStocks to delete
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to delete.
     */
    limit?: number
  }

  /**
   * ProductStock.jobcard
   */
  export type ProductStock$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * ProductStock without action
   */
  export type ProductStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    id: number | null
    customer_id: number | null
    billAmount: number | null
    hallMark: number | null
    prevHallMark: number | null
    PrevBalance: number | null
    billDetailsprofit: number | null
    Stoneprofit: number | null
    Totalprofit: number | null
    cashBalance: number | null
  }

  export type BillSumAggregateOutputType = {
    id: number | null
    customer_id: number | null
    billAmount: number | null
    hallMark: number | null
    prevHallMark: number | null
    PrevBalance: number | null
    billDetailsprofit: number | null
    Stoneprofit: number | null
    Totalprofit: number | null
    cashBalance: number | null
  }

  export type BillMinAggregateOutputType = {
    id: number | null
    date: Date | null
    time: Date | null
    customer_id: number | null
    billAmount: number | null
    hallMark: number | null
    prevHallMark: number | null
    PrevBalance: number | null
    billDetailsprofit: number | null
    Stoneprofit: number | null
    Totalprofit: number | null
    cashBalance: number | null
    createdAt: Date | null
  }

  export type BillMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    time: Date | null
    customer_id: number | null
    billAmount: number | null
    hallMark: number | null
    prevHallMark: number | null
    PrevBalance: number | null
    billDetailsprofit: number | null
    Stoneprofit: number | null
    Totalprofit: number | null
    cashBalance: number | null
    createdAt: Date | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    date: number
    time: number
    customer_id: number
    billAmount: number
    hallMark: number
    prevHallMark: number
    PrevBalance: number
    billDetailsprofit: number
    Stoneprofit: number
    Totalprofit: number
    cashBalance: number
    createdAt: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    id?: true
    customer_id?: true
    billAmount?: true
    hallMark?: true
    prevHallMark?: true
    PrevBalance?: true
    billDetailsprofit?: true
    Stoneprofit?: true
    Totalprofit?: true
    cashBalance?: true
  }

  export type BillSumAggregateInputType = {
    id?: true
    customer_id?: true
    billAmount?: true
    hallMark?: true
    prevHallMark?: true
    PrevBalance?: true
    billDetailsprofit?: true
    Stoneprofit?: true
    Totalprofit?: true
    cashBalance?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    customer_id?: true
    billAmount?: true
    hallMark?: true
    prevHallMark?: true
    PrevBalance?: true
    billDetailsprofit?: true
    Stoneprofit?: true
    Totalprofit?: true
    cashBalance?: true
    createdAt?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    customer_id?: true
    billAmount?: true
    hallMark?: true
    prevHallMark?: true
    PrevBalance?: true
    billDetailsprofit?: true
    Stoneprofit?: true
    Totalprofit?: true
    cashBalance?: true
    createdAt?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    customer_id?: true
    billAmount?: true
    hallMark?: true
    prevHallMark?: true
    PrevBalance?: true
    billDetailsprofit?: true
    Stoneprofit?: true
    Totalprofit?: true
    cashBalance?: true
    createdAt?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: number
    date: Date | null
    time: Date | null
    customer_id: number
    billAmount: number
    hallMark: number | null
    prevHallMark: number | null
    PrevBalance: number | null
    billDetailsprofit: number | null
    Stoneprofit: number | null
    Totalprofit: number | null
    cashBalance: number | null
    createdAt: Date
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    customer_id?: boolean
    billAmount?: boolean
    hallMark?: boolean
    prevHallMark?: boolean
    PrevBalance?: boolean
    billDetailsprofit?: boolean
    Stoneprofit?: boolean
    Totalprofit?: boolean
    cashBalance?: boolean
    createdAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    orders?: boolean | Bill$ordersArgs<ExtArgs>
    billReceive?: boolean | Bill$billReceiveArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>



  export type BillSelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    customer_id?: boolean
    billAmount?: boolean
    hallMark?: boolean
    prevHallMark?: boolean
    PrevBalance?: boolean
    billDetailsprofit?: boolean
    Stoneprofit?: boolean
    Totalprofit?: boolean
    cashBalance?: boolean
    createdAt?: boolean
  }

  export type BillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "time" | "customer_id" | "billAmount" | "hallMark" | "prevHallMark" | "PrevBalance" | "billDetailsprofit" | "Stoneprofit" | "Totalprofit" | "cashBalance" | "createdAt", ExtArgs["result"]["bill"]>
  export type BillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    orders?: boolean | Bill$ordersArgs<ExtArgs>
    billReceive?: boolean | Bill$billReceiveArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>
      orders: Prisma.$OrderItemsPayload<ExtArgs>[]
      billReceive: Prisma.$billReceivedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date | null
      time: Date | null
      customer_id: number
      billAmount: number
      hallMark: number | null
      prevHallMark: number | null
      PrevBalance: number | null
      billDetailsprofit: number | null
      Stoneprofit: number | null
      Totalprofit: number | null
      cashBalance: number | null
      createdAt: Date
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Bill$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Bill$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billReceive<T extends Bill$billReceiveArgs<ExtArgs> = {}>(args?: Subset<T, Bill$billReceiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'Int'>
    readonly date: FieldRef<"Bill", 'DateTime'>
    readonly time: FieldRef<"Bill", 'DateTime'>
    readonly customer_id: FieldRef<"Bill", 'Int'>
    readonly billAmount: FieldRef<"Bill", 'Float'>
    readonly hallMark: FieldRef<"Bill", 'Float'>
    readonly prevHallMark: FieldRef<"Bill", 'Float'>
    readonly PrevBalance: FieldRef<"Bill", 'Float'>
    readonly billDetailsprofit: FieldRef<"Bill", 'Float'>
    readonly Stoneprofit: FieldRef<"Bill", 'Float'>
    readonly Totalprofit: FieldRef<"Bill", 'Float'>
    readonly cashBalance: FieldRef<"Bill", 'Float'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to delete.
     */
    limit?: number
  }

  /**
   * Bill.orders
   */
  export type Bill$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Bill.billReceive
   */
  export type Bill$billReceiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    where?: billReceivedWhereInput
    orderBy?: billReceivedOrderByWithRelationInput | billReceivedOrderByWithRelationInput[]
    cursor?: billReceivedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillReceivedScalarFieldEnum | BillReceivedScalarFieldEnum[]
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
  }


  /**
   * Model OrderItems
   */

  export type AggregateOrderItems = {
    _count: OrderItemsCountAggregateOutputType | null
    _avg: OrderItemsAvgAggregateOutputType | null
    _sum: OrderItemsSumAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  export type OrderItemsAvgAggregateOutputType = {
    id: number | null
    billId: number | null
    count: number | null
    weight: number | null
    stoneWeight: number | null
    afterWeight: number | null
    percentage: number | null
    finalWeight: number | null
  }

  export type OrderItemsSumAggregateOutputType = {
    id: number | null
    billId: number | null
    count: number | null
    weight: number | null
    stoneWeight: number | null
    afterWeight: number | null
    percentage: number | null
    finalWeight: number | null
  }

  export type OrderItemsMinAggregateOutputType = {
    id: number | null
    billId: number | null
    productName: string | null
    count: number | null
    weight: number | null
    stoneWeight: number | null
    afterWeight: number | null
    percentage: number | null
    finalWeight: number | null
    createdAt: Date | null
  }

  export type OrderItemsMaxAggregateOutputType = {
    id: number | null
    billId: number | null
    productName: string | null
    count: number | null
    weight: number | null
    stoneWeight: number | null
    afterWeight: number | null
    percentage: number | null
    finalWeight: number | null
    createdAt: Date | null
  }

  export type OrderItemsCountAggregateOutputType = {
    id: number
    billId: number
    productName: number
    count: number
    weight: number
    stoneWeight: number
    afterWeight: number
    percentage: number
    finalWeight: number
    createdAt: number
    _all: number
  }


  export type OrderItemsAvgAggregateInputType = {
    id?: true
    billId?: true
    count?: true
    weight?: true
    stoneWeight?: true
    afterWeight?: true
    percentage?: true
    finalWeight?: true
  }

  export type OrderItemsSumAggregateInputType = {
    id?: true
    billId?: true
    count?: true
    weight?: true
    stoneWeight?: true
    afterWeight?: true
    percentage?: true
    finalWeight?: true
  }

  export type OrderItemsMinAggregateInputType = {
    id?: true
    billId?: true
    productName?: true
    count?: true
    weight?: true
    stoneWeight?: true
    afterWeight?: true
    percentage?: true
    finalWeight?: true
    createdAt?: true
  }

  export type OrderItemsMaxAggregateInputType = {
    id?: true
    billId?: true
    productName?: true
    count?: true
    weight?: true
    stoneWeight?: true
    afterWeight?: true
    percentage?: true
    finalWeight?: true
    createdAt?: true
  }

  export type OrderItemsCountAggregateInputType = {
    id?: true
    billId?: true
    productName?: true
    count?: true
    weight?: true
    stoneWeight?: true
    afterWeight?: true
    percentage?: true
    finalWeight?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to aggregate.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemsMaxAggregateInputType
  }

  export type GetOrderItemsAggregateType<T extends OrderItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItems[P]>
      : GetScalarType<T[P], AggregateOrderItems[P]>
  }




  export type OrderItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithAggregationInput | OrderItemsOrderByWithAggregationInput[]
    by: OrderItemsScalarFieldEnum[] | OrderItemsScalarFieldEnum
    having?: OrderItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemsCountAggregateInputType | true
    _avg?: OrderItemsAvgAggregateInputType
    _sum?: OrderItemsSumAggregateInputType
    _min?: OrderItemsMinAggregateInputType
    _max?: OrderItemsMaxAggregateInputType
  }

  export type OrderItemsGroupByOutputType = {
    id: number
    billId: number
    productName: string
    count: number | null
    weight: number | null
    stoneWeight: number | null
    afterWeight: number | null
    percentage: number | null
    finalWeight: number | null
    createdAt: Date
    _count: OrderItemsCountAggregateOutputType | null
    _avg: OrderItemsAvgAggregateOutputType | null
    _sum: OrderItemsSumAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  type GetOrderItemsGroupByPayload<T extends OrderItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    productName?: boolean
    count?: boolean
    weight?: boolean
    stoneWeight?: boolean
    afterWeight?: boolean
    percentage?: boolean
    finalWeight?: boolean
    createdAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItems"]>



  export type OrderItemsSelectScalar = {
    id?: boolean
    billId?: boolean
    productName?: boolean
    count?: boolean
    weight?: boolean
    stoneWeight?: boolean
    afterWeight?: boolean
    percentage?: boolean
    finalWeight?: boolean
    createdAt?: boolean
  }

  export type OrderItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "productName" | "count" | "weight" | "stoneWeight" | "afterWeight" | "percentage" | "finalWeight" | "createdAt", ExtArgs["result"]["orderItems"]>
  export type OrderItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }

  export type $OrderItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItems"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      billId: number
      productName: string
      count: number | null
      weight: number | null
      stoneWeight: number | null
      afterWeight: number | null
      percentage: number | null
      finalWeight: number | null
      createdAt: Date
    }, ExtArgs["result"]["orderItems"]>
    composites: {}
  }

  type OrderItemsGetPayload<S extends boolean | null | undefined | OrderItemsDefaultArgs> = $Result.GetResult<Prisma.$OrderItemsPayload, S>

  type OrderItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemsCountAggregateInputType | true
    }

  export interface OrderItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItems'], meta: { name: 'OrderItems' } }
    /**
     * Find zero or one OrderItems that matches the filter.
     * @param {OrderItemsFindUniqueArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemsFindUniqueArgs>(args: SelectSubset<T, OrderItemsFindUniqueArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemsFindUniqueOrThrowArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindFirstArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemsFindFirstArgs>(args?: SelectSubset<T, OrderItemsFindFirstArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindFirstOrThrowArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItems.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemsWithIdOnly = await prisma.orderItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemsFindManyArgs>(args?: SelectSubset<T, OrderItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItems.
     * @param {OrderItemsCreateArgs} args - Arguments to create a OrderItems.
     * @example
     * // Create one OrderItems
     * const OrderItems = await prisma.orderItems.create({
     *   data: {
     *     // ... data to create a OrderItems
     *   }
     * })
     * 
     */
    create<T extends OrderItemsCreateArgs>(args: SelectSubset<T, OrderItemsCreateArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemsCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItems = await prisma.orderItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemsCreateManyArgs>(args?: SelectSubset<T, OrderItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItems.
     * @param {OrderItemsDeleteArgs} args - Arguments to delete one OrderItems.
     * @example
     * // Delete one OrderItems
     * const OrderItems = await prisma.orderItems.delete({
     *   where: {
     *     // ... filter to delete one OrderItems
     *   }
     * })
     * 
     */
    delete<T extends OrderItemsDeleteArgs>(args: SelectSubset<T, OrderItemsDeleteArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItems.
     * @param {OrderItemsUpdateArgs} args - Arguments to update one OrderItems.
     * @example
     * // Update one OrderItems
     * const orderItems = await prisma.orderItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemsUpdateArgs>(args: SelectSubset<T, OrderItemsUpdateArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemsDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemsDeleteManyArgs>(args?: SelectSubset<T, OrderItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItems = await prisma.orderItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemsUpdateManyArgs>(args: SelectSubset<T, OrderItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItems.
     * @param {OrderItemsUpsertArgs} args - Arguments to update or create a OrderItems.
     * @example
     * // Update or create a OrderItems
     * const orderItems = await prisma.orderItems.upsert({
     *   create: {
     *     // ... data to create a OrderItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItems we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemsUpsertArgs>(args: SelectSubset<T, OrderItemsUpsertArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItems.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemsCountArgs>(
      args?: Subset<T, OrderItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemsAggregateArgs>(args: Subset<T, OrderItemsAggregateArgs>): Prisma.PrismaPromise<GetOrderItemsAggregateType<T>>

    /**
     * Group by OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemsGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItems model
   */
  readonly fields: OrderItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItems model
   */
  interface OrderItemsFieldRefs {
    readonly id: FieldRef<"OrderItems", 'Int'>
    readonly billId: FieldRef<"OrderItems", 'Int'>
    readonly productName: FieldRef<"OrderItems", 'String'>
    readonly count: FieldRef<"OrderItems", 'Int'>
    readonly weight: FieldRef<"OrderItems", 'Float'>
    readonly stoneWeight: FieldRef<"OrderItems", 'Float'>
    readonly afterWeight: FieldRef<"OrderItems", 'Float'>
    readonly percentage: FieldRef<"OrderItems", 'Float'>
    readonly finalWeight: FieldRef<"OrderItems", 'Float'>
    readonly createdAt: FieldRef<"OrderItems", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItems findUnique
   */
  export type OrderItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems findUniqueOrThrow
   */
  export type OrderItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems findFirst
   */
  export type OrderItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems findFirstOrThrow
   */
  export type OrderItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems findMany
   */
  export type OrderItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems create
   */
  export type OrderItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItems.
     */
    data: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
  }

  /**
   * OrderItems createMany
   */
  export type OrderItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemsCreateManyInput | OrderItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItems update
   */
  export type OrderItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItems.
     */
    data: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
    /**
     * Choose, which OrderItems to update.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems updateMany
   */
  export type OrderItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemsWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItems upsert
   */
  export type OrderItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItems to update in case it exists.
     */
    where: OrderItemsWhereUniqueInput
    /**
     * In case the OrderItems found by the `where` argument doesn't exist, create a new OrderItems with this data.
     */
    create: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
    /**
     * In case the OrderItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
  }

  /**
   * OrderItems delete
   */
  export type OrderItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter which OrderItems to delete.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems deleteMany
   */
  export type OrderItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemsWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItems without action
   */
  export type OrderItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
  }


  /**
   * Model billReceived
   */

  export type AggregateBillReceived = {
    _count: BillReceivedCountAggregateOutputType | null
    _avg: BillReceivedAvgAggregateOutputType | null
    _sum: BillReceivedSumAggregateOutputType | null
    _min: BillReceivedMinAggregateOutputType | null
    _max: BillReceivedMaxAggregateOutputType | null
  }

  export type BillReceivedAvgAggregateOutputType = {
    id: number | null
    billId: number | null
    customer_id: number | null
    logId: number | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
  }

  export type BillReceivedSumAggregateOutputType = {
    id: number | null
    billId: number | null
    customer_id: number | null
    logId: number | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
  }

  export type BillReceivedMinAggregateOutputType = {
    id: number | null
    billId: number | null
    customer_id: number | null
    logId: number | null
    date: string | null
    type: string | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type BillReceivedMaxAggregateOutputType = {
    id: number | null
    billId: number | null
    customer_id: number | null
    logId: number | null
    date: string | null
    type: string | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type BillReceivedCountAggregateOutputType = {
    id: number
    billId: number
    customer_id: number
    logId: number
    date: number
    type: number
    goldRate: number
    gold: number
    touch: number
    purity: number
    receiveHallMark: number
    amount: number
    createdAt: number
    _all: number
  }


  export type BillReceivedAvgAggregateInputType = {
    id?: true
    billId?: true
    customer_id?: true
    logId?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
  }

  export type BillReceivedSumAggregateInputType = {
    id?: true
    billId?: true
    customer_id?: true
    logId?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
  }

  export type BillReceivedMinAggregateInputType = {
    id?: true
    billId?: true
    customer_id?: true
    logId?: true
    date?: true
    type?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
    createdAt?: true
  }

  export type BillReceivedMaxAggregateInputType = {
    id?: true
    billId?: true
    customer_id?: true
    logId?: true
    date?: true
    type?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
    createdAt?: true
  }

  export type BillReceivedCountAggregateInputType = {
    id?: true
    billId?: true
    customer_id?: true
    logId?: true
    date?: true
    type?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
    createdAt?: true
    _all?: true
  }

  export type BillReceivedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billReceived to aggregate.
     */
    where?: billReceivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billReceiveds to fetch.
     */
    orderBy?: billReceivedOrderByWithRelationInput | billReceivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: billReceivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billReceiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billReceiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned billReceiveds
    **/
    _count?: true | BillReceivedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillReceivedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillReceivedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillReceivedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillReceivedMaxAggregateInputType
  }

  export type GetBillReceivedAggregateType<T extends BillReceivedAggregateArgs> = {
        [P in keyof T & keyof AggregateBillReceived]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillReceived[P]>
      : GetScalarType<T[P], AggregateBillReceived[P]>
  }




  export type billReceivedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billReceivedWhereInput
    orderBy?: billReceivedOrderByWithAggregationInput | billReceivedOrderByWithAggregationInput[]
    by: BillReceivedScalarFieldEnum[] | BillReceivedScalarFieldEnum
    having?: billReceivedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillReceivedCountAggregateInputType | true
    _avg?: BillReceivedAvgAggregateInputType
    _sum?: BillReceivedSumAggregateInputType
    _min?: BillReceivedMinAggregateInputType
    _max?: BillReceivedMaxAggregateInputType
  }

  export type BillReceivedGroupByOutputType = {
    id: number
    billId: number | null
    customer_id: number
    logId: number | null
    date: string | null
    type: string | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
    createdAt: Date
    _count: BillReceivedCountAggregateOutputType | null
    _avg: BillReceivedAvgAggregateOutputType | null
    _sum: BillReceivedSumAggregateOutputType | null
    _min: BillReceivedMinAggregateOutputType | null
    _max: BillReceivedMaxAggregateOutputType | null
  }

  type GetBillReceivedGroupByPayload<T extends billReceivedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillReceivedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillReceivedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillReceivedGroupByOutputType[P]>
            : GetScalarType<T[P], BillReceivedGroupByOutputType[P]>
        }
      >
    >


  export type billReceivedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    customer_id?: boolean
    logId?: boolean
    date?: boolean
    type?: boolean
    goldRate?: boolean
    gold?: boolean
    touch?: boolean
    purity?: boolean
    receiveHallMark?: boolean
    amount?: boolean
    createdAt?: boolean
    bill?: boolean | billReceived$billArgs<ExtArgs>
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    rawGoldLogs?: boolean | billReceived$rawGoldLogsArgs<ExtArgs>
  }, ExtArgs["result"]["billReceived"]>



  export type billReceivedSelectScalar = {
    id?: boolean
    billId?: boolean
    customer_id?: boolean
    logId?: boolean
    date?: boolean
    type?: boolean
    goldRate?: boolean
    gold?: boolean
    touch?: boolean
    purity?: boolean
    receiveHallMark?: boolean
    amount?: boolean
    createdAt?: boolean
  }

  export type billReceivedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "customer_id" | "logId" | "date" | "type" | "goldRate" | "gold" | "touch" | "purity" | "receiveHallMark" | "amount" | "createdAt", ExtArgs["result"]["billReceived"]>
  export type billReceivedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | billReceived$billArgs<ExtArgs>
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    rawGoldLogs?: boolean | billReceived$rawGoldLogsArgs<ExtArgs>
  }

  export type $billReceivedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "billReceived"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs> | null
      customers: Prisma.$CustomerPayload<ExtArgs>
      rawGoldLogs: Prisma.$RawGoldLogsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      billId: number | null
      customer_id: number
      logId: number | null
      date: string | null
      type: string | null
      goldRate: number | null
      gold: number | null
      touch: number | null
      purity: number | null
      receiveHallMark: number | null
      amount: number | null
      createdAt: Date
    }, ExtArgs["result"]["billReceived"]>
    composites: {}
  }

  type billReceivedGetPayload<S extends boolean | null | undefined | billReceivedDefaultArgs> = $Result.GetResult<Prisma.$billReceivedPayload, S>

  type billReceivedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<billReceivedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillReceivedCountAggregateInputType | true
    }

  export interface billReceivedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['billReceived'], meta: { name: 'billReceived' } }
    /**
     * Find zero or one BillReceived that matches the filter.
     * @param {billReceivedFindUniqueArgs} args - Arguments to find a BillReceived
     * @example
     * // Get one BillReceived
     * const billReceived = await prisma.billReceived.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends billReceivedFindUniqueArgs>(args: SelectSubset<T, billReceivedFindUniqueArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillReceived that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {billReceivedFindUniqueOrThrowArgs} args - Arguments to find a BillReceived
     * @example
     * // Get one BillReceived
     * const billReceived = await prisma.billReceived.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends billReceivedFindUniqueOrThrowArgs>(args: SelectSubset<T, billReceivedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillReceived that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billReceivedFindFirstArgs} args - Arguments to find a BillReceived
     * @example
     * // Get one BillReceived
     * const billReceived = await prisma.billReceived.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends billReceivedFindFirstArgs>(args?: SelectSubset<T, billReceivedFindFirstArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillReceived that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billReceivedFindFirstOrThrowArgs} args - Arguments to find a BillReceived
     * @example
     * // Get one BillReceived
     * const billReceived = await prisma.billReceived.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends billReceivedFindFirstOrThrowArgs>(args?: SelectSubset<T, billReceivedFindFirstOrThrowArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillReceiveds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billReceivedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillReceiveds
     * const billReceiveds = await prisma.billReceived.findMany()
     * 
     * // Get first 10 BillReceiveds
     * const billReceiveds = await prisma.billReceived.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billReceivedWithIdOnly = await prisma.billReceived.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends billReceivedFindManyArgs>(args?: SelectSubset<T, billReceivedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillReceived.
     * @param {billReceivedCreateArgs} args - Arguments to create a BillReceived.
     * @example
     * // Create one BillReceived
     * const BillReceived = await prisma.billReceived.create({
     *   data: {
     *     // ... data to create a BillReceived
     *   }
     * })
     * 
     */
    create<T extends billReceivedCreateArgs>(args: SelectSubset<T, billReceivedCreateArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillReceiveds.
     * @param {billReceivedCreateManyArgs} args - Arguments to create many BillReceiveds.
     * @example
     * // Create many BillReceiveds
     * const billReceived = await prisma.billReceived.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends billReceivedCreateManyArgs>(args?: SelectSubset<T, billReceivedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BillReceived.
     * @param {billReceivedDeleteArgs} args - Arguments to delete one BillReceived.
     * @example
     * // Delete one BillReceived
     * const BillReceived = await prisma.billReceived.delete({
     *   where: {
     *     // ... filter to delete one BillReceived
     *   }
     * })
     * 
     */
    delete<T extends billReceivedDeleteArgs>(args: SelectSubset<T, billReceivedDeleteArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillReceived.
     * @param {billReceivedUpdateArgs} args - Arguments to update one BillReceived.
     * @example
     * // Update one BillReceived
     * const billReceived = await prisma.billReceived.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends billReceivedUpdateArgs>(args: SelectSubset<T, billReceivedUpdateArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillReceiveds.
     * @param {billReceivedDeleteManyArgs} args - Arguments to filter BillReceiveds to delete.
     * @example
     * // Delete a few BillReceiveds
     * const { count } = await prisma.billReceived.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends billReceivedDeleteManyArgs>(args?: SelectSubset<T, billReceivedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillReceiveds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billReceivedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillReceiveds
     * const billReceived = await prisma.billReceived.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends billReceivedUpdateManyArgs>(args: SelectSubset<T, billReceivedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillReceived.
     * @param {billReceivedUpsertArgs} args - Arguments to update or create a BillReceived.
     * @example
     * // Update or create a BillReceived
     * const billReceived = await prisma.billReceived.upsert({
     *   create: {
     *     // ... data to create a BillReceived
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillReceived we want to update
     *   }
     * })
     */
    upsert<T extends billReceivedUpsertArgs>(args: SelectSubset<T, billReceivedUpsertArgs<ExtArgs>>): Prisma__billReceivedClient<$Result.GetResult<Prisma.$billReceivedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillReceiveds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billReceivedCountArgs} args - Arguments to filter BillReceiveds to count.
     * @example
     * // Count the number of BillReceiveds
     * const count = await prisma.billReceived.count({
     *   where: {
     *     // ... the filter for the BillReceiveds we want to count
     *   }
     * })
    **/
    count<T extends billReceivedCountArgs>(
      args?: Subset<T, billReceivedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillReceivedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillReceived.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillReceivedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillReceivedAggregateArgs>(args: Subset<T, BillReceivedAggregateArgs>): Prisma.PrismaPromise<GetBillReceivedAggregateType<T>>

    /**
     * Group by BillReceived.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billReceivedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends billReceivedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: billReceivedGroupByArgs['orderBy'] }
        : { orderBy?: billReceivedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, billReceivedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillReceivedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the billReceived model
   */
  readonly fields: billReceivedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for billReceived.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__billReceivedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends billReceived$billArgs<ExtArgs> = {}>(args?: Subset<T, billReceived$billArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rawGoldLogs<T extends billReceived$rawGoldLogsArgs<ExtArgs> = {}>(args?: Subset<T, billReceived$rawGoldLogsArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the billReceived model
   */
  interface billReceivedFieldRefs {
    readonly id: FieldRef<"billReceived", 'Int'>
    readonly billId: FieldRef<"billReceived", 'Int'>
    readonly customer_id: FieldRef<"billReceived", 'Int'>
    readonly logId: FieldRef<"billReceived", 'Int'>
    readonly date: FieldRef<"billReceived", 'String'>
    readonly type: FieldRef<"billReceived", 'String'>
    readonly goldRate: FieldRef<"billReceived", 'Int'>
    readonly gold: FieldRef<"billReceived", 'Float'>
    readonly touch: FieldRef<"billReceived", 'Float'>
    readonly purity: FieldRef<"billReceived", 'Float'>
    readonly receiveHallMark: FieldRef<"billReceived", 'Float'>
    readonly amount: FieldRef<"billReceived", 'Float'>
    readonly createdAt: FieldRef<"billReceived", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * billReceived findUnique
   */
  export type billReceivedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * Filter, which billReceived to fetch.
     */
    where: billReceivedWhereUniqueInput
  }

  /**
   * billReceived findUniqueOrThrow
   */
  export type billReceivedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * Filter, which billReceived to fetch.
     */
    where: billReceivedWhereUniqueInput
  }

  /**
   * billReceived findFirst
   */
  export type billReceivedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * Filter, which billReceived to fetch.
     */
    where?: billReceivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billReceiveds to fetch.
     */
    orderBy?: billReceivedOrderByWithRelationInput | billReceivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billReceiveds.
     */
    cursor?: billReceivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billReceiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billReceiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billReceiveds.
     */
    distinct?: BillReceivedScalarFieldEnum | BillReceivedScalarFieldEnum[]
  }

  /**
   * billReceived findFirstOrThrow
   */
  export type billReceivedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * Filter, which billReceived to fetch.
     */
    where?: billReceivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billReceiveds to fetch.
     */
    orderBy?: billReceivedOrderByWithRelationInput | billReceivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billReceiveds.
     */
    cursor?: billReceivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billReceiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billReceiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billReceiveds.
     */
    distinct?: BillReceivedScalarFieldEnum | BillReceivedScalarFieldEnum[]
  }

  /**
   * billReceived findMany
   */
  export type billReceivedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * Filter, which billReceiveds to fetch.
     */
    where?: billReceivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billReceiveds to fetch.
     */
    orderBy?: billReceivedOrderByWithRelationInput | billReceivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing billReceiveds.
     */
    cursor?: billReceivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billReceiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billReceiveds.
     */
    skip?: number
    distinct?: BillReceivedScalarFieldEnum | BillReceivedScalarFieldEnum[]
  }

  /**
   * billReceived create
   */
  export type billReceivedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * The data needed to create a billReceived.
     */
    data: XOR<billReceivedCreateInput, billReceivedUncheckedCreateInput>
  }

  /**
   * billReceived createMany
   */
  export type billReceivedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many billReceiveds.
     */
    data: billReceivedCreateManyInput | billReceivedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * billReceived update
   */
  export type billReceivedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * The data needed to update a billReceived.
     */
    data: XOR<billReceivedUpdateInput, billReceivedUncheckedUpdateInput>
    /**
     * Choose, which billReceived to update.
     */
    where: billReceivedWhereUniqueInput
  }

  /**
   * billReceived updateMany
   */
  export type billReceivedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update billReceiveds.
     */
    data: XOR<billReceivedUpdateManyMutationInput, billReceivedUncheckedUpdateManyInput>
    /**
     * Filter which billReceiveds to update
     */
    where?: billReceivedWhereInput
    /**
     * Limit how many billReceiveds to update.
     */
    limit?: number
  }

  /**
   * billReceived upsert
   */
  export type billReceivedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * The filter to search for the billReceived to update in case it exists.
     */
    where: billReceivedWhereUniqueInput
    /**
     * In case the billReceived found by the `where` argument doesn't exist, create a new billReceived with this data.
     */
    create: XOR<billReceivedCreateInput, billReceivedUncheckedCreateInput>
    /**
     * In case the billReceived was found with the provided `where` argument, update it with this data.
     */
    update: XOR<billReceivedUpdateInput, billReceivedUncheckedUpdateInput>
  }

  /**
   * billReceived delete
   */
  export type billReceivedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
    /**
     * Filter which billReceived to delete.
     */
    where: billReceivedWhereUniqueInput
  }

  /**
   * billReceived deleteMany
   */
  export type billReceivedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billReceiveds to delete
     */
    where?: billReceivedWhereInput
    /**
     * Limit how many billReceiveds to delete.
     */
    limit?: number
  }

  /**
   * billReceived.bill
   */
  export type billReceived$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
  }

  /**
   * billReceived.rawGoldLogs
   */
  export type billReceived$rawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    where?: RawGoldLogsWhereInput
  }

  /**
   * billReceived without action
   */
  export type billReceivedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billReceived
     */
    select?: billReceivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billReceived
     */
    omit?: billReceivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billReceivedInclude<ExtArgs> | null
  }


  /**
   * Model receiptVoucher
   */

  export type AggregateReceiptVoucher = {
    _count: ReceiptVoucherCountAggregateOutputType | null
    _avg: ReceiptVoucherAvgAggregateOutputType | null
    _sum: ReceiptVoucherSumAggregateOutputType | null
    _min: ReceiptVoucherMinAggregateOutputType | null
    _max: ReceiptVoucherMaxAggregateOutputType | null
  }

  export type ReceiptVoucherAvgAggregateOutputType = {
    id: number | null
    customer_id: number | null
    logId: number | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
  }

  export type ReceiptVoucherSumAggregateOutputType = {
    id: number | null
    customer_id: number | null
    logId: number | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
  }

  export type ReceiptVoucherMinAggregateOutputType = {
    id: number | null
    customer_id: number | null
    logId: number | null
    date: string | null
    type: string | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type ReceiptVoucherMaxAggregateOutputType = {
    id: number | null
    customer_id: number | null
    logId: number | null
    date: string | null
    type: string | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type ReceiptVoucherCountAggregateOutputType = {
    id: number
    customer_id: number
    logId: number
    date: number
    type: number
    goldRate: number
    gold: number
    touch: number
    purity: number
    receiveHallMark: number
    amount: number
    createdAt: number
    _all: number
  }


  export type ReceiptVoucherAvgAggregateInputType = {
    id?: true
    customer_id?: true
    logId?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
  }

  export type ReceiptVoucherSumAggregateInputType = {
    id?: true
    customer_id?: true
    logId?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
  }

  export type ReceiptVoucherMinAggregateInputType = {
    id?: true
    customer_id?: true
    logId?: true
    date?: true
    type?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
    createdAt?: true
  }

  export type ReceiptVoucherMaxAggregateInputType = {
    id?: true
    customer_id?: true
    logId?: true
    date?: true
    type?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
    createdAt?: true
  }

  export type ReceiptVoucherCountAggregateInputType = {
    id?: true
    customer_id?: true
    logId?: true
    date?: true
    type?: true
    goldRate?: true
    gold?: true
    touch?: true
    purity?: true
    receiveHallMark?: true
    amount?: true
    createdAt?: true
    _all?: true
  }

  export type ReceiptVoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receiptVoucher to aggregate.
     */
    where?: receiptVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptVouchers to fetch.
     */
    orderBy?: receiptVoucherOrderByWithRelationInput | receiptVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: receiptVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned receiptVouchers
    **/
    _count?: true | ReceiptVoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptVoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptVoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptVoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptVoucherMaxAggregateInputType
  }

  export type GetReceiptVoucherAggregateType<T extends ReceiptVoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiptVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiptVoucher[P]>
      : GetScalarType<T[P], AggregateReceiptVoucher[P]>
  }




  export type receiptVoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: receiptVoucherWhereInput
    orderBy?: receiptVoucherOrderByWithAggregationInput | receiptVoucherOrderByWithAggregationInput[]
    by: ReceiptVoucherScalarFieldEnum[] | ReceiptVoucherScalarFieldEnum
    having?: receiptVoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptVoucherCountAggregateInputType | true
    _avg?: ReceiptVoucherAvgAggregateInputType
    _sum?: ReceiptVoucherSumAggregateInputType
    _min?: ReceiptVoucherMinAggregateInputType
    _max?: ReceiptVoucherMaxAggregateInputType
  }

  export type ReceiptVoucherGroupByOutputType = {
    id: number
    customer_id: number
    logId: number | null
    date: string | null
    type: string | null
    goldRate: number | null
    gold: number | null
    touch: number | null
    purity: number | null
    receiveHallMark: number | null
    amount: number | null
    createdAt: Date
    _count: ReceiptVoucherCountAggregateOutputType | null
    _avg: ReceiptVoucherAvgAggregateOutputType | null
    _sum: ReceiptVoucherSumAggregateOutputType | null
    _min: ReceiptVoucherMinAggregateOutputType | null
    _max: ReceiptVoucherMaxAggregateOutputType | null
  }

  type GetReceiptVoucherGroupByPayload<T extends receiptVoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptVoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptVoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptVoucherGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptVoucherGroupByOutputType[P]>
        }
      >
    >


  export type receiptVoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    logId?: boolean
    date?: boolean
    type?: boolean
    goldRate?: boolean
    gold?: boolean
    touch?: boolean
    purity?: boolean
    receiveHallMark?: boolean
    amount?: boolean
    createdAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    rawGoldLogs?: boolean | receiptVoucher$rawGoldLogsArgs<ExtArgs>
  }, ExtArgs["result"]["receiptVoucher"]>



  export type receiptVoucherSelectScalar = {
    id?: boolean
    customer_id?: boolean
    logId?: boolean
    date?: boolean
    type?: boolean
    goldRate?: boolean
    gold?: boolean
    touch?: boolean
    purity?: boolean
    receiveHallMark?: boolean
    amount?: boolean
    createdAt?: boolean
  }

  export type receiptVoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "logId" | "date" | "type" | "goldRate" | "gold" | "touch" | "purity" | "receiveHallMark" | "amount" | "createdAt", ExtArgs["result"]["receiptVoucher"]>
  export type receiptVoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    rawGoldLogs?: boolean | receiptVoucher$rawGoldLogsArgs<ExtArgs>
  }

  export type $receiptVoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "receiptVoucher"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>
      rawGoldLogs: Prisma.$RawGoldLogsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_id: number
      logId: number | null
      date: string | null
      type: string | null
      goldRate: number | null
      gold: number | null
      touch: number | null
      purity: number | null
      receiveHallMark: number | null
      amount: number | null
      createdAt: Date
    }, ExtArgs["result"]["receiptVoucher"]>
    composites: {}
  }

  type receiptVoucherGetPayload<S extends boolean | null | undefined | receiptVoucherDefaultArgs> = $Result.GetResult<Prisma.$receiptVoucherPayload, S>

  type receiptVoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<receiptVoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptVoucherCountAggregateInputType | true
    }

  export interface receiptVoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['receiptVoucher'], meta: { name: 'receiptVoucher' } }
    /**
     * Find zero or one ReceiptVoucher that matches the filter.
     * @param {receiptVoucherFindUniqueArgs} args - Arguments to find a ReceiptVoucher
     * @example
     * // Get one ReceiptVoucher
     * const receiptVoucher = await prisma.receiptVoucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends receiptVoucherFindUniqueArgs>(args: SelectSubset<T, receiptVoucherFindUniqueArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReceiptVoucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {receiptVoucherFindUniqueOrThrowArgs} args - Arguments to find a ReceiptVoucher
     * @example
     * // Get one ReceiptVoucher
     * const receiptVoucher = await prisma.receiptVoucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends receiptVoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, receiptVoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptVoucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptVoucherFindFirstArgs} args - Arguments to find a ReceiptVoucher
     * @example
     * // Get one ReceiptVoucher
     * const receiptVoucher = await prisma.receiptVoucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends receiptVoucherFindFirstArgs>(args?: SelectSubset<T, receiptVoucherFindFirstArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptVoucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptVoucherFindFirstOrThrowArgs} args - Arguments to find a ReceiptVoucher
     * @example
     * // Get one ReceiptVoucher
     * const receiptVoucher = await prisma.receiptVoucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends receiptVoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, receiptVoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReceiptVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptVoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceiptVouchers
     * const receiptVouchers = await prisma.receiptVoucher.findMany()
     * 
     * // Get first 10 ReceiptVouchers
     * const receiptVouchers = await prisma.receiptVoucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptVoucherWithIdOnly = await prisma.receiptVoucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends receiptVoucherFindManyArgs>(args?: SelectSubset<T, receiptVoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReceiptVoucher.
     * @param {receiptVoucherCreateArgs} args - Arguments to create a ReceiptVoucher.
     * @example
     * // Create one ReceiptVoucher
     * const ReceiptVoucher = await prisma.receiptVoucher.create({
     *   data: {
     *     // ... data to create a ReceiptVoucher
     *   }
     * })
     * 
     */
    create<T extends receiptVoucherCreateArgs>(args: SelectSubset<T, receiptVoucherCreateArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReceiptVouchers.
     * @param {receiptVoucherCreateManyArgs} args - Arguments to create many ReceiptVouchers.
     * @example
     * // Create many ReceiptVouchers
     * const receiptVoucher = await prisma.receiptVoucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends receiptVoucherCreateManyArgs>(args?: SelectSubset<T, receiptVoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReceiptVoucher.
     * @param {receiptVoucherDeleteArgs} args - Arguments to delete one ReceiptVoucher.
     * @example
     * // Delete one ReceiptVoucher
     * const ReceiptVoucher = await prisma.receiptVoucher.delete({
     *   where: {
     *     // ... filter to delete one ReceiptVoucher
     *   }
     * })
     * 
     */
    delete<T extends receiptVoucherDeleteArgs>(args: SelectSubset<T, receiptVoucherDeleteArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReceiptVoucher.
     * @param {receiptVoucherUpdateArgs} args - Arguments to update one ReceiptVoucher.
     * @example
     * // Update one ReceiptVoucher
     * const receiptVoucher = await prisma.receiptVoucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends receiptVoucherUpdateArgs>(args: SelectSubset<T, receiptVoucherUpdateArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReceiptVouchers.
     * @param {receiptVoucherDeleteManyArgs} args - Arguments to filter ReceiptVouchers to delete.
     * @example
     * // Delete a few ReceiptVouchers
     * const { count } = await prisma.receiptVoucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends receiptVoucherDeleteManyArgs>(args?: SelectSubset<T, receiptVoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptVoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceiptVouchers
     * const receiptVoucher = await prisma.receiptVoucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends receiptVoucherUpdateManyArgs>(args: SelectSubset<T, receiptVoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceiptVoucher.
     * @param {receiptVoucherUpsertArgs} args - Arguments to update or create a ReceiptVoucher.
     * @example
     * // Update or create a ReceiptVoucher
     * const receiptVoucher = await prisma.receiptVoucher.upsert({
     *   create: {
     *     // ... data to create a ReceiptVoucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceiptVoucher we want to update
     *   }
     * })
     */
    upsert<T extends receiptVoucherUpsertArgs>(args: SelectSubset<T, receiptVoucherUpsertArgs<ExtArgs>>): Prisma__receiptVoucherClient<$Result.GetResult<Prisma.$receiptVoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReceiptVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptVoucherCountArgs} args - Arguments to filter ReceiptVouchers to count.
     * @example
     * // Count the number of ReceiptVouchers
     * const count = await prisma.receiptVoucher.count({
     *   where: {
     *     // ... the filter for the ReceiptVouchers we want to count
     *   }
     * })
    **/
    count<T extends receiptVoucherCountArgs>(
      args?: Subset<T, receiptVoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptVoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceiptVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptVoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptVoucherAggregateArgs>(args: Subset<T, ReceiptVoucherAggregateArgs>): Prisma.PrismaPromise<GetReceiptVoucherAggregateType<T>>

    /**
     * Group by ReceiptVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptVoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends receiptVoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: receiptVoucherGroupByArgs['orderBy'] }
        : { orderBy?: receiptVoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, receiptVoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the receiptVoucher model
   */
  readonly fields: receiptVoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for receiptVoucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__receiptVoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rawGoldLogs<T extends receiptVoucher$rawGoldLogsArgs<ExtArgs> = {}>(args?: Subset<T, receiptVoucher$rawGoldLogsArgs<ExtArgs>>): Prisma__RawGoldLogsClient<$Result.GetResult<Prisma.$RawGoldLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the receiptVoucher model
   */
  interface receiptVoucherFieldRefs {
    readonly id: FieldRef<"receiptVoucher", 'Int'>
    readonly customer_id: FieldRef<"receiptVoucher", 'Int'>
    readonly logId: FieldRef<"receiptVoucher", 'Int'>
    readonly date: FieldRef<"receiptVoucher", 'String'>
    readonly type: FieldRef<"receiptVoucher", 'String'>
    readonly goldRate: FieldRef<"receiptVoucher", 'Int'>
    readonly gold: FieldRef<"receiptVoucher", 'Float'>
    readonly touch: FieldRef<"receiptVoucher", 'Float'>
    readonly purity: FieldRef<"receiptVoucher", 'Float'>
    readonly receiveHallMark: FieldRef<"receiptVoucher", 'Float'>
    readonly amount: FieldRef<"receiptVoucher", 'Float'>
    readonly createdAt: FieldRef<"receiptVoucher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * receiptVoucher findUnique
   */
  export type receiptVoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * Filter, which receiptVoucher to fetch.
     */
    where: receiptVoucherWhereUniqueInput
  }

  /**
   * receiptVoucher findUniqueOrThrow
   */
  export type receiptVoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * Filter, which receiptVoucher to fetch.
     */
    where: receiptVoucherWhereUniqueInput
  }

  /**
   * receiptVoucher findFirst
   */
  export type receiptVoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * Filter, which receiptVoucher to fetch.
     */
    where?: receiptVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptVouchers to fetch.
     */
    orderBy?: receiptVoucherOrderByWithRelationInput | receiptVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receiptVouchers.
     */
    cursor?: receiptVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receiptVouchers.
     */
    distinct?: ReceiptVoucherScalarFieldEnum | ReceiptVoucherScalarFieldEnum[]
  }

  /**
   * receiptVoucher findFirstOrThrow
   */
  export type receiptVoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * Filter, which receiptVoucher to fetch.
     */
    where?: receiptVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptVouchers to fetch.
     */
    orderBy?: receiptVoucherOrderByWithRelationInput | receiptVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receiptVouchers.
     */
    cursor?: receiptVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receiptVouchers.
     */
    distinct?: ReceiptVoucherScalarFieldEnum | ReceiptVoucherScalarFieldEnum[]
  }

  /**
   * receiptVoucher findMany
   */
  export type receiptVoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * Filter, which receiptVouchers to fetch.
     */
    where?: receiptVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptVouchers to fetch.
     */
    orderBy?: receiptVoucherOrderByWithRelationInput | receiptVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing receiptVouchers.
     */
    cursor?: receiptVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptVouchers.
     */
    skip?: number
    distinct?: ReceiptVoucherScalarFieldEnum | ReceiptVoucherScalarFieldEnum[]
  }

  /**
   * receiptVoucher create
   */
  export type receiptVoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a receiptVoucher.
     */
    data: XOR<receiptVoucherCreateInput, receiptVoucherUncheckedCreateInput>
  }

  /**
   * receiptVoucher createMany
   */
  export type receiptVoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many receiptVouchers.
     */
    data: receiptVoucherCreateManyInput | receiptVoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * receiptVoucher update
   */
  export type receiptVoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a receiptVoucher.
     */
    data: XOR<receiptVoucherUpdateInput, receiptVoucherUncheckedUpdateInput>
    /**
     * Choose, which receiptVoucher to update.
     */
    where: receiptVoucherWhereUniqueInput
  }

  /**
   * receiptVoucher updateMany
   */
  export type receiptVoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update receiptVouchers.
     */
    data: XOR<receiptVoucherUpdateManyMutationInput, receiptVoucherUncheckedUpdateManyInput>
    /**
     * Filter which receiptVouchers to update
     */
    where?: receiptVoucherWhereInput
    /**
     * Limit how many receiptVouchers to update.
     */
    limit?: number
  }

  /**
   * receiptVoucher upsert
   */
  export type receiptVoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the receiptVoucher to update in case it exists.
     */
    where: receiptVoucherWhereUniqueInput
    /**
     * In case the receiptVoucher found by the `where` argument doesn't exist, create a new receiptVoucher with this data.
     */
    create: XOR<receiptVoucherCreateInput, receiptVoucherUncheckedCreateInput>
    /**
     * In case the receiptVoucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<receiptVoucherUpdateInput, receiptVoucherUncheckedUpdateInput>
  }

  /**
   * receiptVoucher delete
   */
  export type receiptVoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
    /**
     * Filter which receiptVoucher to delete.
     */
    where: receiptVoucherWhereUniqueInput
  }

  /**
   * receiptVoucher deleteMany
   */
  export type receiptVoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receiptVouchers to delete
     */
    where?: receiptVoucherWhereInput
    /**
     * Limit how many receiptVouchers to delete.
     */
    limit?: number
  }

  /**
   * receiptVoucher.rawGoldLogs
   */
  export type receiptVoucher$rawGoldLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawGoldLogs
     */
    select?: RawGoldLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawGoldLogs
     */
    omit?: RawGoldLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawGoldLogsInclude<ExtArgs> | null
    where?: RawGoldLogsWhereInput
  }

  /**
   * receiptVoucher without action
   */
  export type receiptVoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptVoucher
     */
    select?: receiptVoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptVoucher
     */
    omit?: receiptVoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: receiptVoucherInclude<ExtArgs> | null
  }


  /**
   * Model customerBillBalance
   */

  export type AggregateCustomerBillBalance = {
    _count: CustomerBillBalanceCountAggregateOutputType | null
    _avg: CustomerBillBalanceAvgAggregateOutputType | null
    _sum: CustomerBillBalanceSumAggregateOutputType | null
    _min: CustomerBillBalanceMinAggregateOutputType | null
    _max: CustomerBillBalanceMaxAggregateOutputType | null
  }

  export type CustomerBillBalanceAvgAggregateOutputType = {
    id: number | null
    balance: number | null
    hallMarkBal: number | null
    customer_id: number | null
  }

  export type CustomerBillBalanceSumAggregateOutputType = {
    id: number | null
    balance: number | null
    hallMarkBal: number | null
    customer_id: number | null
  }

  export type CustomerBillBalanceMinAggregateOutputType = {
    id: number | null
    balance: number | null
    hallMarkBal: number | null
    customer_id: number | null
    createdAt: Date | null
  }

  export type CustomerBillBalanceMaxAggregateOutputType = {
    id: number | null
    balance: number | null
    hallMarkBal: number | null
    customer_id: number | null
    createdAt: Date | null
  }

  export type CustomerBillBalanceCountAggregateOutputType = {
    id: number
    balance: number
    hallMarkBal: number
    customer_id: number
    createdAt: number
    _all: number
  }


  export type CustomerBillBalanceAvgAggregateInputType = {
    id?: true
    balance?: true
    hallMarkBal?: true
    customer_id?: true
  }

  export type CustomerBillBalanceSumAggregateInputType = {
    id?: true
    balance?: true
    hallMarkBal?: true
    customer_id?: true
  }

  export type CustomerBillBalanceMinAggregateInputType = {
    id?: true
    balance?: true
    hallMarkBal?: true
    customer_id?: true
    createdAt?: true
  }

  export type CustomerBillBalanceMaxAggregateInputType = {
    id?: true
    balance?: true
    hallMarkBal?: true
    customer_id?: true
    createdAt?: true
  }

  export type CustomerBillBalanceCountAggregateInputType = {
    id?: true
    balance?: true
    hallMarkBal?: true
    customer_id?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerBillBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerBillBalance to aggregate.
     */
    where?: customerBillBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerBillBalances to fetch.
     */
    orderBy?: customerBillBalanceOrderByWithRelationInput | customerBillBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerBillBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerBillBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerBillBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customerBillBalances
    **/
    _count?: true | CustomerBillBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerBillBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerBillBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerBillBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerBillBalanceMaxAggregateInputType
  }

  export type GetCustomerBillBalanceAggregateType<T extends CustomerBillBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerBillBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerBillBalance[P]>
      : GetScalarType<T[P], AggregateCustomerBillBalance[P]>
  }




  export type customerBillBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerBillBalanceWhereInput
    orderBy?: customerBillBalanceOrderByWithAggregationInput | customerBillBalanceOrderByWithAggregationInput[]
    by: CustomerBillBalanceScalarFieldEnum[] | CustomerBillBalanceScalarFieldEnum
    having?: customerBillBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerBillBalanceCountAggregateInputType | true
    _avg?: CustomerBillBalanceAvgAggregateInputType
    _sum?: CustomerBillBalanceSumAggregateInputType
    _min?: CustomerBillBalanceMinAggregateInputType
    _max?: CustomerBillBalanceMaxAggregateInputType
  }

  export type CustomerBillBalanceGroupByOutputType = {
    id: number
    balance: number | null
    hallMarkBal: number | null
    customer_id: number
    createdAt: Date
    _count: CustomerBillBalanceCountAggregateOutputType | null
    _avg: CustomerBillBalanceAvgAggregateOutputType | null
    _sum: CustomerBillBalanceSumAggregateOutputType | null
    _min: CustomerBillBalanceMinAggregateOutputType | null
    _max: CustomerBillBalanceMaxAggregateOutputType | null
  }

  type GetCustomerBillBalanceGroupByPayload<T extends customerBillBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerBillBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerBillBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerBillBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerBillBalanceGroupByOutputType[P]>
        }
      >
    >


  export type customerBillBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    hallMarkBal?: boolean
    customer_id?: boolean
    createdAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerBillBalance"]>



  export type customerBillBalanceSelectScalar = {
    id?: boolean
    balance?: boolean
    hallMarkBal?: boolean
    customer_id?: boolean
    createdAt?: boolean
  }

  export type customerBillBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "balance" | "hallMarkBal" | "customer_id" | "createdAt", ExtArgs["result"]["customerBillBalance"]>
  export type customerBillBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $customerBillBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customerBillBalance"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      balance: number | null
      hallMarkBal: number | null
      customer_id: number
      createdAt: Date
    }, ExtArgs["result"]["customerBillBalance"]>
    composites: {}
  }

  type customerBillBalanceGetPayload<S extends boolean | null | undefined | customerBillBalanceDefaultArgs> = $Result.GetResult<Prisma.$customerBillBalancePayload, S>

  type customerBillBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerBillBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerBillBalanceCountAggregateInputType | true
    }

  export interface customerBillBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customerBillBalance'], meta: { name: 'customerBillBalance' } }
    /**
     * Find zero or one CustomerBillBalance that matches the filter.
     * @param {customerBillBalanceFindUniqueArgs} args - Arguments to find a CustomerBillBalance
     * @example
     * // Get one CustomerBillBalance
     * const customerBillBalance = await prisma.customerBillBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerBillBalanceFindUniqueArgs>(args: SelectSubset<T, customerBillBalanceFindUniqueArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerBillBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerBillBalanceFindUniqueOrThrowArgs} args - Arguments to find a CustomerBillBalance
     * @example
     * // Get one CustomerBillBalance
     * const customerBillBalance = await prisma.customerBillBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerBillBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, customerBillBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerBillBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerBillBalanceFindFirstArgs} args - Arguments to find a CustomerBillBalance
     * @example
     * // Get one CustomerBillBalance
     * const customerBillBalance = await prisma.customerBillBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerBillBalanceFindFirstArgs>(args?: SelectSubset<T, customerBillBalanceFindFirstArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerBillBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerBillBalanceFindFirstOrThrowArgs} args - Arguments to find a CustomerBillBalance
     * @example
     * // Get one CustomerBillBalance
     * const customerBillBalance = await prisma.customerBillBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerBillBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, customerBillBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerBillBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerBillBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerBillBalances
     * const customerBillBalances = await prisma.customerBillBalance.findMany()
     * 
     * // Get first 10 CustomerBillBalances
     * const customerBillBalances = await prisma.customerBillBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerBillBalanceWithIdOnly = await prisma.customerBillBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customerBillBalanceFindManyArgs>(args?: SelectSubset<T, customerBillBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerBillBalance.
     * @param {customerBillBalanceCreateArgs} args - Arguments to create a CustomerBillBalance.
     * @example
     * // Create one CustomerBillBalance
     * const CustomerBillBalance = await prisma.customerBillBalance.create({
     *   data: {
     *     // ... data to create a CustomerBillBalance
     *   }
     * })
     * 
     */
    create<T extends customerBillBalanceCreateArgs>(args: SelectSubset<T, customerBillBalanceCreateArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerBillBalances.
     * @param {customerBillBalanceCreateManyArgs} args - Arguments to create many CustomerBillBalances.
     * @example
     * // Create many CustomerBillBalances
     * const customerBillBalance = await prisma.customerBillBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerBillBalanceCreateManyArgs>(args?: SelectSubset<T, customerBillBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerBillBalance.
     * @param {customerBillBalanceDeleteArgs} args - Arguments to delete one CustomerBillBalance.
     * @example
     * // Delete one CustomerBillBalance
     * const CustomerBillBalance = await prisma.customerBillBalance.delete({
     *   where: {
     *     // ... filter to delete one CustomerBillBalance
     *   }
     * })
     * 
     */
    delete<T extends customerBillBalanceDeleteArgs>(args: SelectSubset<T, customerBillBalanceDeleteArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerBillBalance.
     * @param {customerBillBalanceUpdateArgs} args - Arguments to update one CustomerBillBalance.
     * @example
     * // Update one CustomerBillBalance
     * const customerBillBalance = await prisma.customerBillBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerBillBalanceUpdateArgs>(args: SelectSubset<T, customerBillBalanceUpdateArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerBillBalances.
     * @param {customerBillBalanceDeleteManyArgs} args - Arguments to filter CustomerBillBalances to delete.
     * @example
     * // Delete a few CustomerBillBalances
     * const { count } = await prisma.customerBillBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerBillBalanceDeleteManyArgs>(args?: SelectSubset<T, customerBillBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerBillBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerBillBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerBillBalances
     * const customerBillBalance = await prisma.customerBillBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerBillBalanceUpdateManyArgs>(args: SelectSubset<T, customerBillBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerBillBalance.
     * @param {customerBillBalanceUpsertArgs} args - Arguments to update or create a CustomerBillBalance.
     * @example
     * // Update or create a CustomerBillBalance
     * const customerBillBalance = await prisma.customerBillBalance.upsert({
     *   create: {
     *     // ... data to create a CustomerBillBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerBillBalance we want to update
     *   }
     * })
     */
    upsert<T extends customerBillBalanceUpsertArgs>(args: SelectSubset<T, customerBillBalanceUpsertArgs<ExtArgs>>): Prisma__customerBillBalanceClient<$Result.GetResult<Prisma.$customerBillBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerBillBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerBillBalanceCountArgs} args - Arguments to filter CustomerBillBalances to count.
     * @example
     * // Count the number of CustomerBillBalances
     * const count = await prisma.customerBillBalance.count({
     *   where: {
     *     // ... the filter for the CustomerBillBalances we want to count
     *   }
     * })
    **/
    count<T extends customerBillBalanceCountArgs>(
      args?: Subset<T, customerBillBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerBillBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerBillBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBillBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerBillBalanceAggregateArgs>(args: Subset<T, CustomerBillBalanceAggregateArgs>): Prisma.PrismaPromise<GetCustomerBillBalanceAggregateType<T>>

    /**
     * Group by CustomerBillBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerBillBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerBillBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerBillBalanceGroupByArgs['orderBy'] }
        : { orderBy?: customerBillBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerBillBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerBillBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customerBillBalance model
   */
  readonly fields: customerBillBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customerBillBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerBillBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customerBillBalance model
   */
  interface customerBillBalanceFieldRefs {
    readonly id: FieldRef<"customerBillBalance", 'Int'>
    readonly balance: FieldRef<"customerBillBalance", 'Float'>
    readonly hallMarkBal: FieldRef<"customerBillBalance", 'Float'>
    readonly customer_id: FieldRef<"customerBillBalance", 'Int'>
    readonly createdAt: FieldRef<"customerBillBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customerBillBalance findUnique
   */
  export type customerBillBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * Filter, which customerBillBalance to fetch.
     */
    where: customerBillBalanceWhereUniqueInput
  }

  /**
   * customerBillBalance findUniqueOrThrow
   */
  export type customerBillBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * Filter, which customerBillBalance to fetch.
     */
    where: customerBillBalanceWhereUniqueInput
  }

  /**
   * customerBillBalance findFirst
   */
  export type customerBillBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * Filter, which customerBillBalance to fetch.
     */
    where?: customerBillBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerBillBalances to fetch.
     */
    orderBy?: customerBillBalanceOrderByWithRelationInput | customerBillBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerBillBalances.
     */
    cursor?: customerBillBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerBillBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerBillBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerBillBalances.
     */
    distinct?: CustomerBillBalanceScalarFieldEnum | CustomerBillBalanceScalarFieldEnum[]
  }

  /**
   * customerBillBalance findFirstOrThrow
   */
  export type customerBillBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * Filter, which customerBillBalance to fetch.
     */
    where?: customerBillBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerBillBalances to fetch.
     */
    orderBy?: customerBillBalanceOrderByWithRelationInput | customerBillBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerBillBalances.
     */
    cursor?: customerBillBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerBillBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerBillBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerBillBalances.
     */
    distinct?: CustomerBillBalanceScalarFieldEnum | CustomerBillBalanceScalarFieldEnum[]
  }

  /**
   * customerBillBalance findMany
   */
  export type customerBillBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * Filter, which customerBillBalances to fetch.
     */
    where?: customerBillBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerBillBalances to fetch.
     */
    orderBy?: customerBillBalanceOrderByWithRelationInput | customerBillBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customerBillBalances.
     */
    cursor?: customerBillBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerBillBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerBillBalances.
     */
    skip?: number
    distinct?: CustomerBillBalanceScalarFieldEnum | CustomerBillBalanceScalarFieldEnum[]
  }

  /**
   * customerBillBalance create
   */
  export type customerBillBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a customerBillBalance.
     */
    data: XOR<customerBillBalanceCreateInput, customerBillBalanceUncheckedCreateInput>
  }

  /**
   * customerBillBalance createMany
   */
  export type customerBillBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customerBillBalances.
     */
    data: customerBillBalanceCreateManyInput | customerBillBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customerBillBalance update
   */
  export type customerBillBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a customerBillBalance.
     */
    data: XOR<customerBillBalanceUpdateInput, customerBillBalanceUncheckedUpdateInput>
    /**
     * Choose, which customerBillBalance to update.
     */
    where: customerBillBalanceWhereUniqueInput
  }

  /**
   * customerBillBalance updateMany
   */
  export type customerBillBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customerBillBalances.
     */
    data: XOR<customerBillBalanceUpdateManyMutationInput, customerBillBalanceUncheckedUpdateManyInput>
    /**
     * Filter which customerBillBalances to update
     */
    where?: customerBillBalanceWhereInput
    /**
     * Limit how many customerBillBalances to update.
     */
    limit?: number
  }

  /**
   * customerBillBalance upsert
   */
  export type customerBillBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the customerBillBalance to update in case it exists.
     */
    where: customerBillBalanceWhereUniqueInput
    /**
     * In case the customerBillBalance found by the `where` argument doesn't exist, create a new customerBillBalance with this data.
     */
    create: XOR<customerBillBalanceCreateInput, customerBillBalanceUncheckedCreateInput>
    /**
     * In case the customerBillBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerBillBalanceUpdateInput, customerBillBalanceUncheckedUpdateInput>
  }

  /**
   * customerBillBalance delete
   */
  export type customerBillBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
    /**
     * Filter which customerBillBalance to delete.
     */
    where: customerBillBalanceWhereUniqueInput
  }

  /**
   * customerBillBalance deleteMany
   */
  export type customerBillBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerBillBalances to delete
     */
    where?: customerBillBalanceWhereInput
    /**
     * Limit how many customerBillBalances to delete.
     */
    limit?: number
  }

  /**
   * customerBillBalance without action
   */
  export type customerBillBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerBillBalance
     */
    select?: customerBillBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerBillBalance
     */
    omit?: customerBillBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerBillBalanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const MasterItemScalarFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    createdAt: 'createdAt'
  };

  export type MasterItemScalarFieldEnum = (typeof MasterItemScalarFieldEnum)[keyof typeof MasterItemScalarFieldEnum]


  export const MasterTouchScalarFieldEnum: {
    id: 'id',
    touch: 'touch',
    createdAt: 'createdAt'
  };

  export type MasterTouchScalarFieldEnum = (typeof MasterTouchScalarFieldEnum)[keyof typeof MasterTouchScalarFieldEnum]


  export const MasterWastageScalarFieldEnum: {
    id: 'id',
    wastage: 'wastage',
    createdAt: 'createdAt'
  };

  export type MasterWastageScalarFieldEnum = (typeof MasterWastageScalarFieldEnum)[keyof typeof MasterWastageScalarFieldEnum]


  export const MastercopperScalarFieldEnum: {
    id: 'id',
    copperTotal: 'copperTotal',
    remainCopper: 'remainCopper',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MastercopperScalarFieldEnum = (typeof MastercopperScalarFieldEnum)[keyof typeof MastercopperScalarFieldEnum]


  export const JewelStockScalarFieldEnum: {
    id: 'id',
    jewelName: 'jewelName',
    weight: 'weight',
    stoneWeight: 'stoneWeight',
    finalWeight: 'finalWeight',
    touch: 'touch',
    purityValue: 'purityValue',
    createdAt: 'createdAt'
  };

  export type JewelStockScalarFieldEnum = (typeof JewelStockScalarFieldEnum)[keyof typeof JewelStockScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    logId: 'logId',
    gold: 'gold',
    amount: 'amount',
    goldRate: 'goldRate',
    purity: 'purity',
    touch: 'touch',
    customerId: 'customerId',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const EntryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    cashAmount: 'cashAmount',
    goldValue: 'goldValue',
    touch: 'touch',
    purity: 'purity',
    goldRate: 'goldRate',
    createdAt: 'createdAt'
  };

  export type EntryScalarFieldEnum = (typeof EntryScalarFieldEnum)[keyof typeof EntryScalarFieldEnum]


  export const Customer_orderScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    order_group_id: 'order_group_id',
    item_name: 'item_name',
    description: 'description',
    weight: 'weight',
    image: 'image',
    due_date: 'due_date',
    status: 'status',
    worker_name: 'worker_name',
    created_at: 'created_at',
    updatedAt: 'updatedAt'
  };

  export type Customer_orderScalarFieldEnum = (typeof Customer_orderScalarFieldEnum)[keyof typeof Customer_orderScalarFieldEnum]


  export const Product_multiple_imagesScalarFieldEnum: {
    id: 'id',
    customer_order_id: 'customer_order_id',
    filename: 'filename'
  };

  export type Product_multiple_imagesScalarFieldEnum = (typeof Product_multiple_imagesScalarFieldEnum)[keyof typeof Product_multiple_imagesScalarFieldEnum]


  export const MasterBullionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type MasterBullionScalarFieldEnum = (typeof MasterBullionScalarFieldEnum)[keyof typeof MasterBullionScalarFieldEnum]


  export const BullionPurchaseScalarFieldEnum: {
    id: 'id',
    bullionId: 'bullionId',
    grams: 'grams',
    touch: 'touch',
    purity: 'purity',
    rate: 'rate',
    amount: 'amount',
    balance: 'balance',
    createdAt: 'createdAt'
  };

  export type BullionPurchaseScalarFieldEnum = (typeof BullionPurchaseScalarFieldEnum)[keyof typeof BullionPurchaseScalarFieldEnum]


  export const GivenDetailScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    grams: 'grams',
    touch: 'touch',
    purity: 'purity',
    purchaseId: 'purchaseId'
  };

  export type GivenDetailScalarFieldEnum = (typeof GivenDetailScalarFieldEnum)[keyof typeof GivenDetailScalarFieldEnum]


  export const GoldsmithScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoldsmithScalarFieldEnum = (typeof GoldsmithScalarFieldEnum)[keyof typeof GoldsmithScalarFieldEnum]


  export const JobcardScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    description: 'description',
    stockIsMove: 'stockIsMove',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobcardScalarFieldEnum = (typeof JobcardScalarFieldEnum)[keyof typeof JobcardScalarFieldEnum]


  export const GivenGoldScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    jobcardId: 'jobcardId',
    logId: 'logId',
    weight: 'weight',
    touch: 'touch',
    purity: 'purity',
    finaltouch: 'finaltouch',
    finalPurity: 'finalPurity',
    copperPurity: 'copperPurity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GivenGoldScalarFieldEnum = (typeof GivenGoldScalarFieldEnum)[keyof typeof GivenGoldScalarFieldEnum]


  export const ItemDeliveryScalarFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    itemWeight: 'itemWeight',
    count: 'count',
    touch: 'touch',
    sealName: 'sealName',
    netWeight: 'netWeight',
    wastageType: 'wastageType',
    wastageValue: 'wastageValue',
    wastagePure: 'wastagePure',
    finalPurity: 'finalPurity',
    goldsmithId: 'goldsmithId',
    jobcardId: 'jobcardId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemDeliveryScalarFieldEnum = (typeof ItemDeliveryScalarFieldEnum)[keyof typeof ItemDeliveryScalarFieldEnum]


  export const DeductionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    deliveryId: 'deliveryId',
    weight: 'weight',
    stoneWt: 'stoneWt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeductionScalarFieldEnum = (typeof DeductionScalarFieldEnum)[keyof typeof DeductionScalarFieldEnum]


  export const TotalScalarFieldEnum: {
    id: 'id',
    jobcardId: 'jobcardId',
    goldsmithId: 'goldsmithId',
    givenTotal: 'givenTotal',
    deliveryTotal: 'deliveryTotal',
    stoneTotalWt: 'stoneTotalWt',
    openingBalance: 'openingBalance',
    jobCardBalance: 'jobCardBalance',
    receivedTotal: 'receivedTotal',
    isFinished: 'isFinished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TotalScalarFieldEnum = (typeof TotalScalarFieldEnum)[keyof typeof TotalScalarFieldEnum]


  export const ReceivedsectionScalarFieldEnum: {
    id: 'id',
    weight: 'weight',
    touch: 'touch',
    purity: 'purity',
    logId: 'logId',
    jobcardId: 'jobcardId',
    goldsmithId: 'goldsmithId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceivedsectionScalarFieldEnum = (typeof ReceivedsectionScalarFieldEnum)[keyof typeof ReceivedsectionScalarFieldEnum]


  export const RawgoldStockScalarFieldEnum: {
    id: 'id',
    touchId: 'touchId',
    touch: 'touch',
    weight: 'weight',
    remainingWt: 'remainingWt'
  };

  export type RawgoldStockScalarFieldEnum = (typeof RawgoldStockScalarFieldEnum)[keyof typeof RawgoldStockScalarFieldEnum]


  export const RawGoldLogsScalarFieldEnum: {
    id: 'id',
    rawGoldStockId: 'rawGoldStockId',
    weight: 'weight',
    touch: 'touch',
    purity: 'purity'
  };

  export type RawGoldLogsScalarFieldEnum = (typeof RawGoldLogsScalarFieldEnum)[keyof typeof RawGoldLogsScalarFieldEnum]


  export const ExpenseTrackerScalarFieldEnum: {
    id: 'id',
    logId: 'logId',
    gold: 'gold',
    touch: 'touch',
    purity: 'purity',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseTrackerScalarFieldEnum = (typeof ExpenseTrackerScalarFieldEnum)[keyof typeof ExpenseTrackerScalarFieldEnum]


  export const BalancesScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    totalDeliveries: 'totalDeliveries',
    totalItemWeight: 'totalItemWeight',
    totalNetWeight: 'totalNetWeight',
    totalPurity: 'totalPurity',
    totalReceivedWeight: 'totalReceivedWeight',
    totalReceivedTouch: 'totalReceivedTouch',
    totalReceivedPurity: 'totalReceivedPurity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BalancesScalarFieldEnum = (typeof BalancesScalarFieldEnum)[keyof typeof BalancesScalarFieldEnum]


  export const RepairScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    givenWeights: 'givenWeights',
    totalGiven: 'totalGiven',
    itemWeights: 'itemWeights',
    totalItem: 'totalItem',
    stone: 'stone',
    wastageType: 'wastageType',
    touch: 'touch',
    netWeight: 'netWeight',
    createdAt: 'createdAt'
  };

  export type RepairScalarFieldEnum = (typeof RepairScalarFieldEnum)[keyof typeof RepairScalarFieldEnum]


  export const ProductStockScalarFieldEnum: {
    id: 'id',
    jobcardId: 'jobcardId',
    itemName: 'itemName',
    itemWeight: 'itemWeight',
    count: 'count',
    touch: 'touch',
    stoneWeight: 'stoneWeight',
    wastageValue: 'wastageValue',
    netWeight: 'netWeight',
    wastagePure: 'wastagePure',
    finalWeight: 'finalWeight',
    createdAt: 'createdAt'
  };

  export type ProductStockScalarFieldEnum = (typeof ProductStockScalarFieldEnum)[keyof typeof ProductStockScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    customer_id: 'customer_id',
    billAmount: 'billAmount',
    hallMark: 'hallMark',
    prevHallMark: 'prevHallMark',
    PrevBalance: 'PrevBalance',
    billDetailsprofit: 'billDetailsprofit',
    Stoneprofit: 'Stoneprofit',
    Totalprofit: 'Totalprofit',
    cashBalance: 'cashBalance',
    createdAt: 'createdAt'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const OrderItemsScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    productName: 'productName',
    count: 'count',
    weight: 'weight',
    stoneWeight: 'stoneWeight',
    afterWeight: 'afterWeight',
    percentage: 'percentage',
    finalWeight: 'finalWeight',
    createdAt: 'createdAt'
  };

  export type OrderItemsScalarFieldEnum = (typeof OrderItemsScalarFieldEnum)[keyof typeof OrderItemsScalarFieldEnum]


  export const BillReceivedScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    customer_id: 'customer_id',
    logId: 'logId',
    date: 'date',
    type: 'type',
    goldRate: 'goldRate',
    gold: 'gold',
    touch: 'touch',
    purity: 'purity',
    receiveHallMark: 'receiveHallMark',
    amount: 'amount',
    createdAt: 'createdAt'
  };

  export type BillReceivedScalarFieldEnum = (typeof BillReceivedScalarFieldEnum)[keyof typeof BillReceivedScalarFieldEnum]


  export const ReceiptVoucherScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    logId: 'logId',
    date: 'date',
    type: 'type',
    goldRate: 'goldRate',
    gold: 'gold',
    touch: 'touch',
    purity: 'purity',
    receiveHallMark: 'receiveHallMark',
    amount: 'amount',
    createdAt: 'createdAt'
  };

  export type ReceiptVoucherScalarFieldEnum = (typeof ReceiptVoucherScalarFieldEnum)[keyof typeof ReceiptVoucherScalarFieldEnum]


  export const CustomerBillBalanceScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    hallMarkBal: 'hallMarkBal',
    customer_id: 'customer_id',
    createdAt: 'createdAt'
  };

  export type CustomerBillBalanceScalarFieldEnum = (typeof CustomerBillBalanceScalarFieldEnum)[keyof typeof CustomerBillBalanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const UserOrderByRelevanceFieldEnum: {
    username: 'username',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CustomerOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const MasterItemOrderByRelevanceFieldEnum: {
    itemName: 'itemName'
  };

  export type MasterItemOrderByRelevanceFieldEnum = (typeof MasterItemOrderByRelevanceFieldEnum)[keyof typeof MasterItemOrderByRelevanceFieldEnum]


  export const JewelStockOrderByRelevanceFieldEnum: {
    jewelName: 'jewelName'
  };

  export type JewelStockOrderByRelevanceFieldEnum = (typeof JewelStockOrderByRelevanceFieldEnum)[keyof typeof JewelStockOrderByRelevanceFieldEnum]


  export const TransactionOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type TransactionOrderByRelevanceFieldEnum = (typeof TransactionOrderByRelevanceFieldEnum)[keyof typeof TransactionOrderByRelevanceFieldEnum]


  export const EntryOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type EntryOrderByRelevanceFieldEnum = (typeof EntryOrderByRelevanceFieldEnum)[keyof typeof EntryOrderByRelevanceFieldEnum]


  export const customer_orderOrderByRelevanceFieldEnum: {
    item_name: 'item_name',
    description: 'description',
    image: 'image',
    status: 'status',
    worker_name: 'worker_name'
  };

  export type customer_orderOrderByRelevanceFieldEnum = (typeof customer_orderOrderByRelevanceFieldEnum)[keyof typeof customer_orderOrderByRelevanceFieldEnum]


  export const product_multiple_imagesOrderByRelevanceFieldEnum: {
    filename: 'filename'
  };

  export type product_multiple_imagesOrderByRelevanceFieldEnum = (typeof product_multiple_imagesOrderByRelevanceFieldEnum)[keyof typeof product_multiple_imagesOrderByRelevanceFieldEnum]


  export const MasterBullionOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type MasterBullionOrderByRelevanceFieldEnum = (typeof MasterBullionOrderByRelevanceFieldEnum)[keyof typeof MasterBullionOrderByRelevanceFieldEnum]


  export const GoldsmithOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type GoldsmithOrderByRelevanceFieldEnum = (typeof GoldsmithOrderByRelevanceFieldEnum)[keyof typeof GoldsmithOrderByRelevanceFieldEnum]


  export const JobcardOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type JobcardOrderByRelevanceFieldEnum = (typeof JobcardOrderByRelevanceFieldEnum)[keyof typeof JobcardOrderByRelevanceFieldEnum]


  export const itemDeliveryOrderByRelevanceFieldEnum: {
    itemName: 'itemName',
    sealName: 'sealName',
    wastageType: 'wastageType'
  };

  export type itemDeliveryOrderByRelevanceFieldEnum = (typeof itemDeliveryOrderByRelevanceFieldEnum)[keyof typeof itemDeliveryOrderByRelevanceFieldEnum]


  export const deductionOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type deductionOrderByRelevanceFieldEnum = (typeof deductionOrderByRelevanceFieldEnum)[keyof typeof deductionOrderByRelevanceFieldEnum]


  export const TotalOrderByRelevanceFieldEnum: {
    isFinished: 'isFinished'
  };

  export type TotalOrderByRelevanceFieldEnum = (typeof TotalOrderByRelevanceFieldEnum)[keyof typeof TotalOrderByRelevanceFieldEnum]


  export const ExpenseTrackerOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type ExpenseTrackerOrderByRelevanceFieldEnum = (typeof ExpenseTrackerOrderByRelevanceFieldEnum)[keyof typeof ExpenseTrackerOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RepairOrderByRelevanceFieldEnum: {
    wastageType: 'wastageType'
  };

  export type RepairOrderByRelevanceFieldEnum = (typeof RepairOrderByRelevanceFieldEnum)[keyof typeof RepairOrderByRelevanceFieldEnum]


  export const ProductStockOrderByRelevanceFieldEnum: {
    itemName: 'itemName'
  };

  export type ProductStockOrderByRelevanceFieldEnum = (typeof ProductStockOrderByRelevanceFieldEnum)[keyof typeof ProductStockOrderByRelevanceFieldEnum]


  export const OrderItemsOrderByRelevanceFieldEnum: {
    productName: 'productName'
  };

  export type OrderItemsOrderByRelevanceFieldEnum = (typeof OrderItemsOrderByRelevanceFieldEnum)[keyof typeof OrderItemsOrderByRelevanceFieldEnum]


  export const billReceivedOrderByRelevanceFieldEnum: {
    date: 'date',
    type: 'type'
  };

  export type billReceivedOrderByRelevanceFieldEnum = (typeof billReceivedOrderByRelevanceFieldEnum)[keyof typeof billReceivedOrderByRelevanceFieldEnum]


  export const receiptVoucherOrderByRelevanceFieldEnum: {
    date: 'date',
    type: 'type'
  };

  export type receiptVoucherOrderByRelevanceFieldEnum = (typeof receiptVoucherOrderByRelevanceFieldEnum)[keyof typeof receiptVoucherOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
    customerOrders?: Customer_orderListRelationFilter
    bill?: BillListRelationFilter
    billReceive?: BillReceivedListRelationFilter
    receiptVoucher?: ReceiptVoucherListRelationFilter
    customerBillBalance?: XOR<CustomerBillBalanceNullableScalarRelationFilter, customerBillBalanceWhereInput> | null
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    customerOrders?: customer_orderOrderByRelationAggregateInput
    bill?: BillOrderByRelationAggregateInput
    billReceive?: billReceivedOrderByRelationAggregateInput
    receiptVoucher?: receiptVoucherOrderByRelationAggregateInput
    customerBillBalance?: customerBillBalanceOrderByWithRelationInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
    customerOrders?: Customer_orderListRelationFilter
    bill?: BillListRelationFilter
    billReceive?: BillReceivedListRelationFilter
    receiptVoucher?: ReceiptVoucherListRelationFilter
    customerBillBalance?: XOR<CustomerBillBalanceNullableScalarRelationFilter, customerBillBalanceWhereInput> | null
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type MasterItemWhereInput = {
    AND?: MasterItemWhereInput | MasterItemWhereInput[]
    OR?: MasterItemWhereInput[]
    NOT?: MasterItemWhereInput | MasterItemWhereInput[]
    id?: IntFilter<"MasterItem"> | number
    itemName?: StringFilter<"MasterItem"> | string
    createdAt?: DateTimeFilter<"MasterItem"> | Date | string
  }

  export type MasterItemOrderByWithRelationInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
    _relevance?: MasterItemOrderByRelevanceInput
  }

  export type MasterItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MasterItemWhereInput | MasterItemWhereInput[]
    OR?: MasterItemWhereInput[]
    NOT?: MasterItemWhereInput | MasterItemWhereInput[]
    itemName?: StringFilter<"MasterItem"> | string
    createdAt?: DateTimeFilter<"MasterItem"> | Date | string
  }, "id">

  export type MasterItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
    _count?: MasterItemCountOrderByAggregateInput
    _avg?: MasterItemAvgOrderByAggregateInput
    _max?: MasterItemMaxOrderByAggregateInput
    _min?: MasterItemMinOrderByAggregateInput
    _sum?: MasterItemSumOrderByAggregateInput
  }

  export type MasterItemScalarWhereWithAggregatesInput = {
    AND?: MasterItemScalarWhereWithAggregatesInput | MasterItemScalarWhereWithAggregatesInput[]
    OR?: MasterItemScalarWhereWithAggregatesInput[]
    NOT?: MasterItemScalarWhereWithAggregatesInput | MasterItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterItem"> | number
    itemName?: StringWithAggregatesFilter<"MasterItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MasterItem"> | Date | string
  }

  export type MasterTouchWhereInput = {
    AND?: MasterTouchWhereInput | MasterTouchWhereInput[]
    OR?: MasterTouchWhereInput[]
    NOT?: MasterTouchWhereInput | MasterTouchWhereInput[]
    id?: IntFilter<"MasterTouch"> | number
    touch?: FloatFilter<"MasterTouch"> | number
    createdAt?: DateTimeFilter<"MasterTouch"> | Date | string
    rawGoldStock?: RawgoldStockListRelationFilter
  }

  export type MasterTouchOrderByWithRelationInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
    rawGoldStock?: RawgoldStockOrderByRelationAggregateInput
  }

  export type MasterTouchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MasterTouchWhereInput | MasterTouchWhereInput[]
    OR?: MasterTouchWhereInput[]
    NOT?: MasterTouchWhereInput | MasterTouchWhereInput[]
    touch?: FloatFilter<"MasterTouch"> | number
    createdAt?: DateTimeFilter<"MasterTouch"> | Date | string
    rawGoldStock?: RawgoldStockListRelationFilter
  }, "id">

  export type MasterTouchOrderByWithAggregationInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
    _count?: MasterTouchCountOrderByAggregateInput
    _avg?: MasterTouchAvgOrderByAggregateInput
    _max?: MasterTouchMaxOrderByAggregateInput
    _min?: MasterTouchMinOrderByAggregateInput
    _sum?: MasterTouchSumOrderByAggregateInput
  }

  export type MasterTouchScalarWhereWithAggregatesInput = {
    AND?: MasterTouchScalarWhereWithAggregatesInput | MasterTouchScalarWhereWithAggregatesInput[]
    OR?: MasterTouchScalarWhereWithAggregatesInput[]
    NOT?: MasterTouchScalarWhereWithAggregatesInput | MasterTouchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterTouch"> | number
    touch?: FloatWithAggregatesFilter<"MasterTouch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MasterTouch"> | Date | string
  }

  export type masterWastageWhereInput = {
    AND?: masterWastageWhereInput | masterWastageWhereInput[]
    OR?: masterWastageWhereInput[]
    NOT?: masterWastageWhereInput | masterWastageWhereInput[]
    id?: IntFilter<"masterWastage"> | number
    wastage?: FloatFilter<"masterWastage"> | number
    createdAt?: DateTimeFilter<"masterWastage"> | Date | string
  }

  export type masterWastageOrderByWithRelationInput = {
    id?: SortOrder
    wastage?: SortOrder
    createdAt?: SortOrder
  }

  export type masterWastageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: masterWastageWhereInput | masterWastageWhereInput[]
    OR?: masterWastageWhereInput[]
    NOT?: masterWastageWhereInput | masterWastageWhereInput[]
    wastage?: FloatFilter<"masterWastage"> | number
    createdAt?: DateTimeFilter<"masterWastage"> | Date | string
  }, "id">

  export type masterWastageOrderByWithAggregationInput = {
    id?: SortOrder
    wastage?: SortOrder
    createdAt?: SortOrder
    _count?: masterWastageCountOrderByAggregateInput
    _avg?: masterWastageAvgOrderByAggregateInput
    _max?: masterWastageMaxOrderByAggregateInput
    _min?: masterWastageMinOrderByAggregateInput
    _sum?: masterWastageSumOrderByAggregateInput
  }

  export type masterWastageScalarWhereWithAggregatesInput = {
    AND?: masterWastageScalarWhereWithAggregatesInput | masterWastageScalarWhereWithAggregatesInput[]
    OR?: masterWastageScalarWhereWithAggregatesInput[]
    NOT?: masterWastageScalarWhereWithAggregatesInput | masterWastageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"masterWastage"> | number
    wastage?: FloatWithAggregatesFilter<"masterWastage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"masterWastage"> | Date | string
  }

  export type mastercopperWhereInput = {
    AND?: mastercopperWhereInput | mastercopperWhereInput[]
    OR?: mastercopperWhereInput[]
    NOT?: mastercopperWhereInput | mastercopperWhereInput[]
    id?: IntFilter<"mastercopper"> | number
    copperTotal?: FloatFilter<"mastercopper"> | number
    remainCopper?: FloatFilter<"mastercopper"> | number
    createdAt?: DateTimeFilter<"mastercopper"> | Date | string
    updatedAt?: DateTimeFilter<"mastercopper"> | Date | string
  }

  export type mastercopperOrderByWithRelationInput = {
    id?: SortOrder
    copperTotal?: SortOrder
    remainCopper?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mastercopperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: mastercopperWhereInput | mastercopperWhereInput[]
    OR?: mastercopperWhereInput[]
    NOT?: mastercopperWhereInput | mastercopperWhereInput[]
    copperTotal?: FloatFilter<"mastercopper"> | number
    remainCopper?: FloatFilter<"mastercopper"> | number
    createdAt?: DateTimeFilter<"mastercopper"> | Date | string
    updatedAt?: DateTimeFilter<"mastercopper"> | Date | string
  }, "id">

  export type mastercopperOrderByWithAggregationInput = {
    id?: SortOrder
    copperTotal?: SortOrder
    remainCopper?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: mastercopperCountOrderByAggregateInput
    _avg?: mastercopperAvgOrderByAggregateInput
    _max?: mastercopperMaxOrderByAggregateInput
    _min?: mastercopperMinOrderByAggregateInput
    _sum?: mastercopperSumOrderByAggregateInput
  }

  export type mastercopperScalarWhereWithAggregatesInput = {
    AND?: mastercopperScalarWhereWithAggregatesInput | mastercopperScalarWhereWithAggregatesInput[]
    OR?: mastercopperScalarWhereWithAggregatesInput[]
    NOT?: mastercopperScalarWhereWithAggregatesInput | mastercopperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"mastercopper"> | number
    copperTotal?: FloatWithAggregatesFilter<"mastercopper"> | number
    remainCopper?: FloatWithAggregatesFilter<"mastercopper"> | number
    createdAt?: DateTimeWithAggregatesFilter<"mastercopper"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"mastercopper"> | Date | string
  }

  export type JewelStockWhereInput = {
    AND?: JewelStockWhereInput | JewelStockWhereInput[]
    OR?: JewelStockWhereInput[]
    NOT?: JewelStockWhereInput | JewelStockWhereInput[]
    id?: IntFilter<"JewelStock"> | number
    jewelName?: StringFilter<"JewelStock"> | string
    weight?: FloatFilter<"JewelStock"> | number
    stoneWeight?: FloatFilter<"JewelStock"> | number
    finalWeight?: FloatFilter<"JewelStock"> | number
    touch?: FloatFilter<"JewelStock"> | number
    purityValue?: FloatFilter<"JewelStock"> | number
    createdAt?: DateTimeFilter<"JewelStock"> | Date | string
  }

  export type JewelStockOrderByWithRelationInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
    _relevance?: JewelStockOrderByRelevanceInput
  }

  export type JewelStockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JewelStockWhereInput | JewelStockWhereInput[]
    OR?: JewelStockWhereInput[]
    NOT?: JewelStockWhereInput | JewelStockWhereInput[]
    jewelName?: StringFilter<"JewelStock"> | string
    weight?: FloatFilter<"JewelStock"> | number
    stoneWeight?: FloatFilter<"JewelStock"> | number
    finalWeight?: FloatFilter<"JewelStock"> | number
    touch?: FloatFilter<"JewelStock"> | number
    purityValue?: FloatFilter<"JewelStock"> | number
    createdAt?: DateTimeFilter<"JewelStock"> | Date | string
  }, "id">

  export type JewelStockOrderByWithAggregationInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
    _count?: JewelStockCountOrderByAggregateInput
    _avg?: JewelStockAvgOrderByAggregateInput
    _max?: JewelStockMaxOrderByAggregateInput
    _min?: JewelStockMinOrderByAggregateInput
    _sum?: JewelStockSumOrderByAggregateInput
  }

  export type JewelStockScalarWhereWithAggregatesInput = {
    AND?: JewelStockScalarWhereWithAggregatesInput | JewelStockScalarWhereWithAggregatesInput[]
    OR?: JewelStockScalarWhereWithAggregatesInput[]
    NOT?: JewelStockScalarWhereWithAggregatesInput | JewelStockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JewelStock"> | number
    jewelName?: StringWithAggregatesFilter<"JewelStock"> | string
    weight?: FloatWithAggregatesFilter<"JewelStock"> | number
    stoneWeight?: FloatWithAggregatesFilter<"JewelStock"> | number
    finalWeight?: FloatWithAggregatesFilter<"JewelStock"> | number
    touch?: FloatWithAggregatesFilter<"JewelStock"> | number
    purityValue?: FloatWithAggregatesFilter<"JewelStock"> | number
    createdAt?: DateTimeWithAggregatesFilter<"JewelStock"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    logId?: IntNullableFilter<"Transaction"> | number | null
    gold?: FloatNullableFilter<"Transaction"> | number | null
    amount?: FloatNullableFilter<"Transaction"> | number | null
    goldRate?: FloatNullableFilter<"Transaction"> | number | null
    purity?: FloatNullableFilter<"Transaction"> | number | null
    touch?: FloatNullableFilter<"Transaction"> | number | null
    customerId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    logId?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    rawGoldLogs?: RawGoldLogsOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    _relevance?: TransactionOrderByRelevanceInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    date?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    logId?: IntNullableFilter<"Transaction"> | number | null
    gold?: FloatNullableFilter<"Transaction"> | number | null
    amount?: FloatNullableFilter<"Transaction"> | number | null
    goldRate?: FloatNullableFilter<"Transaction"> | number | null
    purity?: FloatNullableFilter<"Transaction"> | number | null
    touch?: FloatNullableFilter<"Transaction"> | number | null
    customerId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    logId?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    logId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    gold?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    goldRate?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    customerId?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type EntryWhereInput = {
    AND?: EntryWhereInput | EntryWhereInput[]
    OR?: EntryWhereInput[]
    NOT?: EntryWhereInput | EntryWhereInput[]
    id?: IntFilter<"Entry"> | number
    date?: DateTimeFilter<"Entry"> | Date | string
    type?: StringFilter<"Entry"> | string
    cashAmount?: FloatNullableFilter<"Entry"> | number | null
    goldValue?: FloatNullableFilter<"Entry"> | number | null
    touch?: FloatNullableFilter<"Entry"> | number | null
    purity?: FloatNullableFilter<"Entry"> | number | null
    goldRate?: FloatNullableFilter<"Entry"> | number | null
    createdAt?: DateTimeFilter<"Entry"> | Date | string
  }

  export type EntryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrderInput | SortOrder
    goldValue?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: EntryOrderByRelevanceInput
  }

  export type EntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntryWhereInput | EntryWhereInput[]
    OR?: EntryWhereInput[]
    NOT?: EntryWhereInput | EntryWhereInput[]
    date?: DateTimeFilter<"Entry"> | Date | string
    type?: StringFilter<"Entry"> | string
    cashAmount?: FloatNullableFilter<"Entry"> | number | null
    goldValue?: FloatNullableFilter<"Entry"> | number | null
    touch?: FloatNullableFilter<"Entry"> | number | null
    purity?: FloatNullableFilter<"Entry"> | number | null
    goldRate?: FloatNullableFilter<"Entry"> | number | null
    createdAt?: DateTimeFilter<"Entry"> | Date | string
  }, "id">

  export type EntryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrderInput | SortOrder
    goldValue?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EntryCountOrderByAggregateInput
    _avg?: EntryAvgOrderByAggregateInput
    _max?: EntryMaxOrderByAggregateInput
    _min?: EntryMinOrderByAggregateInput
    _sum?: EntrySumOrderByAggregateInput
  }

  export type EntryScalarWhereWithAggregatesInput = {
    AND?: EntryScalarWhereWithAggregatesInput | EntryScalarWhereWithAggregatesInput[]
    OR?: EntryScalarWhereWithAggregatesInput[]
    NOT?: EntryScalarWhereWithAggregatesInput | EntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entry"> | number
    date?: DateTimeWithAggregatesFilter<"Entry"> | Date | string
    type?: StringWithAggregatesFilter<"Entry"> | string
    cashAmount?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    goldValue?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    goldRate?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Entry"> | Date | string
  }

  export type customer_orderWhereInput = {
    AND?: customer_orderWhereInput | customer_orderWhereInput[]
    OR?: customer_orderWhereInput[]
    NOT?: customer_orderWhereInput | customer_orderWhereInput[]
    id?: IntFilter<"customer_order"> | number
    customer_id?: IntFilter<"customer_order"> | number
    order_group_id?: IntFilter<"customer_order"> | number
    item_name?: StringFilter<"customer_order"> | string
    description?: StringFilter<"customer_order"> | string
    weight?: FloatFilter<"customer_order"> | number
    image?: StringNullableFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableFilter<"customer_order"> | Date | string | null
    status?: StringFilter<"customer_order"> | string
    worker_name?: StringNullableFilter<"customer_order"> | string | null
    created_at?: DateTimeFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeFilter<"customer_order"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    productImages?: Product_multiple_imagesListRelationFilter
  }

  export type customer_orderOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    status?: SortOrder
    worker_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
    customers?: CustomerOrderByWithRelationInput
    productImages?: product_multiple_imagesOrderByRelationAggregateInput
    _relevance?: customer_orderOrderByRelevanceInput
  }

  export type customer_orderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customer_orderWhereInput | customer_orderWhereInput[]
    OR?: customer_orderWhereInput[]
    NOT?: customer_orderWhereInput | customer_orderWhereInput[]
    customer_id?: IntFilter<"customer_order"> | number
    order_group_id?: IntFilter<"customer_order"> | number
    item_name?: StringFilter<"customer_order"> | string
    description?: StringFilter<"customer_order"> | string
    weight?: FloatFilter<"customer_order"> | number
    image?: StringNullableFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableFilter<"customer_order"> | Date | string | null
    status?: StringFilter<"customer_order"> | string
    worker_name?: StringNullableFilter<"customer_order"> | string | null
    created_at?: DateTimeFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeFilter<"customer_order"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    productImages?: Product_multiple_imagesListRelationFilter
  }, "id">

  export type customer_orderOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    status?: SortOrder
    worker_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
    _count?: customer_orderCountOrderByAggregateInput
    _avg?: customer_orderAvgOrderByAggregateInput
    _max?: customer_orderMaxOrderByAggregateInput
    _min?: customer_orderMinOrderByAggregateInput
    _sum?: customer_orderSumOrderByAggregateInput
  }

  export type customer_orderScalarWhereWithAggregatesInput = {
    AND?: customer_orderScalarWhereWithAggregatesInput | customer_orderScalarWhereWithAggregatesInput[]
    OR?: customer_orderScalarWhereWithAggregatesInput[]
    NOT?: customer_orderScalarWhereWithAggregatesInput | customer_orderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customer_order"> | number
    customer_id?: IntWithAggregatesFilter<"customer_order"> | number
    order_group_id?: IntWithAggregatesFilter<"customer_order"> | number
    item_name?: StringWithAggregatesFilter<"customer_order"> | string
    description?: StringWithAggregatesFilter<"customer_order"> | string
    weight?: FloatWithAggregatesFilter<"customer_order"> | number
    image?: StringNullableWithAggregatesFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableWithAggregatesFilter<"customer_order"> | Date | string | null
    status?: StringWithAggregatesFilter<"customer_order"> | string
    worker_name?: StringNullableWithAggregatesFilter<"customer_order"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customer_order"> | Date | string
  }

  export type product_multiple_imagesWhereInput = {
    AND?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    OR?: product_multiple_imagesWhereInput[]
    NOT?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    id?: IntFilter<"product_multiple_images"> | number
    customer_order_id?: IntFilter<"product_multiple_images"> | number
    filename?: StringFilter<"product_multiple_images"> | string
    customerOrderDetails?: XOR<Customer_orderScalarRelationFilter, customer_orderWhereInput>
  }

  export type product_multiple_imagesOrderByWithRelationInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
    customerOrderDetails?: customer_orderOrderByWithRelationInput
    _relevance?: product_multiple_imagesOrderByRelevanceInput
  }

  export type product_multiple_imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    OR?: product_multiple_imagesWhereInput[]
    NOT?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    customer_order_id?: IntFilter<"product_multiple_images"> | number
    filename?: StringFilter<"product_multiple_images"> | string
    customerOrderDetails?: XOR<Customer_orderScalarRelationFilter, customer_orderWhereInput>
  }, "id">

  export type product_multiple_imagesOrderByWithAggregationInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
    _count?: product_multiple_imagesCountOrderByAggregateInput
    _avg?: product_multiple_imagesAvgOrderByAggregateInput
    _max?: product_multiple_imagesMaxOrderByAggregateInput
    _min?: product_multiple_imagesMinOrderByAggregateInput
    _sum?: product_multiple_imagesSumOrderByAggregateInput
  }

  export type product_multiple_imagesScalarWhereWithAggregatesInput = {
    AND?: product_multiple_imagesScalarWhereWithAggregatesInput | product_multiple_imagesScalarWhereWithAggregatesInput[]
    OR?: product_multiple_imagesScalarWhereWithAggregatesInput[]
    NOT?: product_multiple_imagesScalarWhereWithAggregatesInput | product_multiple_imagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_multiple_images"> | number
    customer_order_id?: IntWithAggregatesFilter<"product_multiple_images"> | number
    filename?: StringWithAggregatesFilter<"product_multiple_images"> | string
  }

  export type MasterBullionWhereInput = {
    AND?: MasterBullionWhereInput | MasterBullionWhereInput[]
    OR?: MasterBullionWhereInput[]
    NOT?: MasterBullionWhereInput | MasterBullionWhereInput[]
    id?: IntFilter<"MasterBullion"> | number
    name?: StringFilter<"MasterBullion"> | string
    phone?: StringNullableFilter<"MasterBullion"> | string | null
    address?: StringNullableFilter<"MasterBullion"> | string | null
    purchases?: BullionPurchaseListRelationFilter
  }

  export type MasterBullionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    purchases?: BullionPurchaseOrderByRelationAggregateInput
    _relevance?: MasterBullionOrderByRelevanceInput
  }

  export type MasterBullionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MasterBullionWhereInput | MasterBullionWhereInput[]
    OR?: MasterBullionWhereInput[]
    NOT?: MasterBullionWhereInput | MasterBullionWhereInput[]
    name?: StringFilter<"MasterBullion"> | string
    phone?: StringNullableFilter<"MasterBullion"> | string | null
    address?: StringNullableFilter<"MasterBullion"> | string | null
    purchases?: BullionPurchaseListRelationFilter
  }, "id">

  export type MasterBullionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: MasterBullionCountOrderByAggregateInput
    _avg?: MasterBullionAvgOrderByAggregateInput
    _max?: MasterBullionMaxOrderByAggregateInput
    _min?: MasterBullionMinOrderByAggregateInput
    _sum?: MasterBullionSumOrderByAggregateInput
  }

  export type MasterBullionScalarWhereWithAggregatesInput = {
    AND?: MasterBullionScalarWhereWithAggregatesInput | MasterBullionScalarWhereWithAggregatesInput[]
    OR?: MasterBullionScalarWhereWithAggregatesInput[]
    NOT?: MasterBullionScalarWhereWithAggregatesInput | MasterBullionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterBullion"> | number
    name?: StringWithAggregatesFilter<"MasterBullion"> | string
    phone?: StringNullableWithAggregatesFilter<"MasterBullion"> | string | null
    address?: StringNullableWithAggregatesFilter<"MasterBullion"> | string | null
  }

  export type BullionPurchaseWhereInput = {
    AND?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    OR?: BullionPurchaseWhereInput[]
    NOT?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    id?: IntFilter<"BullionPurchase"> | number
    bullionId?: IntFilter<"BullionPurchase"> | number
    grams?: FloatFilter<"BullionPurchase"> | number
    touch?: FloatNullableFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableFilter<"BullionPurchase"> | number | null
    rate?: FloatFilter<"BullionPurchase"> | number
    amount?: FloatFilter<"BullionPurchase"> | number
    balance?: FloatFilter<"BullionPurchase"> | number
    createdAt?: DateTimeFilter<"BullionPurchase"> | Date | string
    bullion?: XOR<MasterBullionScalarRelationFilter, MasterBullionWhereInput>
    givenDetails?: GivenDetailListRelationFilter
  }

  export type BullionPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    bullion?: MasterBullionOrderByWithRelationInput
    givenDetails?: GivenDetailOrderByRelationAggregateInput
  }

  export type BullionPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    OR?: BullionPurchaseWhereInput[]
    NOT?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    bullionId?: IntFilter<"BullionPurchase"> | number
    grams?: FloatFilter<"BullionPurchase"> | number
    touch?: FloatNullableFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableFilter<"BullionPurchase"> | number | null
    rate?: FloatFilter<"BullionPurchase"> | number
    amount?: FloatFilter<"BullionPurchase"> | number
    balance?: FloatFilter<"BullionPurchase"> | number
    createdAt?: DateTimeFilter<"BullionPurchase"> | Date | string
    bullion?: XOR<MasterBullionScalarRelationFilter, MasterBullionWhereInput>
    givenDetails?: GivenDetailListRelationFilter
  }, "id">

  export type BullionPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    _count?: BullionPurchaseCountOrderByAggregateInput
    _avg?: BullionPurchaseAvgOrderByAggregateInput
    _max?: BullionPurchaseMaxOrderByAggregateInput
    _min?: BullionPurchaseMinOrderByAggregateInput
    _sum?: BullionPurchaseSumOrderByAggregateInput
  }

  export type BullionPurchaseScalarWhereWithAggregatesInput = {
    AND?: BullionPurchaseScalarWhereWithAggregatesInput | BullionPurchaseScalarWhereWithAggregatesInput[]
    OR?: BullionPurchaseScalarWhereWithAggregatesInput[]
    NOT?: BullionPurchaseScalarWhereWithAggregatesInput | BullionPurchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BullionPurchase"> | number
    bullionId?: IntWithAggregatesFilter<"BullionPurchase"> | number
    grams?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    touch?: FloatNullableWithAggregatesFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"BullionPurchase"> | number | null
    rate?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    amount?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    balance?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BullionPurchase"> | Date | string
  }

  export type GivenDetailWhereInput = {
    AND?: GivenDetailWhereInput | GivenDetailWhereInput[]
    OR?: GivenDetailWhereInput[]
    NOT?: GivenDetailWhereInput | GivenDetailWhereInput[]
    id?: IntFilter<"GivenDetail"> | number
    amount?: FloatFilter<"GivenDetail"> | number
    grams?: FloatFilter<"GivenDetail"> | number
    touch?: FloatNullableFilter<"GivenDetail"> | number | null
    purity?: FloatNullableFilter<"GivenDetail"> | number | null
    purchaseId?: IntFilter<"GivenDetail"> | number
    bullionPurchase?: XOR<BullionPurchaseScalarRelationFilter, BullionPurchaseWhereInput>
  }

  export type GivenDetailOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    purchaseId?: SortOrder
    bullionPurchase?: BullionPurchaseOrderByWithRelationInput
  }

  export type GivenDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GivenDetailWhereInput | GivenDetailWhereInput[]
    OR?: GivenDetailWhereInput[]
    NOT?: GivenDetailWhereInput | GivenDetailWhereInput[]
    amount?: FloatFilter<"GivenDetail"> | number
    grams?: FloatFilter<"GivenDetail"> | number
    touch?: FloatNullableFilter<"GivenDetail"> | number | null
    purity?: FloatNullableFilter<"GivenDetail"> | number | null
    purchaseId?: IntFilter<"GivenDetail"> | number
    bullionPurchase?: XOR<BullionPurchaseScalarRelationFilter, BullionPurchaseWhereInput>
  }, "id">

  export type GivenDetailOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    purchaseId?: SortOrder
    _count?: GivenDetailCountOrderByAggregateInput
    _avg?: GivenDetailAvgOrderByAggregateInput
    _max?: GivenDetailMaxOrderByAggregateInput
    _min?: GivenDetailMinOrderByAggregateInput
    _sum?: GivenDetailSumOrderByAggregateInput
  }

  export type GivenDetailScalarWhereWithAggregatesInput = {
    AND?: GivenDetailScalarWhereWithAggregatesInput | GivenDetailScalarWhereWithAggregatesInput[]
    OR?: GivenDetailScalarWhereWithAggregatesInput[]
    NOT?: GivenDetailScalarWhereWithAggregatesInput | GivenDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GivenDetail"> | number
    amount?: FloatWithAggregatesFilter<"GivenDetail"> | number
    grams?: FloatWithAggregatesFilter<"GivenDetail"> | number
    touch?: FloatNullableWithAggregatesFilter<"GivenDetail"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"GivenDetail"> | number | null
    purchaseId?: IntWithAggregatesFilter<"GivenDetail"> | number
  }

  export type GoldsmithWhereInput = {
    AND?: GoldsmithWhereInput | GoldsmithWhereInput[]
    OR?: GoldsmithWhereInput[]
    NOT?: GoldsmithWhereInput | GoldsmithWhereInput[]
    id?: IntFilter<"Goldsmith"> | number
    name?: StringFilter<"Goldsmith"> | string
    phone?: StringNullableFilter<"Goldsmith"> | string | null
    address?: StringNullableFilter<"Goldsmith"> | string | null
    createdAt?: DateTimeFilter<"Goldsmith"> | Date | string
    updatedAt?: DateTimeFilter<"Goldsmith"> | Date | string
    jobcards?: JobcardListRelationFilter
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
    totals?: TotalListRelationFilter
    repairs?: RepairListRelationFilter
    summaries?: BalancesListRelationFilter
  }

  export type GoldsmithOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobcards?: JobcardOrderByRelationAggregateInput
    givenGold?: givenGoldOrderByRelationAggregateInput
    deliveries?: itemDeliveryOrderByRelationAggregateInput
    received?: ReceivedsectionOrderByRelationAggregateInput
    totals?: TotalOrderByRelationAggregateInput
    repairs?: RepairOrderByRelationAggregateInput
    summaries?: BalancesOrderByRelationAggregateInput
    _relevance?: GoldsmithOrderByRelevanceInput
  }

  export type GoldsmithWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GoldsmithWhereInput | GoldsmithWhereInput[]
    OR?: GoldsmithWhereInput[]
    NOT?: GoldsmithWhereInput | GoldsmithWhereInput[]
    name?: StringFilter<"Goldsmith"> | string
    phone?: StringNullableFilter<"Goldsmith"> | string | null
    address?: StringNullableFilter<"Goldsmith"> | string | null
    createdAt?: DateTimeFilter<"Goldsmith"> | Date | string
    updatedAt?: DateTimeFilter<"Goldsmith"> | Date | string
    jobcards?: JobcardListRelationFilter
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
    totals?: TotalListRelationFilter
    repairs?: RepairListRelationFilter
    summaries?: BalancesListRelationFilter
  }, "id">

  export type GoldsmithOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoldsmithCountOrderByAggregateInput
    _avg?: GoldsmithAvgOrderByAggregateInput
    _max?: GoldsmithMaxOrderByAggregateInput
    _min?: GoldsmithMinOrderByAggregateInput
    _sum?: GoldsmithSumOrderByAggregateInput
  }

  export type GoldsmithScalarWhereWithAggregatesInput = {
    AND?: GoldsmithScalarWhereWithAggregatesInput | GoldsmithScalarWhereWithAggregatesInput[]
    OR?: GoldsmithScalarWhereWithAggregatesInput[]
    NOT?: GoldsmithScalarWhereWithAggregatesInput | GoldsmithScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Goldsmith"> | number
    name?: StringWithAggregatesFilter<"Goldsmith"> | string
    phone?: StringNullableWithAggregatesFilter<"Goldsmith"> | string | null
    address?: StringNullableWithAggregatesFilter<"Goldsmith"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Goldsmith"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goldsmith"> | Date | string
  }

  export type JobcardWhereInput = {
    AND?: JobcardWhereInput | JobcardWhereInput[]
    OR?: JobcardWhereInput[]
    NOT?: JobcardWhereInput | JobcardWhereInput[]
    id?: IntFilter<"Jobcard"> | number
    goldsmithId?: IntFilter<"Jobcard"> | number
    description?: StringNullableFilter<"Jobcard"> | string | null
    stockIsMove?: BoolNullableFilter<"Jobcard"> | boolean | null
    createdAt?: DateTimeFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeFilter<"Jobcard"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
    productStock?: ProductStockListRelationFilter
    total?: TotalListRelationFilter
  }

  export type JobcardOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrderInput | SortOrder
    stockIsMove?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    givenGold?: givenGoldOrderByRelationAggregateInput
    deliveries?: itemDeliveryOrderByRelationAggregateInput
    received?: ReceivedsectionOrderByRelationAggregateInput
    productStock?: ProductStockOrderByRelationAggregateInput
    total?: TotalOrderByRelationAggregateInput
    _relevance?: JobcardOrderByRelevanceInput
  }

  export type JobcardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobcardWhereInput | JobcardWhereInput[]
    OR?: JobcardWhereInput[]
    NOT?: JobcardWhereInput | JobcardWhereInput[]
    goldsmithId?: IntFilter<"Jobcard"> | number
    description?: StringNullableFilter<"Jobcard"> | string | null
    stockIsMove?: BoolNullableFilter<"Jobcard"> | boolean | null
    createdAt?: DateTimeFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeFilter<"Jobcard"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
    productStock?: ProductStockListRelationFilter
    total?: TotalListRelationFilter
  }, "id">

  export type JobcardOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrderInput | SortOrder
    stockIsMove?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobcardCountOrderByAggregateInput
    _avg?: JobcardAvgOrderByAggregateInput
    _max?: JobcardMaxOrderByAggregateInput
    _min?: JobcardMinOrderByAggregateInput
    _sum?: JobcardSumOrderByAggregateInput
  }

  export type JobcardScalarWhereWithAggregatesInput = {
    AND?: JobcardScalarWhereWithAggregatesInput | JobcardScalarWhereWithAggregatesInput[]
    OR?: JobcardScalarWhereWithAggregatesInput[]
    NOT?: JobcardScalarWhereWithAggregatesInput | JobcardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Jobcard"> | number
    goldsmithId?: IntWithAggregatesFilter<"Jobcard"> | number
    description?: StringNullableWithAggregatesFilter<"Jobcard"> | string | null
    stockIsMove?: BoolNullableWithAggregatesFilter<"Jobcard"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Jobcard"> | Date | string
  }

  export type givenGoldWhereInput = {
    AND?: givenGoldWhereInput | givenGoldWhereInput[]
    OR?: givenGoldWhereInput[]
    NOT?: givenGoldWhereInput | givenGoldWhereInput[]
    id?: IntFilter<"givenGold"> | number
    goldsmithId?: IntNullableFilter<"givenGold"> | number | null
    jobcardId?: IntNullableFilter<"givenGold"> | number | null
    logId?: IntNullableFilter<"givenGold"> | number | null
    weight?: FloatNullableFilter<"givenGold"> | number | null
    touch?: FloatNullableFilter<"givenGold"> | number | null
    purity?: FloatNullableFilter<"givenGold"> | number | null
    finaltouch?: FloatNullableFilter<"givenGold"> | number | null
    finalPurity?: FloatNullableFilter<"givenGold"> | number | null
    copperPurity?: FloatNullableFilter<"givenGold"> | number | null
    createdAt?: DateTimeFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeFilter<"givenGold"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }

  export type givenGoldOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    logId?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    finaltouch?: SortOrderInput | SortOrder
    finalPurity?: SortOrderInput | SortOrder
    copperPurity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    jobcard?: JobcardOrderByWithRelationInput
    rawGoldLogs?: RawGoldLogsOrderByWithRelationInput
  }

  export type givenGoldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: givenGoldWhereInput | givenGoldWhereInput[]
    OR?: givenGoldWhereInput[]
    NOT?: givenGoldWhereInput | givenGoldWhereInput[]
    goldsmithId?: IntNullableFilter<"givenGold"> | number | null
    jobcardId?: IntNullableFilter<"givenGold"> | number | null
    logId?: IntNullableFilter<"givenGold"> | number | null
    weight?: FloatNullableFilter<"givenGold"> | number | null
    touch?: FloatNullableFilter<"givenGold"> | number | null
    purity?: FloatNullableFilter<"givenGold"> | number | null
    finaltouch?: FloatNullableFilter<"givenGold"> | number | null
    finalPurity?: FloatNullableFilter<"givenGold"> | number | null
    copperPurity?: FloatNullableFilter<"givenGold"> | number | null
    createdAt?: DateTimeFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeFilter<"givenGold"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }, "id">

  export type givenGoldOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    logId?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    finaltouch?: SortOrderInput | SortOrder
    finalPurity?: SortOrderInput | SortOrder
    copperPurity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: givenGoldCountOrderByAggregateInput
    _avg?: givenGoldAvgOrderByAggregateInput
    _max?: givenGoldMaxOrderByAggregateInput
    _min?: givenGoldMinOrderByAggregateInput
    _sum?: givenGoldSumOrderByAggregateInput
  }

  export type givenGoldScalarWhereWithAggregatesInput = {
    AND?: givenGoldScalarWhereWithAggregatesInput | givenGoldScalarWhereWithAggregatesInput[]
    OR?: givenGoldScalarWhereWithAggregatesInput[]
    NOT?: givenGoldScalarWhereWithAggregatesInput | givenGoldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"givenGold"> | number
    goldsmithId?: IntNullableWithAggregatesFilter<"givenGold"> | number | null
    jobcardId?: IntNullableWithAggregatesFilter<"givenGold"> | number | null
    logId?: IntNullableWithAggregatesFilter<"givenGold"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"givenGold"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"givenGold"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"givenGold"> | number | null
    finaltouch?: FloatNullableWithAggregatesFilter<"givenGold"> | number | null
    finalPurity?: FloatNullableWithAggregatesFilter<"givenGold"> | number | null
    copperPurity?: FloatNullableWithAggregatesFilter<"givenGold"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"givenGold"> | Date | string
  }

  export type itemDeliveryWhereInput = {
    AND?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    OR?: itemDeliveryWhereInput[]
    NOT?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    id?: IntFilter<"itemDelivery"> | number
    itemName?: StringNullableFilter<"itemDelivery"> | string | null
    itemWeight?: FloatNullableFilter<"itemDelivery"> | number | null
    count?: IntNullableFilter<"itemDelivery"> | number | null
    touch?: FloatNullableFilter<"itemDelivery"> | number | null
    sealName?: StringNullableFilter<"itemDelivery"> | string | null
    netWeight?: FloatNullableFilter<"itemDelivery"> | number | null
    wastageType?: StringNullableFilter<"itemDelivery"> | string | null
    wastageValue?: FloatNullableFilter<"itemDelivery"> | number | null
    wastagePure?: FloatNullableFilter<"itemDelivery"> | number | null
    finalPurity?: FloatNullableFilter<"itemDelivery"> | number | null
    goldsmithId?: IntNullableFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"itemDelivery"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    deduction?: DeductionListRelationFilter
  }

  export type itemDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    itemName?: SortOrderInput | SortOrder
    itemWeight?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    sealName?: SortOrderInput | SortOrder
    netWeight?: SortOrderInput | SortOrder
    wastageType?: SortOrderInput | SortOrder
    wastageValue?: SortOrderInput | SortOrder
    wastagePure?: SortOrderInput | SortOrder
    finalPurity?: SortOrderInput | SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    jobcard?: JobcardOrderByWithRelationInput
    deduction?: deductionOrderByRelationAggregateInput
    _relevance?: itemDeliveryOrderByRelevanceInput
  }

  export type itemDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    OR?: itemDeliveryWhereInput[]
    NOT?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    itemName?: StringNullableFilter<"itemDelivery"> | string | null
    itemWeight?: FloatNullableFilter<"itemDelivery"> | number | null
    count?: IntNullableFilter<"itemDelivery"> | number | null
    touch?: FloatNullableFilter<"itemDelivery"> | number | null
    sealName?: StringNullableFilter<"itemDelivery"> | string | null
    netWeight?: FloatNullableFilter<"itemDelivery"> | number | null
    wastageType?: StringNullableFilter<"itemDelivery"> | string | null
    wastageValue?: FloatNullableFilter<"itemDelivery"> | number | null
    wastagePure?: FloatNullableFilter<"itemDelivery"> | number | null
    finalPurity?: FloatNullableFilter<"itemDelivery"> | number | null
    goldsmithId?: IntNullableFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"itemDelivery"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    deduction?: DeductionListRelationFilter
  }, "id">

  export type itemDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    itemName?: SortOrderInput | SortOrder
    itemWeight?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    sealName?: SortOrderInput | SortOrder
    netWeight?: SortOrderInput | SortOrder
    wastageType?: SortOrderInput | SortOrder
    wastageValue?: SortOrderInput | SortOrder
    wastagePure?: SortOrderInput | SortOrder
    finalPurity?: SortOrderInput | SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: itemDeliveryCountOrderByAggregateInput
    _avg?: itemDeliveryAvgOrderByAggregateInput
    _max?: itemDeliveryMaxOrderByAggregateInput
    _min?: itemDeliveryMinOrderByAggregateInput
    _sum?: itemDeliverySumOrderByAggregateInput
  }

  export type itemDeliveryScalarWhereWithAggregatesInput = {
    AND?: itemDeliveryScalarWhereWithAggregatesInput | itemDeliveryScalarWhereWithAggregatesInput[]
    OR?: itemDeliveryScalarWhereWithAggregatesInput[]
    NOT?: itemDeliveryScalarWhereWithAggregatesInput | itemDeliveryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"itemDelivery"> | number
    itemName?: StringNullableWithAggregatesFilter<"itemDelivery"> | string | null
    itemWeight?: FloatNullableWithAggregatesFilter<"itemDelivery"> | number | null
    count?: IntNullableWithAggregatesFilter<"itemDelivery"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"itemDelivery"> | number | null
    sealName?: StringNullableWithAggregatesFilter<"itemDelivery"> | string | null
    netWeight?: FloatNullableWithAggregatesFilter<"itemDelivery"> | number | null
    wastageType?: StringNullableWithAggregatesFilter<"itemDelivery"> | string | null
    wastageValue?: FloatNullableWithAggregatesFilter<"itemDelivery"> | number | null
    wastagePure?: FloatNullableWithAggregatesFilter<"itemDelivery"> | number | null
    finalPurity?: FloatNullableWithAggregatesFilter<"itemDelivery"> | number | null
    goldsmithId?: IntNullableWithAggregatesFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableWithAggregatesFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"itemDelivery"> | Date | string
  }

  export type deductionWhereInput = {
    AND?: deductionWhereInput | deductionWhereInput[]
    OR?: deductionWhereInput[]
    NOT?: deductionWhereInput | deductionWhereInput[]
    id?: IntFilter<"deduction"> | number
    type?: StringNullableFilter<"deduction"> | string | null
    deliveryId?: IntFilter<"deduction"> | number
    weight?: FloatNullableFilter<"deduction"> | number | null
    stoneWt?: FloatNullableFilter<"deduction"> | number | null
    createdAt?: DateTimeFilter<"deduction"> | Date | string
    updatedAt?: DateTimeFilter<"deduction"> | Date | string
    itemDelivery?: XOR<ItemDeliveryScalarRelationFilter, itemDeliveryWhereInput>
  }

  export type deductionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    deliveryId?: SortOrder
    weight?: SortOrderInput | SortOrder
    stoneWt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itemDelivery?: itemDeliveryOrderByWithRelationInput
    _relevance?: deductionOrderByRelevanceInput
  }

  export type deductionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: deductionWhereInput | deductionWhereInput[]
    OR?: deductionWhereInput[]
    NOT?: deductionWhereInput | deductionWhereInput[]
    type?: StringNullableFilter<"deduction"> | string | null
    deliveryId?: IntFilter<"deduction"> | number
    weight?: FloatNullableFilter<"deduction"> | number | null
    stoneWt?: FloatNullableFilter<"deduction"> | number | null
    createdAt?: DateTimeFilter<"deduction"> | Date | string
    updatedAt?: DateTimeFilter<"deduction"> | Date | string
    itemDelivery?: XOR<ItemDeliveryScalarRelationFilter, itemDeliveryWhereInput>
  }, "id">

  export type deductionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    deliveryId?: SortOrder
    weight?: SortOrderInput | SortOrder
    stoneWt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: deductionCountOrderByAggregateInput
    _avg?: deductionAvgOrderByAggregateInput
    _max?: deductionMaxOrderByAggregateInput
    _min?: deductionMinOrderByAggregateInput
    _sum?: deductionSumOrderByAggregateInput
  }

  export type deductionScalarWhereWithAggregatesInput = {
    AND?: deductionScalarWhereWithAggregatesInput | deductionScalarWhereWithAggregatesInput[]
    OR?: deductionScalarWhereWithAggregatesInput[]
    NOT?: deductionScalarWhereWithAggregatesInput | deductionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"deduction"> | number
    type?: StringNullableWithAggregatesFilter<"deduction"> | string | null
    deliveryId?: IntWithAggregatesFilter<"deduction"> | number
    weight?: FloatNullableWithAggregatesFilter<"deduction"> | number | null
    stoneWt?: FloatNullableWithAggregatesFilter<"deduction"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"deduction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"deduction"> | Date | string
  }

  export type TotalWhereInput = {
    AND?: TotalWhereInput | TotalWhereInput[]
    OR?: TotalWhereInput[]
    NOT?: TotalWhereInput | TotalWhereInput[]
    id?: IntFilter<"Total"> | number
    jobcardId?: IntNullableFilter<"Total"> | number | null
    goldsmithId?: IntFilter<"Total"> | number
    givenTotal?: FloatNullableFilter<"Total"> | number | null
    deliveryTotal?: FloatNullableFilter<"Total"> | number | null
    stoneTotalWt?: FloatNullableFilter<"Total"> | number | null
    openingBalance?: FloatNullableFilter<"Total"> | number | null
    jobCardBalance?: FloatNullableFilter<"Total"> | number | null
    receivedTotal?: FloatNullableFilter<"Total"> | number | null
    isFinished?: StringNullableFilter<"Total"> | string | null
    createdAt?: DateTimeFilter<"Total"> | Date | string
    updatedAt?: DateTimeFilter<"Total"> | Date | string
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }

  export type TotalOrderByWithRelationInput = {
    id?: SortOrder
    jobcardId?: SortOrderInput | SortOrder
    goldsmithId?: SortOrder
    givenTotal?: SortOrderInput | SortOrder
    deliveryTotal?: SortOrderInput | SortOrder
    stoneTotalWt?: SortOrderInput | SortOrder
    openingBalance?: SortOrderInput | SortOrder
    jobCardBalance?: SortOrderInput | SortOrder
    receivedTotal?: SortOrderInput | SortOrder
    isFinished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobcard?: JobcardOrderByWithRelationInput
    goldsmith?: GoldsmithOrderByWithRelationInput
    _relevance?: TotalOrderByRelevanceInput
  }

  export type TotalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TotalWhereInput | TotalWhereInput[]
    OR?: TotalWhereInput[]
    NOT?: TotalWhereInput | TotalWhereInput[]
    jobcardId?: IntNullableFilter<"Total"> | number | null
    goldsmithId?: IntFilter<"Total"> | number
    givenTotal?: FloatNullableFilter<"Total"> | number | null
    deliveryTotal?: FloatNullableFilter<"Total"> | number | null
    stoneTotalWt?: FloatNullableFilter<"Total"> | number | null
    openingBalance?: FloatNullableFilter<"Total"> | number | null
    jobCardBalance?: FloatNullableFilter<"Total"> | number | null
    receivedTotal?: FloatNullableFilter<"Total"> | number | null
    isFinished?: StringNullableFilter<"Total"> | string | null
    createdAt?: DateTimeFilter<"Total"> | Date | string
    updatedAt?: DateTimeFilter<"Total"> | Date | string
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }, "id">

  export type TotalOrderByWithAggregationInput = {
    id?: SortOrder
    jobcardId?: SortOrderInput | SortOrder
    goldsmithId?: SortOrder
    givenTotal?: SortOrderInput | SortOrder
    deliveryTotal?: SortOrderInput | SortOrder
    stoneTotalWt?: SortOrderInput | SortOrder
    openingBalance?: SortOrderInput | SortOrder
    jobCardBalance?: SortOrderInput | SortOrder
    receivedTotal?: SortOrderInput | SortOrder
    isFinished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TotalCountOrderByAggregateInput
    _avg?: TotalAvgOrderByAggregateInput
    _max?: TotalMaxOrderByAggregateInput
    _min?: TotalMinOrderByAggregateInput
    _sum?: TotalSumOrderByAggregateInput
  }

  export type TotalScalarWhereWithAggregatesInput = {
    AND?: TotalScalarWhereWithAggregatesInput | TotalScalarWhereWithAggregatesInput[]
    OR?: TotalScalarWhereWithAggregatesInput[]
    NOT?: TotalScalarWhereWithAggregatesInput | TotalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Total"> | number
    jobcardId?: IntNullableWithAggregatesFilter<"Total"> | number | null
    goldsmithId?: IntWithAggregatesFilter<"Total"> | number
    givenTotal?: FloatNullableWithAggregatesFilter<"Total"> | number | null
    deliveryTotal?: FloatNullableWithAggregatesFilter<"Total"> | number | null
    stoneTotalWt?: FloatNullableWithAggregatesFilter<"Total"> | number | null
    openingBalance?: FloatNullableWithAggregatesFilter<"Total"> | number | null
    jobCardBalance?: FloatNullableWithAggregatesFilter<"Total"> | number | null
    receivedTotal?: FloatNullableWithAggregatesFilter<"Total"> | number | null
    isFinished?: StringNullableWithAggregatesFilter<"Total"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Total"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Total"> | Date | string
  }

  export type ReceivedsectionWhereInput = {
    AND?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    OR?: ReceivedsectionWhereInput[]
    NOT?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    id?: IntFilter<"Receivedsection"> | number
    weight?: FloatNullableFilter<"Receivedsection"> | number | null
    touch?: FloatNullableFilter<"Receivedsection"> | number | null
    purity?: FloatNullableFilter<"Receivedsection"> | number | null
    logId?: IntNullableFilter<"Receivedsection"> | number | null
    jobcardId?: IntFilter<"Receivedsection"> | number
    goldsmithId?: IntFilter<"Receivedsection"> | number
    createdAt?: DateTimeFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeFilter<"Receivedsection"> | Date | string
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
  }

  export type ReceivedsectionOrderByWithRelationInput = {
    id?: SortOrder
    weight?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    logId?: SortOrderInput | SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rawGoldLogs?: RawGoldLogsOrderByWithRelationInput
    jobcard?: JobcardOrderByWithRelationInput
    goldsmith?: GoldsmithOrderByWithRelationInput
  }

  export type ReceivedsectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    OR?: ReceivedsectionWhereInput[]
    NOT?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    weight?: FloatNullableFilter<"Receivedsection"> | number | null
    touch?: FloatNullableFilter<"Receivedsection"> | number | null
    purity?: FloatNullableFilter<"Receivedsection"> | number | null
    logId?: IntNullableFilter<"Receivedsection"> | number | null
    jobcardId?: IntFilter<"Receivedsection"> | number
    goldsmithId?: IntFilter<"Receivedsection"> | number
    createdAt?: DateTimeFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeFilter<"Receivedsection"> | Date | string
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
  }, "id">

  export type ReceivedsectionOrderByWithAggregationInput = {
    id?: SortOrder
    weight?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    logId?: SortOrderInput | SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceivedsectionCountOrderByAggregateInput
    _avg?: ReceivedsectionAvgOrderByAggregateInput
    _max?: ReceivedsectionMaxOrderByAggregateInput
    _min?: ReceivedsectionMinOrderByAggregateInput
    _sum?: ReceivedsectionSumOrderByAggregateInput
  }

  export type ReceivedsectionScalarWhereWithAggregatesInput = {
    AND?: ReceivedsectionScalarWhereWithAggregatesInput | ReceivedsectionScalarWhereWithAggregatesInput[]
    OR?: ReceivedsectionScalarWhereWithAggregatesInput[]
    NOT?: ReceivedsectionScalarWhereWithAggregatesInput | ReceivedsectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Receivedsection"> | number
    weight?: FloatNullableWithAggregatesFilter<"Receivedsection"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"Receivedsection"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"Receivedsection"> | number | null
    logId?: IntNullableWithAggregatesFilter<"Receivedsection"> | number | null
    jobcardId?: IntWithAggregatesFilter<"Receivedsection"> | number
    goldsmithId?: IntWithAggregatesFilter<"Receivedsection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Receivedsection"> | Date | string
  }

  export type RawgoldStockWhereInput = {
    AND?: RawgoldStockWhereInput | RawgoldStockWhereInput[]
    OR?: RawgoldStockWhereInput[]
    NOT?: RawgoldStockWhereInput | RawgoldStockWhereInput[]
    id?: IntFilter<"RawgoldStock"> | number
    touchId?: IntFilter<"RawgoldStock"> | number
    touch?: FloatNullableFilter<"RawgoldStock"> | number | null
    weight?: FloatNullableFilter<"RawgoldStock"> | number | null
    remainingWt?: FloatNullableFilter<"RawgoldStock"> | number | null
    masterTouch?: XOR<MasterTouchNullableScalarRelationFilter, MasterTouchWhereInput> | null
    rawGoldLogs?: RawGoldLogsListRelationFilter
  }

  export type RawgoldStockOrderByWithRelationInput = {
    id?: SortOrder
    touchId?: SortOrder
    touch?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    remainingWt?: SortOrderInput | SortOrder
    masterTouch?: MasterTouchOrderByWithRelationInput
    rawGoldLogs?: RawGoldLogsOrderByRelationAggregateInput
  }

  export type RawgoldStockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RawgoldStockWhereInput | RawgoldStockWhereInput[]
    OR?: RawgoldStockWhereInput[]
    NOT?: RawgoldStockWhereInput | RawgoldStockWhereInput[]
    touchId?: IntFilter<"RawgoldStock"> | number
    touch?: FloatNullableFilter<"RawgoldStock"> | number | null
    weight?: FloatNullableFilter<"RawgoldStock"> | number | null
    remainingWt?: FloatNullableFilter<"RawgoldStock"> | number | null
    masterTouch?: XOR<MasterTouchNullableScalarRelationFilter, MasterTouchWhereInput> | null
    rawGoldLogs?: RawGoldLogsListRelationFilter
  }, "id">

  export type RawgoldStockOrderByWithAggregationInput = {
    id?: SortOrder
    touchId?: SortOrder
    touch?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    remainingWt?: SortOrderInput | SortOrder
    _count?: RawgoldStockCountOrderByAggregateInput
    _avg?: RawgoldStockAvgOrderByAggregateInput
    _max?: RawgoldStockMaxOrderByAggregateInput
    _min?: RawgoldStockMinOrderByAggregateInput
    _sum?: RawgoldStockSumOrderByAggregateInput
  }

  export type RawgoldStockScalarWhereWithAggregatesInput = {
    AND?: RawgoldStockScalarWhereWithAggregatesInput | RawgoldStockScalarWhereWithAggregatesInput[]
    OR?: RawgoldStockScalarWhereWithAggregatesInput[]
    NOT?: RawgoldStockScalarWhereWithAggregatesInput | RawgoldStockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RawgoldStock"> | number
    touchId?: IntWithAggregatesFilter<"RawgoldStock"> | number
    touch?: FloatNullableWithAggregatesFilter<"RawgoldStock"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"RawgoldStock"> | number | null
    remainingWt?: FloatNullableWithAggregatesFilter<"RawgoldStock"> | number | null
  }

  export type RawGoldLogsWhereInput = {
    AND?: RawGoldLogsWhereInput | RawGoldLogsWhereInput[]
    OR?: RawGoldLogsWhereInput[]
    NOT?: RawGoldLogsWhereInput | RawGoldLogsWhereInput[]
    id?: IntFilter<"RawGoldLogs"> | number
    rawGoldStockId?: IntFilter<"RawGoldLogs"> | number
    weight?: FloatNullableFilter<"RawGoldLogs"> | number | null
    touch?: FloatNullableFilter<"RawGoldLogs"> | number | null
    purity?: FloatNullableFilter<"RawGoldLogs"> | number | null
    rawGoldStock?: XOR<RawgoldStockNullableScalarRelationFilter, RawgoldStockWhereInput> | null
    givenGold?: GivenGoldListRelationFilter
    receivedSections?: ReceivedsectionListRelationFilter
    billReceive?: BillReceivedListRelationFilter
    receiptVoucher?: ReceiptVoucherListRelationFilter
    transactions?: TransactionListRelationFilter
    expenseTracker?: ExpenseTrackerListRelationFilter
  }

  export type RawGoldLogsOrderByWithRelationInput = {
    id?: SortOrder
    rawGoldStockId?: SortOrder
    weight?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    rawGoldStock?: RawgoldStockOrderByWithRelationInput
    givenGold?: givenGoldOrderByRelationAggregateInput
    receivedSections?: ReceivedsectionOrderByRelationAggregateInput
    billReceive?: billReceivedOrderByRelationAggregateInput
    receiptVoucher?: receiptVoucherOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    expenseTracker?: ExpenseTrackerOrderByRelationAggregateInput
  }

  export type RawGoldLogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RawGoldLogsWhereInput | RawGoldLogsWhereInput[]
    OR?: RawGoldLogsWhereInput[]
    NOT?: RawGoldLogsWhereInput | RawGoldLogsWhereInput[]
    rawGoldStockId?: IntFilter<"RawGoldLogs"> | number
    weight?: FloatNullableFilter<"RawGoldLogs"> | number | null
    touch?: FloatNullableFilter<"RawGoldLogs"> | number | null
    purity?: FloatNullableFilter<"RawGoldLogs"> | number | null
    rawGoldStock?: XOR<RawgoldStockNullableScalarRelationFilter, RawgoldStockWhereInput> | null
    givenGold?: GivenGoldListRelationFilter
    receivedSections?: ReceivedsectionListRelationFilter
    billReceive?: BillReceivedListRelationFilter
    receiptVoucher?: ReceiptVoucherListRelationFilter
    transactions?: TransactionListRelationFilter
    expenseTracker?: ExpenseTrackerListRelationFilter
  }, "id">

  export type RawGoldLogsOrderByWithAggregationInput = {
    id?: SortOrder
    rawGoldStockId?: SortOrder
    weight?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    _count?: RawGoldLogsCountOrderByAggregateInput
    _avg?: RawGoldLogsAvgOrderByAggregateInput
    _max?: RawGoldLogsMaxOrderByAggregateInput
    _min?: RawGoldLogsMinOrderByAggregateInput
    _sum?: RawGoldLogsSumOrderByAggregateInput
  }

  export type RawGoldLogsScalarWhereWithAggregatesInput = {
    AND?: RawGoldLogsScalarWhereWithAggregatesInput | RawGoldLogsScalarWhereWithAggregatesInput[]
    OR?: RawGoldLogsScalarWhereWithAggregatesInput[]
    NOT?: RawGoldLogsScalarWhereWithAggregatesInput | RawGoldLogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RawGoldLogs"> | number
    rawGoldStockId?: IntWithAggregatesFilter<"RawGoldLogs"> | number
    weight?: FloatNullableWithAggregatesFilter<"RawGoldLogs"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"RawGoldLogs"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"RawGoldLogs"> | number | null
  }

  export type ExpenseTrackerWhereInput = {
    AND?: ExpenseTrackerWhereInput | ExpenseTrackerWhereInput[]
    OR?: ExpenseTrackerWhereInput[]
    NOT?: ExpenseTrackerWhereInput | ExpenseTrackerWhereInput[]
    id?: IntFilter<"ExpenseTracker"> | number
    logId?: IntNullableFilter<"ExpenseTracker"> | number | null
    gold?: FloatNullableFilter<"ExpenseTracker"> | number | null
    touch?: FloatNullableFilter<"ExpenseTracker"> | number | null
    purity?: FloatNullableFilter<"ExpenseTracker"> | number | null
    description?: StringNullableFilter<"ExpenseTracker"> | string | null
    createdAt?: DateTimeFilter<"ExpenseTracker"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseTracker"> | Date | string
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }

  export type ExpenseTrackerOrderByWithRelationInput = {
    id?: SortOrder
    logId?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rawGoldLogs?: RawGoldLogsOrderByWithRelationInput
    _relevance?: ExpenseTrackerOrderByRelevanceInput
  }

  export type ExpenseTrackerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpenseTrackerWhereInput | ExpenseTrackerWhereInput[]
    OR?: ExpenseTrackerWhereInput[]
    NOT?: ExpenseTrackerWhereInput | ExpenseTrackerWhereInput[]
    logId?: IntNullableFilter<"ExpenseTracker"> | number | null
    gold?: FloatNullableFilter<"ExpenseTracker"> | number | null
    touch?: FloatNullableFilter<"ExpenseTracker"> | number | null
    purity?: FloatNullableFilter<"ExpenseTracker"> | number | null
    description?: StringNullableFilter<"ExpenseTracker"> | string | null
    createdAt?: DateTimeFilter<"ExpenseTracker"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseTracker"> | Date | string
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }, "id">

  export type ExpenseTrackerOrderByWithAggregationInput = {
    id?: SortOrder
    logId?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseTrackerCountOrderByAggregateInput
    _avg?: ExpenseTrackerAvgOrderByAggregateInput
    _max?: ExpenseTrackerMaxOrderByAggregateInput
    _min?: ExpenseTrackerMinOrderByAggregateInput
    _sum?: ExpenseTrackerSumOrderByAggregateInput
  }

  export type ExpenseTrackerScalarWhereWithAggregatesInput = {
    AND?: ExpenseTrackerScalarWhereWithAggregatesInput | ExpenseTrackerScalarWhereWithAggregatesInput[]
    OR?: ExpenseTrackerScalarWhereWithAggregatesInput[]
    NOT?: ExpenseTrackerScalarWhereWithAggregatesInput | ExpenseTrackerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseTracker"> | number
    logId?: IntNullableWithAggregatesFilter<"ExpenseTracker"> | number | null
    gold?: FloatNullableWithAggregatesFilter<"ExpenseTracker"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"ExpenseTracker"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"ExpenseTracker"> | number | null
    description?: StringNullableWithAggregatesFilter<"ExpenseTracker"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseTracker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpenseTracker"> | Date | string
  }

  export type BalancesWhereInput = {
    AND?: BalancesWhereInput | BalancesWhereInput[]
    OR?: BalancesWhereInput[]
    NOT?: BalancesWhereInput | BalancesWhereInput[]
    id?: IntFilter<"Balances"> | number
    goldsmithId?: IntFilter<"Balances"> | number
    totalDeliveries?: IntFilter<"Balances"> | number
    totalItemWeight?: FloatFilter<"Balances"> | number
    totalNetWeight?: FloatFilter<"Balances"> | number
    totalPurity?: FloatFilter<"Balances"> | number
    totalReceivedWeight?: FloatFilter<"Balances"> | number
    totalReceivedTouch?: FloatFilter<"Balances"> | number
    totalReceivedPurity?: FloatFilter<"Balances"> | number
    createdAt?: DateTimeFilter<"Balances"> | Date | string
    updatedAt?: DateTimeFilter<"Balances"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }

  export type BalancesOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
  }

  export type BalancesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BalancesWhereInput | BalancesWhereInput[]
    OR?: BalancesWhereInput[]
    NOT?: BalancesWhereInput | BalancesWhereInput[]
    goldsmithId?: IntFilter<"Balances"> | number
    totalDeliveries?: IntFilter<"Balances"> | number
    totalItemWeight?: FloatFilter<"Balances"> | number
    totalNetWeight?: FloatFilter<"Balances"> | number
    totalPurity?: FloatFilter<"Balances"> | number
    totalReceivedWeight?: FloatFilter<"Balances"> | number
    totalReceivedTouch?: FloatFilter<"Balances"> | number
    totalReceivedPurity?: FloatFilter<"Balances"> | number
    createdAt?: DateTimeFilter<"Balances"> | Date | string
    updatedAt?: DateTimeFilter<"Balances"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }, "id">

  export type BalancesOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BalancesCountOrderByAggregateInput
    _avg?: BalancesAvgOrderByAggregateInput
    _max?: BalancesMaxOrderByAggregateInput
    _min?: BalancesMinOrderByAggregateInput
    _sum?: BalancesSumOrderByAggregateInput
  }

  export type BalancesScalarWhereWithAggregatesInput = {
    AND?: BalancesScalarWhereWithAggregatesInput | BalancesScalarWhereWithAggregatesInput[]
    OR?: BalancesScalarWhereWithAggregatesInput[]
    NOT?: BalancesScalarWhereWithAggregatesInput | BalancesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Balances"> | number
    goldsmithId?: IntWithAggregatesFilter<"Balances"> | number
    totalDeliveries?: IntWithAggregatesFilter<"Balances"> | number
    totalItemWeight?: FloatWithAggregatesFilter<"Balances"> | number
    totalNetWeight?: FloatWithAggregatesFilter<"Balances"> | number
    totalPurity?: FloatWithAggregatesFilter<"Balances"> | number
    totalReceivedWeight?: FloatWithAggregatesFilter<"Balances"> | number
    totalReceivedTouch?: FloatWithAggregatesFilter<"Balances"> | number
    totalReceivedPurity?: FloatWithAggregatesFilter<"Balances"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Balances"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Balances"> | Date | string
  }

  export type RepairWhereInput = {
    AND?: RepairWhereInput | RepairWhereInput[]
    OR?: RepairWhereInput[]
    NOT?: RepairWhereInput | RepairWhereInput[]
    id?: IntFilter<"Repair"> | number
    goldsmithId?: IntFilter<"Repair"> | number
    givenWeights?: JsonFilter<"Repair">
    totalGiven?: FloatFilter<"Repair"> | number
    itemWeights?: JsonFilter<"Repair">
    totalItem?: FloatFilter<"Repair"> | number
    stone?: FloatFilter<"Repair"> | number
    wastageType?: StringFilter<"Repair"> | string
    touch?: FloatFilter<"Repair"> | number
    netWeight?: FloatFilter<"Repair"> | number
    createdAt?: DateTimeFilter<"Repair"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }

  export type RepairOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    givenWeights?: SortOrder
    totalGiven?: SortOrder
    itemWeights?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    _relevance?: RepairOrderByRelevanceInput
  }

  export type RepairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RepairWhereInput | RepairWhereInput[]
    OR?: RepairWhereInput[]
    NOT?: RepairWhereInput | RepairWhereInput[]
    goldsmithId?: IntFilter<"Repair"> | number
    givenWeights?: JsonFilter<"Repair">
    totalGiven?: FloatFilter<"Repair"> | number
    itemWeights?: JsonFilter<"Repair">
    totalItem?: FloatFilter<"Repair"> | number
    stone?: FloatFilter<"Repair"> | number
    wastageType?: StringFilter<"Repair"> | string
    touch?: FloatFilter<"Repair"> | number
    netWeight?: FloatFilter<"Repair"> | number
    createdAt?: DateTimeFilter<"Repair"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }, "id">

  export type RepairOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    givenWeights?: SortOrder
    totalGiven?: SortOrder
    itemWeights?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
    _count?: RepairCountOrderByAggregateInput
    _avg?: RepairAvgOrderByAggregateInput
    _max?: RepairMaxOrderByAggregateInput
    _min?: RepairMinOrderByAggregateInput
    _sum?: RepairSumOrderByAggregateInput
  }

  export type RepairScalarWhereWithAggregatesInput = {
    AND?: RepairScalarWhereWithAggregatesInput | RepairScalarWhereWithAggregatesInput[]
    OR?: RepairScalarWhereWithAggregatesInput[]
    NOT?: RepairScalarWhereWithAggregatesInput | RepairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Repair"> | number
    goldsmithId?: IntWithAggregatesFilter<"Repair"> | number
    givenWeights?: JsonWithAggregatesFilter<"Repair">
    totalGiven?: FloatWithAggregatesFilter<"Repair"> | number
    itemWeights?: JsonWithAggregatesFilter<"Repair">
    totalItem?: FloatWithAggregatesFilter<"Repair"> | number
    stone?: FloatWithAggregatesFilter<"Repair"> | number
    wastageType?: StringWithAggregatesFilter<"Repair"> | string
    touch?: FloatWithAggregatesFilter<"Repair"> | number
    netWeight?: FloatWithAggregatesFilter<"Repair"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Repair"> | Date | string
  }

  export type ProductStockWhereInput = {
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    id?: IntFilter<"ProductStock"> | number
    jobcardId?: IntFilter<"ProductStock"> | number
    itemName?: StringFilter<"ProductStock"> | string
    itemWeight?: FloatFilter<"ProductStock"> | number
    count?: IntFilter<"ProductStock"> | number
    touch?: FloatFilter<"ProductStock"> | number
    stoneWeight?: FloatFilter<"ProductStock"> | number
    wastageValue?: FloatFilter<"ProductStock"> | number
    netWeight?: FloatNullableFilter<"ProductStock"> | number | null
    wastagePure?: FloatNullableFilter<"ProductStock"> | number | null
    finalWeight?: FloatFilter<"ProductStock"> | number
    createdAt?: DateTimeFilter<"ProductStock"> | Date | string
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
  }

  export type ProductStockOrderByWithRelationInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    stoneWeight?: SortOrder
    wastageValue?: SortOrder
    netWeight?: SortOrderInput | SortOrder
    wastagePure?: SortOrderInput | SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
    jobcard?: JobcardOrderByWithRelationInput
    _relevance?: ProductStockOrderByRelevanceInput
  }

  export type ProductStockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    jobcardId?: IntFilter<"ProductStock"> | number
    itemName?: StringFilter<"ProductStock"> | string
    itemWeight?: FloatFilter<"ProductStock"> | number
    count?: IntFilter<"ProductStock"> | number
    touch?: FloatFilter<"ProductStock"> | number
    stoneWeight?: FloatFilter<"ProductStock"> | number
    wastageValue?: FloatFilter<"ProductStock"> | number
    netWeight?: FloatNullableFilter<"ProductStock"> | number | null
    wastagePure?: FloatNullableFilter<"ProductStock"> | number | null
    finalWeight?: FloatFilter<"ProductStock"> | number
    createdAt?: DateTimeFilter<"ProductStock"> | Date | string
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
  }, "id">

  export type ProductStockOrderByWithAggregationInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    stoneWeight?: SortOrder
    wastageValue?: SortOrder
    netWeight?: SortOrderInput | SortOrder
    wastagePure?: SortOrderInput | SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
    _count?: ProductStockCountOrderByAggregateInput
    _avg?: ProductStockAvgOrderByAggregateInput
    _max?: ProductStockMaxOrderByAggregateInput
    _min?: ProductStockMinOrderByAggregateInput
    _sum?: ProductStockSumOrderByAggregateInput
  }

  export type ProductStockScalarWhereWithAggregatesInput = {
    AND?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    OR?: ProductStockScalarWhereWithAggregatesInput[]
    NOT?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductStock"> | number
    jobcardId?: IntWithAggregatesFilter<"ProductStock"> | number
    itemName?: StringWithAggregatesFilter<"ProductStock"> | string
    itemWeight?: FloatWithAggregatesFilter<"ProductStock"> | number
    count?: IntWithAggregatesFilter<"ProductStock"> | number
    touch?: FloatWithAggregatesFilter<"ProductStock"> | number
    stoneWeight?: FloatWithAggregatesFilter<"ProductStock"> | number
    wastageValue?: FloatWithAggregatesFilter<"ProductStock"> | number
    netWeight?: FloatNullableWithAggregatesFilter<"ProductStock"> | number | null
    wastagePure?: FloatNullableWithAggregatesFilter<"ProductStock"> | number | null
    finalWeight?: FloatWithAggregatesFilter<"ProductStock"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductStock"> | Date | string
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: IntFilter<"Bill"> | number
    date?: DateTimeNullableFilter<"Bill"> | Date | string | null
    time?: DateTimeNullableFilter<"Bill"> | Date | string | null
    customer_id?: IntFilter<"Bill"> | number
    billAmount?: FloatFilter<"Bill"> | number
    hallMark?: FloatNullableFilter<"Bill"> | number | null
    prevHallMark?: FloatNullableFilter<"Bill"> | number | null
    PrevBalance?: FloatNullableFilter<"Bill"> | number | null
    billDetailsprofit?: FloatNullableFilter<"Bill"> | number | null
    Stoneprofit?: FloatNullableFilter<"Bill"> | number | null
    Totalprofit?: FloatNullableFilter<"Bill"> | number | null
    cashBalance?: FloatNullableFilter<"Bill"> | number | null
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    orders?: OrderItemsListRelationFilter
    billReceive?: BillReceivedListRelationFilter
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    billAmount?: SortOrder
    hallMark?: SortOrderInput | SortOrder
    prevHallMark?: SortOrderInput | SortOrder
    PrevBalance?: SortOrderInput | SortOrder
    billDetailsprofit?: SortOrderInput | SortOrder
    Stoneprofit?: SortOrderInput | SortOrder
    Totalprofit?: SortOrderInput | SortOrder
    cashBalance?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    customers?: CustomerOrderByWithRelationInput
    orders?: OrderItemsOrderByRelationAggregateInput
    billReceive?: billReceivedOrderByRelationAggregateInput
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    date?: DateTimeNullableFilter<"Bill"> | Date | string | null
    time?: DateTimeNullableFilter<"Bill"> | Date | string | null
    customer_id?: IntFilter<"Bill"> | number
    billAmount?: FloatFilter<"Bill"> | number
    hallMark?: FloatNullableFilter<"Bill"> | number | null
    prevHallMark?: FloatNullableFilter<"Bill"> | number | null
    PrevBalance?: FloatNullableFilter<"Bill"> | number | null
    billDetailsprofit?: FloatNullableFilter<"Bill"> | number | null
    Stoneprofit?: FloatNullableFilter<"Bill"> | number | null
    Totalprofit?: FloatNullableFilter<"Bill"> | number | null
    cashBalance?: FloatNullableFilter<"Bill"> | number | null
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    orders?: OrderItemsListRelationFilter
    billReceive?: BillReceivedListRelationFilter
  }, "id">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    billAmount?: SortOrder
    hallMark?: SortOrderInput | SortOrder
    prevHallMark?: SortOrderInput | SortOrder
    PrevBalance?: SortOrderInput | SortOrder
    billDetailsprofit?: SortOrderInput | SortOrder
    Stoneprofit?: SortOrderInput | SortOrder
    Totalprofit?: SortOrderInput | SortOrder
    cashBalance?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bill"> | number
    date?: DateTimeNullableWithAggregatesFilter<"Bill"> | Date | string | null
    time?: DateTimeNullableWithAggregatesFilter<"Bill"> | Date | string | null
    customer_id?: IntWithAggregatesFilter<"Bill"> | number
    billAmount?: FloatWithAggregatesFilter<"Bill"> | number
    hallMark?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    prevHallMark?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    PrevBalance?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    billDetailsprofit?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    Stoneprofit?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    Totalprofit?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    cashBalance?: FloatNullableWithAggregatesFilter<"Bill"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
  }

  export type OrderItemsWhereInput = {
    AND?: OrderItemsWhereInput | OrderItemsWhereInput[]
    OR?: OrderItemsWhereInput[]
    NOT?: OrderItemsWhereInput | OrderItemsWhereInput[]
    id?: IntFilter<"OrderItems"> | number
    billId?: IntFilter<"OrderItems"> | number
    productName?: StringFilter<"OrderItems"> | string
    count?: IntNullableFilter<"OrderItems"> | number | null
    weight?: FloatNullableFilter<"OrderItems"> | number | null
    stoneWeight?: FloatNullableFilter<"OrderItems"> | number | null
    afterWeight?: FloatNullableFilter<"OrderItems"> | number | null
    percentage?: FloatNullableFilter<"OrderItems"> | number | null
    finalWeight?: FloatNullableFilter<"OrderItems"> | number | null
    createdAt?: DateTimeFilter<"OrderItems"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }

  export type OrderItemsOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrder
    productName?: SortOrder
    count?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    stoneWeight?: SortOrderInput | SortOrder
    afterWeight?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    finalWeight?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bill?: BillOrderByWithRelationInput
    _relevance?: OrderItemsOrderByRelevanceInput
  }

  export type OrderItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemsWhereInput | OrderItemsWhereInput[]
    OR?: OrderItemsWhereInput[]
    NOT?: OrderItemsWhereInput | OrderItemsWhereInput[]
    billId?: IntFilter<"OrderItems"> | number
    productName?: StringFilter<"OrderItems"> | string
    count?: IntNullableFilter<"OrderItems"> | number | null
    weight?: FloatNullableFilter<"OrderItems"> | number | null
    stoneWeight?: FloatNullableFilter<"OrderItems"> | number | null
    afterWeight?: FloatNullableFilter<"OrderItems"> | number | null
    percentage?: FloatNullableFilter<"OrderItems"> | number | null
    finalWeight?: FloatNullableFilter<"OrderItems"> | number | null
    createdAt?: DateTimeFilter<"OrderItems"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }, "id">

  export type OrderItemsOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrder
    productName?: SortOrder
    count?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    stoneWeight?: SortOrderInput | SortOrder
    afterWeight?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    finalWeight?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderItemsCountOrderByAggregateInput
    _avg?: OrderItemsAvgOrderByAggregateInput
    _max?: OrderItemsMaxOrderByAggregateInput
    _min?: OrderItemsMinOrderByAggregateInput
    _sum?: OrderItemsSumOrderByAggregateInput
  }

  export type OrderItemsScalarWhereWithAggregatesInput = {
    AND?: OrderItemsScalarWhereWithAggregatesInput | OrderItemsScalarWhereWithAggregatesInput[]
    OR?: OrderItemsScalarWhereWithAggregatesInput[]
    NOT?: OrderItemsScalarWhereWithAggregatesInput | OrderItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItems"> | number
    billId?: IntWithAggregatesFilter<"OrderItems"> | number
    productName?: StringWithAggregatesFilter<"OrderItems"> | string
    count?: IntNullableWithAggregatesFilter<"OrderItems"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"OrderItems"> | number | null
    stoneWeight?: FloatNullableWithAggregatesFilter<"OrderItems"> | number | null
    afterWeight?: FloatNullableWithAggregatesFilter<"OrderItems"> | number | null
    percentage?: FloatNullableWithAggregatesFilter<"OrderItems"> | number | null
    finalWeight?: FloatNullableWithAggregatesFilter<"OrderItems"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItems"> | Date | string
  }

  export type billReceivedWhereInput = {
    AND?: billReceivedWhereInput | billReceivedWhereInput[]
    OR?: billReceivedWhereInput[]
    NOT?: billReceivedWhereInput | billReceivedWhereInput[]
    id?: IntFilter<"billReceived"> | number
    billId?: IntNullableFilter<"billReceived"> | number | null
    customer_id?: IntFilter<"billReceived"> | number
    logId?: IntNullableFilter<"billReceived"> | number | null
    date?: StringNullableFilter<"billReceived"> | string | null
    type?: StringNullableFilter<"billReceived"> | string | null
    goldRate?: IntNullableFilter<"billReceived"> | number | null
    gold?: FloatNullableFilter<"billReceived"> | number | null
    touch?: FloatNullableFilter<"billReceived"> | number | null
    purity?: FloatNullableFilter<"billReceived"> | number | null
    receiveHallMark?: FloatNullableFilter<"billReceived"> | number | null
    amount?: FloatNullableFilter<"billReceived"> | number | null
    createdAt?: DateTimeFilter<"billReceived"> | Date | string
    bill?: XOR<BillNullableScalarRelationFilter, BillWhereInput> | null
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }

  export type billReceivedOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    logId?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    receiveHallMark?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bill?: BillOrderByWithRelationInput
    customers?: CustomerOrderByWithRelationInput
    rawGoldLogs?: RawGoldLogsOrderByWithRelationInput
    _relevance?: billReceivedOrderByRelevanceInput
  }

  export type billReceivedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: billReceivedWhereInput | billReceivedWhereInput[]
    OR?: billReceivedWhereInput[]
    NOT?: billReceivedWhereInput | billReceivedWhereInput[]
    billId?: IntNullableFilter<"billReceived"> | number | null
    customer_id?: IntFilter<"billReceived"> | number
    logId?: IntNullableFilter<"billReceived"> | number | null
    date?: StringNullableFilter<"billReceived"> | string | null
    type?: StringNullableFilter<"billReceived"> | string | null
    goldRate?: IntNullableFilter<"billReceived"> | number | null
    gold?: FloatNullableFilter<"billReceived"> | number | null
    touch?: FloatNullableFilter<"billReceived"> | number | null
    purity?: FloatNullableFilter<"billReceived"> | number | null
    receiveHallMark?: FloatNullableFilter<"billReceived"> | number | null
    amount?: FloatNullableFilter<"billReceived"> | number | null
    createdAt?: DateTimeFilter<"billReceived"> | Date | string
    bill?: XOR<BillNullableScalarRelationFilter, BillWhereInput> | null
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }, "id">

  export type billReceivedOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    logId?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    receiveHallMark?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: billReceivedCountOrderByAggregateInput
    _avg?: billReceivedAvgOrderByAggregateInput
    _max?: billReceivedMaxOrderByAggregateInput
    _min?: billReceivedMinOrderByAggregateInput
    _sum?: billReceivedSumOrderByAggregateInput
  }

  export type billReceivedScalarWhereWithAggregatesInput = {
    AND?: billReceivedScalarWhereWithAggregatesInput | billReceivedScalarWhereWithAggregatesInput[]
    OR?: billReceivedScalarWhereWithAggregatesInput[]
    NOT?: billReceivedScalarWhereWithAggregatesInput | billReceivedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"billReceived"> | number
    billId?: IntNullableWithAggregatesFilter<"billReceived"> | number | null
    customer_id?: IntWithAggregatesFilter<"billReceived"> | number
    logId?: IntNullableWithAggregatesFilter<"billReceived"> | number | null
    date?: StringNullableWithAggregatesFilter<"billReceived"> | string | null
    type?: StringNullableWithAggregatesFilter<"billReceived"> | string | null
    goldRate?: IntNullableWithAggregatesFilter<"billReceived"> | number | null
    gold?: FloatNullableWithAggregatesFilter<"billReceived"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"billReceived"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"billReceived"> | number | null
    receiveHallMark?: FloatNullableWithAggregatesFilter<"billReceived"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"billReceived"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"billReceived"> | Date | string
  }

  export type receiptVoucherWhereInput = {
    AND?: receiptVoucherWhereInput | receiptVoucherWhereInput[]
    OR?: receiptVoucherWhereInput[]
    NOT?: receiptVoucherWhereInput | receiptVoucherWhereInput[]
    id?: IntFilter<"receiptVoucher"> | number
    customer_id?: IntFilter<"receiptVoucher"> | number
    logId?: IntNullableFilter<"receiptVoucher"> | number | null
    date?: StringNullableFilter<"receiptVoucher"> | string | null
    type?: StringNullableFilter<"receiptVoucher"> | string | null
    goldRate?: IntNullableFilter<"receiptVoucher"> | number | null
    gold?: FloatNullableFilter<"receiptVoucher"> | number | null
    touch?: FloatNullableFilter<"receiptVoucher"> | number | null
    purity?: FloatNullableFilter<"receiptVoucher"> | number | null
    receiveHallMark?: FloatNullableFilter<"receiptVoucher"> | number | null
    amount?: FloatNullableFilter<"receiptVoucher"> | number | null
    createdAt?: DateTimeFilter<"receiptVoucher"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }

  export type receiptVoucherOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    receiveHallMark?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    customers?: CustomerOrderByWithRelationInput
    rawGoldLogs?: RawGoldLogsOrderByWithRelationInput
    _relevance?: receiptVoucherOrderByRelevanceInput
  }

  export type receiptVoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: receiptVoucherWhereInput | receiptVoucherWhereInput[]
    OR?: receiptVoucherWhereInput[]
    NOT?: receiptVoucherWhereInput | receiptVoucherWhereInput[]
    customer_id?: IntFilter<"receiptVoucher"> | number
    logId?: IntNullableFilter<"receiptVoucher"> | number | null
    date?: StringNullableFilter<"receiptVoucher"> | string | null
    type?: StringNullableFilter<"receiptVoucher"> | string | null
    goldRate?: IntNullableFilter<"receiptVoucher"> | number | null
    gold?: FloatNullableFilter<"receiptVoucher"> | number | null
    touch?: FloatNullableFilter<"receiptVoucher"> | number | null
    purity?: FloatNullableFilter<"receiptVoucher"> | number | null
    receiveHallMark?: FloatNullableFilter<"receiptVoucher"> | number | null
    amount?: FloatNullableFilter<"receiptVoucher"> | number | null
    createdAt?: DateTimeFilter<"receiptVoucher"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    rawGoldLogs?: XOR<RawGoldLogsNullableScalarRelationFilter, RawGoldLogsWhereInput> | null
  }, "id">

  export type receiptVoucherOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    receiveHallMark?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: receiptVoucherCountOrderByAggregateInput
    _avg?: receiptVoucherAvgOrderByAggregateInput
    _max?: receiptVoucherMaxOrderByAggregateInput
    _min?: receiptVoucherMinOrderByAggregateInput
    _sum?: receiptVoucherSumOrderByAggregateInput
  }

  export type receiptVoucherScalarWhereWithAggregatesInput = {
    AND?: receiptVoucherScalarWhereWithAggregatesInput | receiptVoucherScalarWhereWithAggregatesInput[]
    OR?: receiptVoucherScalarWhereWithAggregatesInput[]
    NOT?: receiptVoucherScalarWhereWithAggregatesInput | receiptVoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"receiptVoucher"> | number
    customer_id?: IntWithAggregatesFilter<"receiptVoucher"> | number
    logId?: IntNullableWithAggregatesFilter<"receiptVoucher"> | number | null
    date?: StringNullableWithAggregatesFilter<"receiptVoucher"> | string | null
    type?: StringNullableWithAggregatesFilter<"receiptVoucher"> | string | null
    goldRate?: IntNullableWithAggregatesFilter<"receiptVoucher"> | number | null
    gold?: FloatNullableWithAggregatesFilter<"receiptVoucher"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"receiptVoucher"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"receiptVoucher"> | number | null
    receiveHallMark?: FloatNullableWithAggregatesFilter<"receiptVoucher"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"receiptVoucher"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"receiptVoucher"> | Date | string
  }

  export type customerBillBalanceWhereInput = {
    AND?: customerBillBalanceWhereInput | customerBillBalanceWhereInput[]
    OR?: customerBillBalanceWhereInput[]
    NOT?: customerBillBalanceWhereInput | customerBillBalanceWhereInput[]
    id?: IntFilter<"customerBillBalance"> | number
    balance?: FloatNullableFilter<"customerBillBalance"> | number | null
    hallMarkBal?: FloatNullableFilter<"customerBillBalance"> | number | null
    customer_id?: IntFilter<"customerBillBalance"> | number
    createdAt?: DateTimeFilter<"customerBillBalance"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type customerBillBalanceOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrderInput | SortOrder
    hallMarkBal?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    customers?: CustomerOrderByWithRelationInput
  }

  export type customerBillBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    customer_id?: number
    AND?: customerBillBalanceWhereInput | customerBillBalanceWhereInput[]
    OR?: customerBillBalanceWhereInput[]
    NOT?: customerBillBalanceWhereInput | customerBillBalanceWhereInput[]
    balance?: FloatNullableFilter<"customerBillBalance"> | number | null
    hallMarkBal?: FloatNullableFilter<"customerBillBalance"> | number | null
    createdAt?: DateTimeFilter<"customerBillBalance"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "customer_id">

  export type customerBillBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrderInput | SortOrder
    hallMarkBal?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    _count?: customerBillBalanceCountOrderByAggregateInput
    _avg?: customerBillBalanceAvgOrderByAggregateInput
    _max?: customerBillBalanceMaxOrderByAggregateInput
    _min?: customerBillBalanceMinOrderByAggregateInput
    _sum?: customerBillBalanceSumOrderByAggregateInput
  }

  export type customerBillBalanceScalarWhereWithAggregatesInput = {
    AND?: customerBillBalanceScalarWhereWithAggregatesInput | customerBillBalanceScalarWhereWithAggregatesInput[]
    OR?: customerBillBalanceScalarWhereWithAggregatesInput[]
    NOT?: customerBillBalanceScalarWhereWithAggregatesInput | customerBillBalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customerBillBalance"> | number
    balance?: FloatNullableWithAggregatesFilter<"customerBillBalance"> | number | null
    hallMarkBal?: FloatNullableWithAggregatesFilter<"customerBillBalance"> | number | null
    customer_id?: IntWithAggregatesFilter<"customerBillBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"customerBillBalance"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
    bill?: BillCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
    bill?: BillUncheckedCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceUncheckedCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
    bill?: BillUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
    bill?: BillUncheckedUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUncheckedUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemCreateInput = {
    itemName: string
    createdAt?: Date | string
  }

  export type MasterItemUncheckedCreateInput = {
    id?: number
    itemName: string
    createdAt?: Date | string
  }

  export type MasterItemUpdateInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemCreateManyInput = {
    id?: number
    itemName: string
    createdAt?: Date | string
  }

  export type MasterItemUpdateManyMutationInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterTouchCreateInput = {
    touch: number
    createdAt?: Date | string
    rawGoldStock?: RawgoldStockCreateNestedManyWithoutMasterTouchInput
  }

  export type MasterTouchUncheckedCreateInput = {
    id?: number
    touch: number
    createdAt?: Date | string
    rawGoldStock?: RawgoldStockUncheckedCreateNestedManyWithoutMasterTouchInput
  }

  export type MasterTouchUpdateInput = {
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldStock?: RawgoldStockUpdateManyWithoutMasterTouchNestedInput
  }

  export type MasterTouchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldStock?: RawgoldStockUncheckedUpdateManyWithoutMasterTouchNestedInput
  }

  export type MasterTouchCreateManyInput = {
    id?: number
    touch: number
    createdAt?: Date | string
  }

  export type MasterTouchUpdateManyMutationInput = {
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterTouchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type masterWastageCreateInput = {
    wastage: number
    createdAt?: Date | string
  }

  export type masterWastageUncheckedCreateInput = {
    id?: number
    wastage: number
    createdAt?: Date | string
  }

  export type masterWastageUpdateInput = {
    wastage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type masterWastageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wastage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type masterWastageCreateManyInput = {
    id?: number
    wastage: number
    createdAt?: Date | string
  }

  export type masterWastageUpdateManyMutationInput = {
    wastage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type masterWastageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wastage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mastercopperCreateInput = {
    copperTotal: number
    remainCopper: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type mastercopperUncheckedCreateInput = {
    id?: number
    copperTotal: number
    remainCopper: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type mastercopperUpdateInput = {
    copperTotal?: FloatFieldUpdateOperationsInput | number
    remainCopper?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mastercopperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    copperTotal?: FloatFieldUpdateOperationsInput | number
    remainCopper?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mastercopperCreateManyInput = {
    id?: number
    copperTotal: number
    remainCopper: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type mastercopperUpdateManyMutationInput = {
    copperTotal?: FloatFieldUpdateOperationsInput | number
    remainCopper?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mastercopperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    copperTotal?: FloatFieldUpdateOperationsInput | number
    remainCopper?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockCreateInput = {
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt?: Date | string
  }

  export type JewelStockUncheckedCreateInput = {
    id?: number
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt?: Date | string
  }

  export type JewelStockUpdateInput = {
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockCreateManyInput = {
    id?: number
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt?: Date | string
  }

  export type JewelStockUpdateManyMutationInput = {
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    date: Date | string
    type: string
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    createdAt?: Date | string
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutTransactionsInput
    customer: CustomerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    date: Date | string
    type: string
    logId?: number | null
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    customerId: number
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: number
    date: Date | string
    type: string
    logId?: number | null
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    customerId: number
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryCreateInput = {
    date: Date | string
    type: string
    cashAmount?: number | null
    goldValue?: number | null
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    createdAt?: Date | string
  }

  export type EntryUncheckedCreateInput = {
    id?: number
    date: Date | string
    type: string
    cashAmount?: number | null
    goldValue?: number | null
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    createdAt?: Date | string
  }

  export type EntryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryCreateManyInput = {
    id?: number
    date: Date | string
    type: string
    cashAmount?: number | null
    goldValue?: number | null
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    createdAt?: Date | string
  }

  export type EntryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_orderCreateInput = {
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    customers: CustomerCreateNestedOneWithoutCustomerOrdersInput
    productImages?: product_multiple_imagesCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderUncheckedCreateInput = {
    id?: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    productImages?: product_multiple_imagesUncheckedCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderUpdateInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutCustomerOrdersNestedInput
    productImages?: product_multiple_imagesUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productImages?: product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderCreateManyInput = {
    id?: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type customer_orderUpdateManyMutationInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_multiple_imagesCreateInput = {
    filename: string
    customerOrderDetails: customer_orderCreateNestedOneWithoutProductImagesInput
  }

  export type product_multiple_imagesUncheckedCreateInput = {
    id?: number
    customer_order_id: number
    filename: string
  }

  export type product_multiple_imagesUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    customerOrderDetails?: customer_orderUpdateOneRequiredWithoutProductImagesNestedInput
  }

  export type product_multiple_imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_order_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesCreateManyInput = {
    id?: number
    customer_order_id: number
    filename: string
  }

  export type product_multiple_imagesUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_order_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type MasterBullionCreateInput = {
    name: string
    phone?: string | null
    address?: string | null
    purchases?: BullionPurchaseCreateNestedManyWithoutBullionInput
  }

  export type MasterBullionUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    purchases?: BullionPurchaseUncheckedCreateNestedManyWithoutBullionInput
  }

  export type MasterBullionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    purchases?: BullionPurchaseUpdateManyWithoutBullionNestedInput
  }

  export type MasterBullionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    purchases?: BullionPurchaseUncheckedUpdateManyWithoutBullionNestedInput
  }

  export type MasterBullionCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
  }

  export type MasterBullionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterBullionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BullionPurchaseCreateInput = {
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    bullion: MasterBullionCreateNestedOneWithoutPurchasesInput
    givenDetails?: GivenDetailCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseUncheckedCreateInput = {
    id?: number
    bullionId: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    givenDetails?: GivenDetailUncheckedCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseUpdateInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bullion?: MasterBullionUpdateOneRequiredWithoutPurchasesNestedInput
    givenDetails?: GivenDetailUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bullionId?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenDetails?: GivenDetailUncheckedUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseCreateManyInput = {
    id?: number
    bullionId: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
  }

  export type BullionPurchaseUpdateManyMutationInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BullionPurchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bullionId?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GivenDetailCreateInput = {
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
    bullionPurchase: BullionPurchaseCreateNestedOneWithoutGivenDetailsInput
  }

  export type GivenDetailUncheckedCreateInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
    purchaseId: number
  }

  export type GivenDetailUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    bullionPurchase?: BullionPurchaseUpdateOneRequiredWithoutGivenDetailsNestedInput
  }

  export type GivenDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseId?: IntFieldUpdateOperationsInput | number
  }

  export type GivenDetailCreateManyInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
    purchaseId: number
  }

  export type GivenDetailUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type GivenDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseId?: IntFieldUpdateOperationsInput | number
  }

  export type GoldsmithCreateInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoldsmithUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoldsmithUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobcardCreateInput = {
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockCreateNestedManyWithoutJobcardInput
    total?: TotalCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateInput = {
    id?: number
    goldsmithId: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutJobcardInput
    total?: TotalUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUpdateManyWithoutJobcardNestedInput
    total?: TotalUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutJobcardNestedInput
    total?: TotalUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardCreateManyInput = {
    id?: number
    goldsmithId: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobcardUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobcardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldCreateInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutGivenGoldInput
    jobcard?: JobcardCreateNestedOneWithoutGivenGoldInput
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutGivenGoldInput
  }

  export type givenGoldUncheckedCreateInput = {
    id?: number
    goldsmithId?: number | null
    jobcardId?: number | null
    logId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldUpdateInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutGivenGoldNestedInput
    jobcard?: JobcardUpdateOneWithoutGivenGoldNestedInput
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutGivenGoldNestedInput
  }

  export type givenGoldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldCreateManyInput = {
    id?: number
    goldsmithId?: number | null
    jobcardId?: number | null
    logId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldUpdateManyMutationInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryCreateInput = {
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutDeliveriesInput
    jobcard?: JobcardCreateNestedOneWithoutDeliveriesInput
    deduction?: deductionCreateNestedManyWithoutItemDeliveryInput
  }

  export type itemDeliveryUncheckedCreateInput = {
    id?: number
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    goldsmithId?: number | null
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deduction?: deductionUncheckedCreateNestedManyWithoutItemDeliveryInput
  }

  export type itemDeliveryUpdateInput = {
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutDeliveriesNestedInput
    jobcard?: JobcardUpdateOneWithoutDeliveriesNestedInput
    deduction?: deductionUpdateManyWithoutItemDeliveryNestedInput
  }

  export type itemDeliveryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deduction?: deductionUncheckedUpdateManyWithoutItemDeliveryNestedInput
  }

  export type itemDeliveryCreateManyInput = {
    id?: number
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    goldsmithId?: number | null
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryUpdateManyMutationInput = {
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deductionCreateInput = {
    type?: string | null
    weight?: number | null
    stoneWt?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemDelivery: itemDeliveryCreateNestedOneWithoutDeductionInput
  }

  export type deductionUncheckedCreateInput = {
    id?: number
    type?: string | null
    deliveryId: number
    weight?: number | null
    stoneWt?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deductionUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWt?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemDelivery?: itemDeliveryUpdateOneRequiredWithoutDeductionNestedInput
  }

  export type deductionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWt?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deductionCreateManyInput = {
    id?: number
    type?: string | null
    deliveryId: number
    weight?: number | null
    stoneWt?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deductionUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWt?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deductionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWt?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalCreateInput = {
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutTotalInput
    goldsmith: GoldsmithCreateNestedOneWithoutTotalsInput
  }

  export type TotalUncheckedCreateInput = {
    id?: number
    jobcardId?: number | null
    goldsmithId: number
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalUpdateInput = {
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutTotalNestedInput
    goldsmith?: GoldsmithUpdateOneRequiredWithoutTotalsNestedInput
  }

  export type TotalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalCreateManyInput = {
    id?: number
    jobcardId?: number | null
    goldsmithId: number
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalUpdateManyMutationInput = {
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionCreateInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutReceivedSectionsInput
    jobcard?: JobcardCreateNestedOneWithoutReceivedInput
    goldsmith?: GoldsmithCreateNestedOneWithoutReceivedInput
  }

  export type ReceivedsectionUncheckedCreateInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    logId?: number | null
    jobcardId: number
    goldsmithId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionUpdateInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutReceivedSectionsNestedInput
    jobcard?: JobcardUpdateOneWithoutReceivedNestedInput
    goldsmith?: GoldsmithUpdateOneWithoutReceivedNestedInput
  }

  export type ReceivedsectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionCreateManyInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    logId?: number | null
    jobcardId: number
    goldsmithId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionUpdateManyMutationInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawgoldStockCreateInput = {
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
    masterTouch?: MasterTouchCreateNestedOneWithoutRawGoldStockInput
    rawGoldLogs?: RawGoldLogsCreateNestedManyWithoutRawGoldStockInput
  }

  export type RawgoldStockUncheckedCreateInput = {
    id?: number
    touchId: number
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
    rawGoldLogs?: RawGoldLogsUncheckedCreateNestedManyWithoutRawGoldStockInput
  }

  export type RawgoldStockUpdateInput = {
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
    masterTouch?: MasterTouchUpdateOneWithoutRawGoldStockNestedInput
    rawGoldLogs?: RawGoldLogsUpdateManyWithoutRawGoldStockNestedInput
  }

  export type RawgoldStockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    touchId?: IntFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldLogs?: RawGoldLogsUncheckedUpdateManyWithoutRawGoldStockNestedInput
  }

  export type RawgoldStockCreateManyInput = {
    id?: number
    touchId: number
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
  }

  export type RawgoldStockUpdateManyMutationInput = {
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RawgoldStockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    touchId?: IntFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RawGoldLogsCreateInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    rawGoldStock?: RawgoldStockCreateNestedOneWithoutRawGoldLogsInput
    givenGold?: givenGoldCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUpdateInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldStock?: RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput
    givenGold?: givenGoldUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsCreateManyInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
  }

  export type RawGoldLogsUpdateManyMutationInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RawGoldLogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExpenseTrackerCreateInput = {
    gold?: number | null
    touch?: number | null
    purity?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutExpenseTrackerInput
  }

  export type ExpenseTrackerUncheckedCreateInput = {
    id?: number
    logId?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseTrackerUpdateInput = {
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutExpenseTrackerNestedInput
  }

  export type ExpenseTrackerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseTrackerCreateManyInput = {
    id?: number
    logId?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseTrackerUpdateManyMutationInput = {
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseTrackerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesCreateInput = {
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutSummariesInput
  }

  export type BalancesUncheckedCreateInput = {
    id?: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesUpdateInput = {
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutSummariesNestedInput
  }

  export type BalancesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesCreateManyInput = {
    id?: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesUpdateManyMutationInput = {
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairCreateInput = {
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutRepairsInput
  }

  export type RepairUncheckedCreateInput = {
    id?: number
    goldsmithId: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairUpdateInput = {
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutRepairsNestedInput
  }

  export type RepairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairCreateManyInput = {
    id?: number
    goldsmithId: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairUpdateManyMutationInput = {
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateInput = {
    itemName: string
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight?: number | null
    wastagePure?: number | null
    finalWeight: number
    createdAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutProductStockInput
  }

  export type ProductStockUncheckedCreateInput = {
    id?: number
    jobcardId: number
    itemName: string
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight?: number | null
    wastagePure?: number | null
    finalWeight: number
    createdAt?: Date | string
  }

  export type ProductStockUpdateInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    wastageValue?: FloatFieldUpdateOperationsInput | number
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutProductStockNestedInput
  }

  export type ProductStockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    wastageValue?: FloatFieldUpdateOperationsInput | number
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateManyInput = {
    id?: number
    jobcardId: number
    itemName: string
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight?: number | null
    wastagePure?: number | null
    finalWeight: number
    createdAt?: Date | string
  }

  export type ProductStockUpdateManyMutationInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    wastageValue?: FloatFieldUpdateOperationsInput | number
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    wastageValue?: FloatFieldUpdateOperationsInput | number
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateInput = {
    date?: Date | string | null
    time?: Date | string | null
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    customers: CustomerCreateNestedOneWithoutBillInput
    orders?: OrderItemsCreateNestedManyWithoutBillInput
    billReceive?: billReceivedCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateInput = {
    id?: number
    date?: Date | string | null
    time?: Date | string | null
    customer_id: number
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    orders?: OrderItemsUncheckedCreateNestedManyWithoutBillInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillUpdateInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutBillNestedInput
    orders?: OrderItemsUpdateManyWithoutBillNestedInput
    billReceive?: billReceivedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer_id?: IntFieldUpdateOperationsInput | number
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemsUncheckedUpdateManyWithoutBillNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillCreateManyInput = {
    id?: number
    date?: Date | string | null
    time?: Date | string | null
    customer_id: number
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
  }

  export type BillUpdateManyMutationInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer_id?: IntFieldUpdateOperationsInput | number
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateInput = {
    productName: string
    count?: number | null
    weight?: number | null
    stoneWeight?: number | null
    afterWeight?: number | null
    percentage?: number | null
    finalWeight?: number | null
    createdAt?: Date | string
    bill: BillCreateNestedOneWithoutOrdersInput
  }

  export type OrderItemsUncheckedCreateInput = {
    id?: number
    billId: number
    productName: string
    count?: number | null
    weight?: number | null
    stoneWeight?: number | null
    afterWeight?: number | null
    percentage?: number | null
    finalWeight?: number | null
    createdAt?: Date | string
  }

  export type OrderItemsUpdateInput = {
    productName?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    afterWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    afterWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateManyInput = {
    id?: number
    billId: number
    productName: string
    count?: number | null
    weight?: number | null
    stoneWeight?: number | null
    afterWeight?: number | null
    percentage?: number | null
    finalWeight?: number | null
    createdAt?: Date | string
  }

  export type OrderItemsUpdateManyMutationInput = {
    productName?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    afterWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    afterWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedCreateInput = {
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
    bill?: BillCreateNestedOneWithoutBillReceiveInput
    customers: CustomerCreateNestedOneWithoutBillReceiveInput
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutBillReceiveInput
  }

  export type billReceivedUncheckedCreateInput = {
    id?: number
    billId?: number | null
    customer_id: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type billReceivedUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneWithoutBillReceiveNestedInput
    customers?: CustomerUpdateOneRequiredWithoutBillReceiveNestedInput
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutBillReceiveNestedInput
  }

  export type billReceivedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedCreateManyInput = {
    id?: number
    billId?: number | null
    customer_id: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type billReceivedUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type receiptVoucherCreateInput = {
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
    customers: CustomerCreateNestedOneWithoutReceiptVoucherInput
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutReceiptVoucherInput
  }

  export type receiptVoucherUncheckedCreateInput = {
    id?: number
    customer_id: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type receiptVoucherUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutReceiptVoucherNestedInput
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutReceiptVoucherNestedInput
  }

  export type receiptVoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type receiptVoucherCreateManyInput = {
    id?: number
    customer_id: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type receiptVoucherUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type receiptVoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerBillBalanceCreateInput = {
    balance?: number | null
    hallMarkBal?: number | null
    createdAt?: Date | string
    customers: CustomerCreateNestedOneWithoutCustomerBillBalanceInput
  }

  export type customerBillBalanceUncheckedCreateInput = {
    id?: number
    balance?: number | null
    hallMarkBal?: number | null
    customer_id: number
    createdAt?: Date | string
  }

  export type customerBillBalanceUpdateInput = {
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    hallMarkBal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutCustomerBillBalanceNestedInput
  }

  export type customerBillBalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    hallMarkBal?: NullableFloatFieldUpdateOperationsInput | number | null
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerBillBalanceCreateManyInput = {
    id?: number
    balance?: number | null
    hallMarkBal?: number | null
    customer_id: number
    createdAt?: Date | string
  }

  export type customerBillBalanceUpdateManyMutationInput = {
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    hallMarkBal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerBillBalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    hallMarkBal?: NullableFloatFieldUpdateOperationsInput | number | null
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type Customer_orderListRelationFilter = {
    every?: customer_orderWhereInput
    some?: customer_orderWhereInput
    none?: customer_orderWhereInput
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type BillReceivedListRelationFilter = {
    every?: billReceivedWhereInput
    some?: billReceivedWhereInput
    none?: billReceivedWhereInput
  }

  export type ReceiptVoucherListRelationFilter = {
    every?: receiptVoucherWhereInput
    some?: receiptVoucherWhereInput
    none?: receiptVoucherWhereInput
  }

  export type CustomerBillBalanceNullableScalarRelationFilter = {
    is?: customerBillBalanceWhereInput | null
    isNot?: customerBillBalanceWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customer_orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type billReceivedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type receiptVoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MasterItemOrderByRelevanceInput = {
    fields: MasterItemOrderByRelevanceFieldEnum | MasterItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MasterItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterItemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterItemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RawgoldStockListRelationFilter = {
    every?: RawgoldStockWhereInput
    some?: RawgoldStockWhereInput
    none?: RawgoldStockWhereInput
  }

  export type RawgoldStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterTouchCountOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterTouchAvgOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
  }

  export type MasterTouchMaxOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterTouchMinOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterTouchSumOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type masterWastageCountOrderByAggregateInput = {
    id?: SortOrder
    wastage?: SortOrder
    createdAt?: SortOrder
  }

  export type masterWastageAvgOrderByAggregateInput = {
    id?: SortOrder
    wastage?: SortOrder
  }

  export type masterWastageMaxOrderByAggregateInput = {
    id?: SortOrder
    wastage?: SortOrder
    createdAt?: SortOrder
  }

  export type masterWastageMinOrderByAggregateInput = {
    id?: SortOrder
    wastage?: SortOrder
    createdAt?: SortOrder
  }

  export type masterWastageSumOrderByAggregateInput = {
    id?: SortOrder
    wastage?: SortOrder
  }

  export type mastercopperCountOrderByAggregateInput = {
    id?: SortOrder
    copperTotal?: SortOrder
    remainCopper?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mastercopperAvgOrderByAggregateInput = {
    id?: SortOrder
    copperTotal?: SortOrder
    remainCopper?: SortOrder
  }

  export type mastercopperMaxOrderByAggregateInput = {
    id?: SortOrder
    copperTotal?: SortOrder
    remainCopper?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mastercopperMinOrderByAggregateInput = {
    id?: SortOrder
    copperTotal?: SortOrder
    remainCopper?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mastercopperSumOrderByAggregateInput = {
    id?: SortOrder
    copperTotal?: SortOrder
    remainCopper?: SortOrder
  }

  export type JewelStockOrderByRelevanceInput = {
    fields: JewelStockOrderByRelevanceFieldEnum | JewelStockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JewelStockCountOrderByAggregateInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
  }

  export type JewelStockAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
  }

  export type JewelStockMaxOrderByAggregateInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
  }

  export type JewelStockMinOrderByAggregateInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
  }

  export type JewelStockSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RawGoldLogsNullableScalarRelationFilter = {
    is?: RawGoldLogsWhereInput | null
    isNot?: RawGoldLogsWhereInput | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type TransactionOrderByRelevanceInput = {
    fields: TransactionOrderByRelevanceFieldEnum | TransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    amount?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    amount?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    amount?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    amount?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    amount?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EntryOrderByRelevanceInput = {
    fields: EntryOrderByRelevanceFieldEnum | EntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EntryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    createdAt?: SortOrder
  }

  export type EntryAvgOrderByAggregateInput = {
    id?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
  }

  export type EntryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    createdAt?: SortOrder
  }

  export type EntryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    createdAt?: SortOrder
  }

  export type EntrySumOrderByAggregateInput = {
    id?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Product_multiple_imagesListRelationFilter = {
    every?: product_multiple_imagesWhereInput
    some?: product_multiple_imagesWhereInput
    none?: product_multiple_imagesWhereInput
  }

  export type product_multiple_imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customer_orderOrderByRelevanceInput = {
    fields: customer_orderOrderByRelevanceFieldEnum | customer_orderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type customer_orderCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    worker_name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type customer_orderAvgOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    weight?: SortOrder
  }

  export type customer_orderMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    worker_name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type customer_orderMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    worker_name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type customer_orderSumOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    weight?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Customer_orderScalarRelationFilter = {
    is?: customer_orderWhereInput
    isNot?: customer_orderWhereInput
  }

  export type product_multiple_imagesOrderByRelevanceInput = {
    fields: product_multiple_imagesOrderByRelevanceFieldEnum | product_multiple_imagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type product_multiple_imagesCountOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
  }

  export type product_multiple_imagesAvgOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
  }

  export type product_multiple_imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
  }

  export type product_multiple_imagesMinOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
  }

  export type product_multiple_imagesSumOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
  }

  export type BullionPurchaseListRelationFilter = {
    every?: BullionPurchaseWhereInput
    some?: BullionPurchaseWhereInput
    none?: BullionPurchaseWhereInput
  }

  export type BullionPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterBullionOrderByRelevanceInput = {
    fields: MasterBullionOrderByRelevanceFieldEnum | MasterBullionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MasterBullionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type MasterBullionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterBullionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type MasterBullionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type MasterBullionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterBullionScalarRelationFilter = {
    is?: MasterBullionWhereInput
    isNot?: MasterBullionWhereInput
  }

  export type GivenDetailListRelationFilter = {
    every?: GivenDetailWhereInput
    some?: GivenDetailWhereInput
    none?: GivenDetailWhereInput
  }

  export type GivenDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BullionPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type BullionPurchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
  }

  export type BullionPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type BullionPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type BullionPurchaseSumOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
  }

  export type BullionPurchaseScalarRelationFilter = {
    is?: BullionPurchaseWhereInput
    isNot?: BullionPurchaseWhereInput
  }

  export type GivenDetailCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type JobcardListRelationFilter = {
    every?: JobcardWhereInput
    some?: JobcardWhereInput
    none?: JobcardWhereInput
  }

  export type GivenGoldListRelationFilter = {
    every?: givenGoldWhereInput
    some?: givenGoldWhereInput
    none?: givenGoldWhereInput
  }

  export type ItemDeliveryListRelationFilter = {
    every?: itemDeliveryWhereInput
    some?: itemDeliveryWhereInput
    none?: itemDeliveryWhereInput
  }

  export type ReceivedsectionListRelationFilter = {
    every?: ReceivedsectionWhereInput
    some?: ReceivedsectionWhereInput
    none?: ReceivedsectionWhereInput
  }

  export type TotalListRelationFilter = {
    every?: TotalWhereInput
    some?: TotalWhereInput
    none?: TotalWhereInput
  }

  export type RepairListRelationFilter = {
    every?: RepairWhereInput
    some?: RepairWhereInput
    none?: RepairWhereInput
  }

  export type BalancesListRelationFilter = {
    every?: BalancesWhereInput
    some?: BalancesWhereInput
    none?: BalancesWhereInput
  }

  export type JobcardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type givenGoldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceivedsectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TotalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoldsmithOrderByRelevanceInput = {
    fields: GoldsmithOrderByRelevanceFieldEnum | GoldsmithOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GoldsmithCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoldsmithAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GoldsmithMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoldsmithMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoldsmithSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type GoldsmithScalarRelationFilter = {
    is?: GoldsmithWhereInput
    isNot?: GoldsmithWhereInput
  }

  export type ProductStockListRelationFilter = {
    every?: ProductStockWhereInput
    some?: ProductStockWhereInput
    none?: ProductStockWhereInput
  }

  export type ProductStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobcardOrderByRelevanceInput = {
    fields: JobcardOrderByRelevanceFieldEnum | JobcardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobcardCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    stockIsMove?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobcardAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
  }

  export type JobcardMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    stockIsMove?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobcardMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    stockIsMove?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobcardSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type GoldsmithNullableScalarRelationFilter = {
    is?: GoldsmithWhereInput | null
    isNot?: GoldsmithWhereInput | null
  }

  export type JobcardNullableScalarRelationFilter = {
    is?: JobcardWhereInput | null
    isNot?: JobcardWhereInput | null
  }

  export type givenGoldCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    logId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    finaltouch?: SortOrder
    finalPurity?: SortOrder
    copperPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type givenGoldAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    logId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    finaltouch?: SortOrder
    finalPurity?: SortOrder
    copperPurity?: SortOrder
  }

  export type givenGoldMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    logId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    finaltouch?: SortOrder
    finalPurity?: SortOrder
    copperPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type givenGoldMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    logId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    finaltouch?: SortOrder
    finalPurity?: SortOrder
    copperPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type givenGoldSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    logId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    finaltouch?: SortOrder
    finalPurity?: SortOrder
    copperPurity?: SortOrder
  }

  export type DeductionListRelationFilter = {
    every?: deductionWhereInput
    some?: deductionWhereInput
    none?: deductionWhereInput
  }

  export type deductionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemDeliveryOrderByRelevanceInput = {
    fields: itemDeliveryOrderByRelevanceFieldEnum | itemDeliveryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type itemDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    sealName?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    wastagePure?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemDeliveryAvgOrderByAggregateInput = {
    id?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    wastageValue?: SortOrder
    wastagePure?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
  }

  export type itemDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    sealName?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    wastagePure?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    sealName?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    wastagePure?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemDeliverySumOrderByAggregateInput = {
    id?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    wastageValue?: SortOrder
    wastagePure?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
  }

  export type ItemDeliveryScalarRelationFilter = {
    is?: itemDeliveryWhereInput
    isNot?: itemDeliveryWhereInput
  }

  export type deductionOrderByRelevanceInput = {
    fields: deductionOrderByRelevanceFieldEnum | deductionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type deductionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    deliveryId?: SortOrder
    weight?: SortOrder
    stoneWt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deductionAvgOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    weight?: SortOrder
    stoneWt?: SortOrder
  }

  export type deductionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    deliveryId?: SortOrder
    weight?: SortOrder
    stoneWt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deductionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    deliveryId?: SortOrder
    weight?: SortOrder
    stoneWt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deductionSumOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    weight?: SortOrder
    stoneWt?: SortOrder
  }

  export type TotalOrderByRelevanceInput = {
    fields: TotalOrderByRelevanceFieldEnum | TotalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TotalCountOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    givenTotal?: SortOrder
    deliveryTotal?: SortOrder
    stoneTotalWt?: SortOrder
    openingBalance?: SortOrder
    jobCardBalance?: SortOrder
    receivedTotal?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotalAvgOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    givenTotal?: SortOrder
    deliveryTotal?: SortOrder
    stoneTotalWt?: SortOrder
    openingBalance?: SortOrder
    jobCardBalance?: SortOrder
    receivedTotal?: SortOrder
  }

  export type TotalMaxOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    givenTotal?: SortOrder
    deliveryTotal?: SortOrder
    stoneTotalWt?: SortOrder
    openingBalance?: SortOrder
    jobCardBalance?: SortOrder
    receivedTotal?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotalMinOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    givenTotal?: SortOrder
    deliveryTotal?: SortOrder
    stoneTotalWt?: SortOrder
    openingBalance?: SortOrder
    jobCardBalance?: SortOrder
    receivedTotal?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotalSumOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    givenTotal?: SortOrder
    deliveryTotal?: SortOrder
    stoneTotalWt?: SortOrder
    openingBalance?: SortOrder
    jobCardBalance?: SortOrder
    receivedTotal?: SortOrder
  }

  export type ReceivedsectionCountOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    logId?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivedsectionAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    logId?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
  }

  export type ReceivedsectionMaxOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    logId?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivedsectionMinOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    logId?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivedsectionSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    logId?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
  }

  export type MasterTouchNullableScalarRelationFilter = {
    is?: MasterTouchWhereInput | null
    isNot?: MasterTouchWhereInput | null
  }

  export type RawGoldLogsListRelationFilter = {
    every?: RawGoldLogsWhereInput
    some?: RawGoldLogsWhereInput
    none?: RawGoldLogsWhereInput
  }

  export type RawGoldLogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RawgoldStockCountOrderByAggregateInput = {
    id?: SortOrder
    touchId?: SortOrder
    touch?: SortOrder
    weight?: SortOrder
    remainingWt?: SortOrder
  }

  export type RawgoldStockAvgOrderByAggregateInput = {
    id?: SortOrder
    touchId?: SortOrder
    touch?: SortOrder
    weight?: SortOrder
    remainingWt?: SortOrder
  }

  export type RawgoldStockMaxOrderByAggregateInput = {
    id?: SortOrder
    touchId?: SortOrder
    touch?: SortOrder
    weight?: SortOrder
    remainingWt?: SortOrder
  }

  export type RawgoldStockMinOrderByAggregateInput = {
    id?: SortOrder
    touchId?: SortOrder
    touch?: SortOrder
    weight?: SortOrder
    remainingWt?: SortOrder
  }

  export type RawgoldStockSumOrderByAggregateInput = {
    id?: SortOrder
    touchId?: SortOrder
    touch?: SortOrder
    weight?: SortOrder
    remainingWt?: SortOrder
  }

  export type RawgoldStockNullableScalarRelationFilter = {
    is?: RawgoldStockWhereInput | null
    isNot?: RawgoldStockWhereInput | null
  }

  export type ExpenseTrackerListRelationFilter = {
    every?: ExpenseTrackerWhereInput
    some?: ExpenseTrackerWhereInput
    none?: ExpenseTrackerWhereInput
  }

  export type ExpenseTrackerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RawGoldLogsCountOrderByAggregateInput = {
    id?: SortOrder
    rawGoldStockId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type RawGoldLogsAvgOrderByAggregateInput = {
    id?: SortOrder
    rawGoldStockId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type RawGoldLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    rawGoldStockId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type RawGoldLogsMinOrderByAggregateInput = {
    id?: SortOrder
    rawGoldStockId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type RawGoldLogsSumOrderByAggregateInput = {
    id?: SortOrder
    rawGoldStockId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type ExpenseTrackerOrderByRelevanceInput = {
    fields: ExpenseTrackerOrderByRelevanceFieldEnum | ExpenseTrackerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExpenseTrackerCountOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseTrackerAvgOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type ExpenseTrackerMaxOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseTrackerMinOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseTrackerSumOrderByAggregateInput = {
    id?: SortOrder
    logId?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type BalancesCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalancesAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
  }

  export type BalancesMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalancesMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalancesSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RepairOrderByRelevanceInput = {
    fields: RepairOrderByRelevanceFieldEnum | RepairOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RepairCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    givenWeights?: SortOrder
    totalGiven?: SortOrder
    itemWeights?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
  }

  export type RepairMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ProductStockOrderByRelevanceInput = {
    fields: ProductStockOrderByRelevanceFieldEnum | ProductStockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductStockCountOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    stoneWeight?: SortOrder
    wastageValue?: SortOrder
    netWeight?: SortOrder
    wastagePure?: SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductStockAvgOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    stoneWeight?: SortOrder
    wastageValue?: SortOrder
    netWeight?: SortOrder
    wastagePure?: SortOrder
    finalWeight?: SortOrder
  }

  export type ProductStockMaxOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    stoneWeight?: SortOrder
    wastageValue?: SortOrder
    netWeight?: SortOrder
    wastagePure?: SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductStockMinOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    stoneWeight?: SortOrder
    wastageValue?: SortOrder
    netWeight?: SortOrder
    wastagePure?: SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductStockSumOrderByAggregateInput = {
    id?: SortOrder
    jobcardId?: SortOrder
    itemWeight?: SortOrder
    count?: SortOrder
    touch?: SortOrder
    stoneWeight?: SortOrder
    wastageValue?: SortOrder
    netWeight?: SortOrder
    wastagePure?: SortOrder
    finalWeight?: SortOrder
  }

  export type OrderItemsListRelationFilter = {
    every?: OrderItemsWhereInput
    some?: OrderItemsWhereInput
    none?: OrderItemsWhereInput
  }

  export type OrderItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    customer_id?: SortOrder
    billAmount?: SortOrder
    hallMark?: SortOrder
    prevHallMark?: SortOrder
    PrevBalance?: SortOrder
    billDetailsprofit?: SortOrder
    Stoneprofit?: SortOrder
    Totalprofit?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    billAmount?: SortOrder
    hallMark?: SortOrder
    prevHallMark?: SortOrder
    PrevBalance?: SortOrder
    billDetailsprofit?: SortOrder
    Stoneprofit?: SortOrder
    Totalprofit?: SortOrder
    cashBalance?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    customer_id?: SortOrder
    billAmount?: SortOrder
    hallMark?: SortOrder
    prevHallMark?: SortOrder
    PrevBalance?: SortOrder
    billDetailsprofit?: SortOrder
    Stoneprofit?: SortOrder
    Totalprofit?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    customer_id?: SortOrder
    billAmount?: SortOrder
    hallMark?: SortOrder
    prevHallMark?: SortOrder
    PrevBalance?: SortOrder
    billDetailsprofit?: SortOrder
    Stoneprofit?: SortOrder
    Totalprofit?: SortOrder
    cashBalance?: SortOrder
    createdAt?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    billAmount?: SortOrder
    hallMark?: SortOrder
    prevHallMark?: SortOrder
    PrevBalance?: SortOrder
    billDetailsprofit?: SortOrder
    Stoneprofit?: SortOrder
    Totalprofit?: SortOrder
    cashBalance?: SortOrder
  }

  export type BillScalarRelationFilter = {
    is?: BillWhereInput
    isNot?: BillWhereInput
  }

  export type OrderItemsOrderByRelevanceInput = {
    fields: OrderItemsOrderByRelevanceFieldEnum | OrderItemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderItemsCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    productName?: SortOrder
    count?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    afterWeight?: SortOrder
    percentage?: SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    count?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    afterWeight?: SortOrder
    percentage?: SortOrder
    finalWeight?: SortOrder
  }

  export type OrderItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    productName?: SortOrder
    count?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    afterWeight?: SortOrder
    percentage?: SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemsMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    productName?: SortOrder
    count?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    afterWeight?: SortOrder
    percentage?: SortOrder
    finalWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemsSumOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    count?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    afterWeight?: SortOrder
    percentage?: SortOrder
    finalWeight?: SortOrder
  }

  export type BillNullableScalarRelationFilter = {
    is?: BillWhereInput | null
    isNot?: BillWhereInput | null
  }

  export type billReceivedOrderByRelevanceInput = {
    fields: billReceivedOrderByRelevanceFieldEnum | billReceivedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type billReceivedCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type billReceivedAvgOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
  }

  export type billReceivedMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type billReceivedMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type billReceivedSumOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
  }

  export type receiptVoucherOrderByRelevanceInput = {
    fields: receiptVoucherOrderByRelevanceFieldEnum | receiptVoucherOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type receiptVoucherCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type receiptVoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
  }

  export type receiptVoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type receiptVoucherMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type receiptVoucherSumOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    logId?: SortOrder
    goldRate?: SortOrder
    gold?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    receiveHallMark?: SortOrder
    amount?: SortOrder
  }

  export type customerBillBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    hallMarkBal?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
  }

  export type customerBillBalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    hallMarkBal?: SortOrder
    customer_id?: SortOrder
  }

  export type customerBillBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    hallMarkBal?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
  }

  export type customerBillBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    hallMarkBal?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
  }

  export type customerBillBalanceSumOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    hallMarkBal?: SortOrder
    customer_id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type customer_orderCreateNestedManyWithoutCustomersInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
  }

  export type BillCreateNestedManyWithoutCustomersInput = {
    create?: XOR<BillCreateWithoutCustomersInput, BillUncheckedCreateWithoutCustomersInput> | BillCreateWithoutCustomersInput[] | BillUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCustomersInput | BillCreateOrConnectWithoutCustomersInput[]
    createMany?: BillCreateManyCustomersInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type billReceivedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<billReceivedCreateWithoutCustomersInput, billReceivedUncheckedCreateWithoutCustomersInput> | billReceivedCreateWithoutCustomersInput[] | billReceivedUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutCustomersInput | billReceivedCreateOrConnectWithoutCustomersInput[]
    createMany?: billReceivedCreateManyCustomersInputEnvelope
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
  }

  export type receiptVoucherCreateNestedManyWithoutCustomersInput = {
    create?: XOR<receiptVoucherCreateWithoutCustomersInput, receiptVoucherUncheckedCreateWithoutCustomersInput> | receiptVoucherCreateWithoutCustomersInput[] | receiptVoucherUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutCustomersInput | receiptVoucherCreateOrConnectWithoutCustomersInput[]
    createMany?: receiptVoucherCreateManyCustomersInputEnvelope
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
  }

  export type customerBillBalanceCreateNestedOneWithoutCustomersInput = {
    create?: XOR<customerBillBalanceCreateWithoutCustomersInput, customerBillBalanceUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customerBillBalanceCreateOrConnectWithoutCustomersInput
    connect?: customerBillBalanceWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type customer_orderUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<BillCreateWithoutCustomersInput, BillUncheckedCreateWithoutCustomersInput> | BillCreateWithoutCustomersInput[] | BillUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCustomersInput | BillCreateOrConnectWithoutCustomersInput[]
    createMany?: BillCreateManyCustomersInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type billReceivedUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<billReceivedCreateWithoutCustomersInput, billReceivedUncheckedCreateWithoutCustomersInput> | billReceivedCreateWithoutCustomersInput[] | billReceivedUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutCustomersInput | billReceivedCreateOrConnectWithoutCustomersInput[]
    createMany?: billReceivedCreateManyCustomersInputEnvelope
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
  }

  export type receiptVoucherUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<receiptVoucherCreateWithoutCustomersInput, receiptVoucherUncheckedCreateWithoutCustomersInput> | receiptVoucherCreateWithoutCustomersInput[] | receiptVoucherUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutCustomersInput | receiptVoucherCreateOrConnectWithoutCustomersInput[]
    createMany?: receiptVoucherCreateManyCustomersInputEnvelope
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
  }

  export type customerBillBalanceUncheckedCreateNestedOneWithoutCustomersInput = {
    create?: XOR<customerBillBalanceCreateWithoutCustomersInput, customerBillBalanceUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customerBillBalanceCreateOrConnectWithoutCustomersInput
    connect?: customerBillBalanceWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type customer_orderUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    upsert?: customer_orderUpsertWithWhereUniqueWithoutCustomersInput | customer_orderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    set?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    disconnect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    delete?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    update?: customer_orderUpdateWithWhereUniqueWithoutCustomersInput | customer_orderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: customer_orderUpdateManyWithWhereWithoutCustomersInput | customer_orderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
  }

  export type BillUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<BillCreateWithoutCustomersInput, BillUncheckedCreateWithoutCustomersInput> | BillCreateWithoutCustomersInput[] | BillUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCustomersInput | BillCreateOrConnectWithoutCustomersInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutCustomersInput | BillUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: BillCreateManyCustomersInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutCustomersInput | BillUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: BillUpdateManyWithWhereWithoutCustomersInput | BillUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type billReceivedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<billReceivedCreateWithoutCustomersInput, billReceivedUncheckedCreateWithoutCustomersInput> | billReceivedCreateWithoutCustomersInput[] | billReceivedUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutCustomersInput | billReceivedCreateOrConnectWithoutCustomersInput[]
    upsert?: billReceivedUpsertWithWhereUniqueWithoutCustomersInput | billReceivedUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: billReceivedCreateManyCustomersInputEnvelope
    set?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    disconnect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    delete?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    update?: billReceivedUpdateWithWhereUniqueWithoutCustomersInput | billReceivedUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: billReceivedUpdateManyWithWhereWithoutCustomersInput | billReceivedUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
  }

  export type receiptVoucherUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<receiptVoucherCreateWithoutCustomersInput, receiptVoucherUncheckedCreateWithoutCustomersInput> | receiptVoucherCreateWithoutCustomersInput[] | receiptVoucherUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutCustomersInput | receiptVoucherCreateOrConnectWithoutCustomersInput[]
    upsert?: receiptVoucherUpsertWithWhereUniqueWithoutCustomersInput | receiptVoucherUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: receiptVoucherCreateManyCustomersInputEnvelope
    set?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    disconnect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    delete?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    update?: receiptVoucherUpdateWithWhereUniqueWithoutCustomersInput | receiptVoucherUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: receiptVoucherUpdateManyWithWhereWithoutCustomersInput | receiptVoucherUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: receiptVoucherScalarWhereInput | receiptVoucherScalarWhereInput[]
  }

  export type customerBillBalanceUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<customerBillBalanceCreateWithoutCustomersInput, customerBillBalanceUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customerBillBalanceCreateOrConnectWithoutCustomersInput
    upsert?: customerBillBalanceUpsertWithoutCustomersInput
    disconnect?: customerBillBalanceWhereInput | boolean
    delete?: customerBillBalanceWhereInput | boolean
    connect?: customerBillBalanceWhereUniqueInput
    update?: XOR<XOR<customerBillBalanceUpdateToOneWithWhereWithoutCustomersInput, customerBillBalanceUpdateWithoutCustomersInput>, customerBillBalanceUncheckedUpdateWithoutCustomersInput>
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type customer_orderUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    upsert?: customer_orderUpsertWithWhereUniqueWithoutCustomersInput | customer_orderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    set?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    disconnect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    delete?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    update?: customer_orderUpdateWithWhereUniqueWithoutCustomersInput | customer_orderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: customer_orderUpdateManyWithWhereWithoutCustomersInput | customer_orderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<BillCreateWithoutCustomersInput, BillUncheckedCreateWithoutCustomersInput> | BillCreateWithoutCustomersInput[] | BillUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: BillCreateOrConnectWithoutCustomersInput | BillCreateOrConnectWithoutCustomersInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutCustomersInput | BillUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: BillCreateManyCustomersInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutCustomersInput | BillUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: BillUpdateManyWithWhereWithoutCustomersInput | BillUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type billReceivedUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<billReceivedCreateWithoutCustomersInput, billReceivedUncheckedCreateWithoutCustomersInput> | billReceivedCreateWithoutCustomersInput[] | billReceivedUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutCustomersInput | billReceivedCreateOrConnectWithoutCustomersInput[]
    upsert?: billReceivedUpsertWithWhereUniqueWithoutCustomersInput | billReceivedUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: billReceivedCreateManyCustomersInputEnvelope
    set?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    disconnect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    delete?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    update?: billReceivedUpdateWithWhereUniqueWithoutCustomersInput | billReceivedUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: billReceivedUpdateManyWithWhereWithoutCustomersInput | billReceivedUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
  }

  export type receiptVoucherUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<receiptVoucherCreateWithoutCustomersInput, receiptVoucherUncheckedCreateWithoutCustomersInput> | receiptVoucherCreateWithoutCustomersInput[] | receiptVoucherUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutCustomersInput | receiptVoucherCreateOrConnectWithoutCustomersInput[]
    upsert?: receiptVoucherUpsertWithWhereUniqueWithoutCustomersInput | receiptVoucherUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: receiptVoucherCreateManyCustomersInputEnvelope
    set?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    disconnect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    delete?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    update?: receiptVoucherUpdateWithWhereUniqueWithoutCustomersInput | receiptVoucherUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: receiptVoucherUpdateManyWithWhereWithoutCustomersInput | receiptVoucherUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: receiptVoucherScalarWhereInput | receiptVoucherScalarWhereInput[]
  }

  export type customerBillBalanceUncheckedUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<customerBillBalanceCreateWithoutCustomersInput, customerBillBalanceUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customerBillBalanceCreateOrConnectWithoutCustomersInput
    upsert?: customerBillBalanceUpsertWithoutCustomersInput
    disconnect?: customerBillBalanceWhereInput | boolean
    delete?: customerBillBalanceWhereInput | boolean
    connect?: customerBillBalanceWhereUniqueInput
    update?: XOR<XOR<customerBillBalanceUpdateToOneWithWhereWithoutCustomersInput, customerBillBalanceUpdateWithoutCustomersInput>, customerBillBalanceUncheckedUpdateWithoutCustomersInput>
  }

  export type RawgoldStockCreateNestedManyWithoutMasterTouchInput = {
    create?: XOR<RawgoldStockCreateWithoutMasterTouchInput, RawgoldStockUncheckedCreateWithoutMasterTouchInput> | RawgoldStockCreateWithoutMasterTouchInput[] | RawgoldStockUncheckedCreateWithoutMasterTouchInput[]
    connectOrCreate?: RawgoldStockCreateOrConnectWithoutMasterTouchInput | RawgoldStockCreateOrConnectWithoutMasterTouchInput[]
    createMany?: RawgoldStockCreateManyMasterTouchInputEnvelope
    connect?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
  }

  export type RawgoldStockUncheckedCreateNestedManyWithoutMasterTouchInput = {
    create?: XOR<RawgoldStockCreateWithoutMasterTouchInput, RawgoldStockUncheckedCreateWithoutMasterTouchInput> | RawgoldStockCreateWithoutMasterTouchInput[] | RawgoldStockUncheckedCreateWithoutMasterTouchInput[]
    connectOrCreate?: RawgoldStockCreateOrConnectWithoutMasterTouchInput | RawgoldStockCreateOrConnectWithoutMasterTouchInput[]
    createMany?: RawgoldStockCreateManyMasterTouchInputEnvelope
    connect?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RawgoldStockUpdateManyWithoutMasterTouchNestedInput = {
    create?: XOR<RawgoldStockCreateWithoutMasterTouchInput, RawgoldStockUncheckedCreateWithoutMasterTouchInput> | RawgoldStockCreateWithoutMasterTouchInput[] | RawgoldStockUncheckedCreateWithoutMasterTouchInput[]
    connectOrCreate?: RawgoldStockCreateOrConnectWithoutMasterTouchInput | RawgoldStockCreateOrConnectWithoutMasterTouchInput[]
    upsert?: RawgoldStockUpsertWithWhereUniqueWithoutMasterTouchInput | RawgoldStockUpsertWithWhereUniqueWithoutMasterTouchInput[]
    createMany?: RawgoldStockCreateManyMasterTouchInputEnvelope
    set?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    disconnect?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    delete?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    connect?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    update?: RawgoldStockUpdateWithWhereUniqueWithoutMasterTouchInput | RawgoldStockUpdateWithWhereUniqueWithoutMasterTouchInput[]
    updateMany?: RawgoldStockUpdateManyWithWhereWithoutMasterTouchInput | RawgoldStockUpdateManyWithWhereWithoutMasterTouchInput[]
    deleteMany?: RawgoldStockScalarWhereInput | RawgoldStockScalarWhereInput[]
  }

  export type RawgoldStockUncheckedUpdateManyWithoutMasterTouchNestedInput = {
    create?: XOR<RawgoldStockCreateWithoutMasterTouchInput, RawgoldStockUncheckedCreateWithoutMasterTouchInput> | RawgoldStockCreateWithoutMasterTouchInput[] | RawgoldStockUncheckedCreateWithoutMasterTouchInput[]
    connectOrCreate?: RawgoldStockCreateOrConnectWithoutMasterTouchInput | RawgoldStockCreateOrConnectWithoutMasterTouchInput[]
    upsert?: RawgoldStockUpsertWithWhereUniqueWithoutMasterTouchInput | RawgoldStockUpsertWithWhereUniqueWithoutMasterTouchInput[]
    createMany?: RawgoldStockCreateManyMasterTouchInputEnvelope
    set?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    disconnect?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    delete?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    connect?: RawgoldStockWhereUniqueInput | RawgoldStockWhereUniqueInput[]
    update?: RawgoldStockUpdateWithWhereUniqueWithoutMasterTouchInput | RawgoldStockUpdateWithWhereUniqueWithoutMasterTouchInput[]
    updateMany?: RawgoldStockUpdateManyWithWhereWithoutMasterTouchInput | RawgoldStockUpdateManyWithWhereWithoutMasterTouchInput[]
    deleteMany?: RawgoldStockScalarWhereInput | RawgoldStockScalarWhereInput[]
  }

  export type RawGoldLogsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<RawGoldLogsCreateWithoutTransactionsInput, RawGoldLogsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutTransactionsInput
    connect?: RawGoldLogsWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RawGoldLogsUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutTransactionsInput, RawGoldLogsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutTransactionsInput
    upsert?: RawGoldLogsUpsertWithoutTransactionsInput
    disconnect?: RawGoldLogsWhereInput | boolean
    delete?: RawGoldLogsWhereInput | boolean
    connect?: RawGoldLogsWhereUniqueInput
    update?: XOR<XOR<RawGoldLogsUpdateToOneWithWhereWithoutTransactionsInput, RawGoldLogsUpdateWithoutTransactionsInput>, RawGoldLogsUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerCreateNestedOneWithoutCustomerOrdersInput = {
    create?: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type product_multiple_imagesCreateNestedManyWithoutCustomerOrderDetailsInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
  }

  export type product_multiple_imagesUncheckedCreateNestedManyWithoutCustomerOrderDetailsInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneRequiredWithoutCustomerOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerOrdersInput
    upsert?: CustomerUpsertWithoutCustomerOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerOrdersInput, CustomerUpdateWithoutCustomerOrdersInput>, CustomerUncheckedUpdateWithoutCustomerOrdersInput>
  }

  export type product_multiple_imagesUpdateManyWithoutCustomerOrderDetailsNestedInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    upsert?: product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    set?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    disconnect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    delete?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    update?: product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    updateMany?: product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput[]
    deleteMany?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
  }

  export type product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsNestedInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    upsert?: product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    set?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    disconnect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    delete?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    update?: product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    updateMany?: product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput[]
    deleteMany?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
  }

  export type customer_orderCreateNestedOneWithoutProductImagesInput = {
    create?: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: customer_orderCreateOrConnectWithoutProductImagesInput
    connect?: customer_orderWhereUniqueInput
  }

  export type customer_orderUpdateOneRequiredWithoutProductImagesNestedInput = {
    create?: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: customer_orderCreateOrConnectWithoutProductImagesInput
    upsert?: customer_orderUpsertWithoutProductImagesInput
    connect?: customer_orderWhereUniqueInput
    update?: XOR<XOR<customer_orderUpdateToOneWithWhereWithoutProductImagesInput, customer_orderUpdateWithoutProductImagesInput>, customer_orderUncheckedUpdateWithoutProductImagesInput>
  }

  export type BullionPurchaseCreateNestedManyWithoutBullionInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
  }

  export type BullionPurchaseUncheckedCreateNestedManyWithoutBullionInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
  }

  export type BullionPurchaseUpdateManyWithoutBullionNestedInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    upsert?: BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput | BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    set?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    disconnect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    delete?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    update?: BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput | BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput[]
    updateMany?: BullionPurchaseUpdateManyWithWhereWithoutBullionInput | BullionPurchaseUpdateManyWithWhereWithoutBullionInput[]
    deleteMany?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
  }

  export type BullionPurchaseUncheckedUpdateManyWithoutBullionNestedInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    upsert?: BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput | BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    set?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    disconnect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    delete?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    update?: BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput | BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput[]
    updateMany?: BullionPurchaseUpdateManyWithWhereWithoutBullionInput | BullionPurchaseUpdateManyWithWhereWithoutBullionInput[]
    deleteMany?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
  }

  export type MasterBullionCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: MasterBullionCreateOrConnectWithoutPurchasesInput
    connect?: MasterBullionWhereUniqueInput
  }

  export type GivenDetailCreateNestedManyWithoutBullionPurchaseInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
  }

  export type GivenDetailUncheckedCreateNestedManyWithoutBullionPurchaseInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
  }

  export type MasterBullionUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: MasterBullionCreateOrConnectWithoutPurchasesInput
    upsert?: MasterBullionUpsertWithoutPurchasesInput
    connect?: MasterBullionWhereUniqueInput
    update?: XOR<XOR<MasterBullionUpdateToOneWithWhereWithoutPurchasesInput, MasterBullionUpdateWithoutPurchasesInput>, MasterBullionUncheckedUpdateWithoutPurchasesInput>
  }

  export type GivenDetailUpdateManyWithoutBullionPurchaseNestedInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    upsert?: GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    set?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    disconnect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    delete?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    update?: GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput[]
    updateMany?: GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput | GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput[]
    deleteMany?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
  }

  export type GivenDetailUncheckedUpdateManyWithoutBullionPurchaseNestedInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    upsert?: GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    set?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    disconnect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    delete?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    update?: GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput[]
    updateMany?: GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput | GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput[]
    deleteMany?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
  }

  export type BullionPurchaseCreateNestedOneWithoutGivenDetailsInput = {
    create?: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutGivenDetailsInput
    connect?: BullionPurchaseWhereUniqueInput
  }

  export type BullionPurchaseUpdateOneRequiredWithoutGivenDetailsNestedInput = {
    create?: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutGivenDetailsInput
    upsert?: BullionPurchaseUpsertWithoutGivenDetailsInput
    connect?: BullionPurchaseWhereUniqueInput
    update?: XOR<XOR<BullionPurchaseUpdateToOneWithWhereWithoutGivenDetailsInput, BullionPurchaseUpdateWithoutGivenDetailsInput>, BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput>
  }

  export type JobcardCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
  }

  export type givenGoldCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type TotalCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
  }

  export type RepairCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
  }

  export type BalancesCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
  }

  export type JobcardUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
  }

  export type givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type TotalUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
  }

  export type RepairUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
  }

  export type BalancesUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
  }

  export type JobcardUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    upsert?: JobcardUpsertWithWhereUniqueWithoutGoldsmithInput | JobcardUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    set?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    disconnect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    delete?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    update?: JobcardUpdateWithWhereUniqueWithoutGoldsmithInput | JobcardUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: JobcardUpdateManyWithWhereWithoutGoldsmithInput | JobcardUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
  }

  export type givenGoldUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput | givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput | givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutGoldsmithInput | givenGoldUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput | itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput | ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type TotalUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    upsert?: TotalUpsertWithWhereUniqueWithoutGoldsmithInput | TotalUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    set?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    disconnect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    delete?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    update?: TotalUpdateWithWhereUniqueWithoutGoldsmithInput | TotalUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: TotalUpdateManyWithWhereWithoutGoldsmithInput | TotalUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: TotalScalarWhereInput | TotalScalarWhereInput[]
  }

  export type RepairUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    upsert?: RepairUpsertWithWhereUniqueWithoutGoldsmithInput | RepairUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    set?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    disconnect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    delete?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    update?: RepairUpdateWithWhereUniqueWithoutGoldsmithInput | RepairUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: RepairUpdateManyWithWhereWithoutGoldsmithInput | RepairUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: RepairScalarWhereInput | RepairScalarWhereInput[]
  }

  export type BalancesUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    upsert?: BalancesUpsertWithWhereUniqueWithoutGoldsmithInput | BalancesUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    set?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    disconnect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    delete?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    update?: BalancesUpdateWithWhereUniqueWithoutGoldsmithInput | BalancesUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: BalancesUpdateManyWithWhereWithoutGoldsmithInput | BalancesUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
  }

  export type JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    upsert?: JobcardUpsertWithWhereUniqueWithoutGoldsmithInput | JobcardUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    set?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    disconnect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    delete?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    update?: JobcardUpdateWithWhereUniqueWithoutGoldsmithInput | JobcardUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: JobcardUpdateManyWithWhereWithoutGoldsmithInput | JobcardUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
  }

  export type givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput | givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput | givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutGoldsmithInput | givenGoldUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput | itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput | ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type TotalUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    upsert?: TotalUpsertWithWhereUniqueWithoutGoldsmithInput | TotalUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    set?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    disconnect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    delete?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    update?: TotalUpdateWithWhereUniqueWithoutGoldsmithInput | TotalUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: TotalUpdateManyWithWhereWithoutGoldsmithInput | TotalUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: TotalScalarWhereInput | TotalScalarWhereInput[]
  }

  export type RepairUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    upsert?: RepairUpsertWithWhereUniqueWithoutGoldsmithInput | RepairUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    set?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    disconnect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    delete?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    update?: RepairUpdateWithWhereUniqueWithoutGoldsmithInput | RepairUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: RepairUpdateManyWithWhereWithoutGoldsmithInput | RepairUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: RepairScalarWhereInput | RepairScalarWhereInput[]
  }

  export type BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    upsert?: BalancesUpsertWithWhereUniqueWithoutGoldsmithInput | BalancesUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    set?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    disconnect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    delete?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    update?: BalancesUpdateWithWhereUniqueWithoutGoldsmithInput | BalancesUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: BalancesUpdateManyWithWhereWithoutGoldsmithInput | BalancesUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
  }

  export type GoldsmithCreateNestedOneWithoutJobcardsInput = {
    create?: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutJobcardsInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type givenGoldCreateNestedManyWithoutJobcardInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryCreateNestedManyWithoutJobcardInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionCreateNestedManyWithoutJobcardInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type ProductStockCreateNestedManyWithoutJobcardInput = {
    create?: XOR<ProductStockCreateWithoutJobcardInput, ProductStockUncheckedCreateWithoutJobcardInput> | ProductStockCreateWithoutJobcardInput[] | ProductStockUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutJobcardInput | ProductStockCreateOrConnectWithoutJobcardInput[]
    createMany?: ProductStockCreateManyJobcardInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type TotalCreateNestedManyWithoutJobcardInput = {
    create?: XOR<TotalCreateWithoutJobcardInput, TotalUncheckedCreateWithoutJobcardInput> | TotalCreateWithoutJobcardInput[] | TotalUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutJobcardInput | TotalCreateOrConnectWithoutJobcardInput[]
    createMany?: TotalCreateManyJobcardInputEnvelope
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
  }

  export type givenGoldUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type ProductStockUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<ProductStockCreateWithoutJobcardInput, ProductStockUncheckedCreateWithoutJobcardInput> | ProductStockCreateWithoutJobcardInput[] | ProductStockUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutJobcardInput | ProductStockCreateOrConnectWithoutJobcardInput[]
    createMany?: ProductStockCreateManyJobcardInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type TotalUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<TotalCreateWithoutJobcardInput, TotalUncheckedCreateWithoutJobcardInput> | TotalCreateWithoutJobcardInput[] | TotalUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutJobcardInput | TotalCreateOrConnectWithoutJobcardInput[]
    createMany?: TotalCreateManyJobcardInputEnvelope
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput = {
    create?: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutJobcardsInput
    upsert?: GoldsmithUpsertWithoutJobcardsInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutJobcardsInput, GoldsmithUpdateWithoutJobcardsInput>, GoldsmithUncheckedUpdateWithoutJobcardsInput>
  }

  export type givenGoldUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutJobcardInput | givenGoldUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutJobcardInput | givenGoldUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutJobcardInput | givenGoldUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput | itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput | itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutJobcardInput | itemDeliveryUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutJobcardInput | ReceivedsectionUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type ProductStockUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<ProductStockCreateWithoutJobcardInput, ProductStockUncheckedCreateWithoutJobcardInput> | ProductStockCreateWithoutJobcardInput[] | ProductStockUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutJobcardInput | ProductStockCreateOrConnectWithoutJobcardInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutJobcardInput | ProductStockUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: ProductStockCreateManyJobcardInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutJobcardInput | ProductStockUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutJobcardInput | ProductStockUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type TotalUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<TotalCreateWithoutJobcardInput, TotalUncheckedCreateWithoutJobcardInput> | TotalCreateWithoutJobcardInput[] | TotalUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutJobcardInput | TotalCreateOrConnectWithoutJobcardInput[]
    upsert?: TotalUpsertWithWhereUniqueWithoutJobcardInput | TotalUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: TotalCreateManyJobcardInputEnvelope
    set?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    disconnect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    delete?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    update?: TotalUpdateWithWhereUniqueWithoutJobcardInput | TotalUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: TotalUpdateManyWithWhereWithoutJobcardInput | TotalUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: TotalScalarWhereInput | TotalScalarWhereInput[]
  }

  export type givenGoldUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutJobcardInput | givenGoldUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutJobcardInput | givenGoldUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutJobcardInput | givenGoldUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput | itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput | itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutJobcardInput | itemDeliveryUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutJobcardInput | ReceivedsectionUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type ProductStockUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<ProductStockCreateWithoutJobcardInput, ProductStockUncheckedCreateWithoutJobcardInput> | ProductStockCreateWithoutJobcardInput[] | ProductStockUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutJobcardInput | ProductStockCreateOrConnectWithoutJobcardInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutJobcardInput | ProductStockUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: ProductStockCreateManyJobcardInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutJobcardInput | ProductStockUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutJobcardInput | ProductStockUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type TotalUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<TotalCreateWithoutJobcardInput, TotalUncheckedCreateWithoutJobcardInput> | TotalCreateWithoutJobcardInput[] | TotalUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutJobcardInput | TotalCreateOrConnectWithoutJobcardInput[]
    upsert?: TotalUpsertWithWhereUniqueWithoutJobcardInput | TotalUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: TotalCreateManyJobcardInputEnvelope
    set?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    disconnect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    delete?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    update?: TotalUpdateWithWhereUniqueWithoutJobcardInput | TotalUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: TotalUpdateManyWithWhereWithoutJobcardInput | TotalUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: TotalScalarWhereInput | TotalScalarWhereInput[]
  }

  export type GoldsmithCreateNestedOneWithoutGivenGoldInput = {
    create?: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutGivenGoldInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type JobcardCreateNestedOneWithoutGivenGoldInput = {
    create?: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutGivenGoldInput
    connect?: JobcardWhereUniqueInput
  }

  export type RawGoldLogsCreateNestedOneWithoutGivenGoldInput = {
    create?: XOR<RawGoldLogsCreateWithoutGivenGoldInput, RawGoldLogsUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutGivenGoldInput
    connect?: RawGoldLogsWhereUniqueInput
  }

  export type GoldsmithUpdateOneWithoutGivenGoldNestedInput = {
    create?: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutGivenGoldInput
    upsert?: GoldsmithUpsertWithoutGivenGoldInput
    disconnect?: GoldsmithWhereInput | boolean
    delete?: GoldsmithWhereInput | boolean
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutGivenGoldInput, GoldsmithUpdateWithoutGivenGoldInput>, GoldsmithUncheckedUpdateWithoutGivenGoldInput>
  }

  export type JobcardUpdateOneWithoutGivenGoldNestedInput = {
    create?: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutGivenGoldInput
    upsert?: JobcardUpsertWithoutGivenGoldInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutGivenGoldInput, JobcardUpdateWithoutGivenGoldInput>, JobcardUncheckedUpdateWithoutGivenGoldInput>
  }

  export type RawGoldLogsUpdateOneWithoutGivenGoldNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutGivenGoldInput, RawGoldLogsUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutGivenGoldInput
    upsert?: RawGoldLogsUpsertWithoutGivenGoldInput
    disconnect?: RawGoldLogsWhereInput | boolean
    delete?: RawGoldLogsWhereInput | boolean
    connect?: RawGoldLogsWhereUniqueInput
    update?: XOR<XOR<RawGoldLogsUpdateToOneWithWhereWithoutGivenGoldInput, RawGoldLogsUpdateWithoutGivenGoldInput>, RawGoldLogsUncheckedUpdateWithoutGivenGoldInput>
  }

  export type GoldsmithCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutDeliveriesInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type JobcardCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutDeliveriesInput
    connect?: JobcardWhereUniqueInput
  }

  export type deductionCreateNestedManyWithoutItemDeliveryInput = {
    create?: XOR<deductionCreateWithoutItemDeliveryInput, deductionUncheckedCreateWithoutItemDeliveryInput> | deductionCreateWithoutItemDeliveryInput[] | deductionUncheckedCreateWithoutItemDeliveryInput[]
    connectOrCreate?: deductionCreateOrConnectWithoutItemDeliveryInput | deductionCreateOrConnectWithoutItemDeliveryInput[]
    createMany?: deductionCreateManyItemDeliveryInputEnvelope
    connect?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
  }

  export type deductionUncheckedCreateNestedManyWithoutItemDeliveryInput = {
    create?: XOR<deductionCreateWithoutItemDeliveryInput, deductionUncheckedCreateWithoutItemDeliveryInput> | deductionCreateWithoutItemDeliveryInput[] | deductionUncheckedCreateWithoutItemDeliveryInput[]
    connectOrCreate?: deductionCreateOrConnectWithoutItemDeliveryInput | deductionCreateOrConnectWithoutItemDeliveryInput[]
    createMany?: deductionCreateManyItemDeliveryInputEnvelope
    connect?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
  }

  export type GoldsmithUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutDeliveriesInput
    upsert?: GoldsmithUpsertWithoutDeliveriesInput
    disconnect?: GoldsmithWhereInput | boolean
    delete?: GoldsmithWhereInput | boolean
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutDeliveriesInput, GoldsmithUpdateWithoutDeliveriesInput>, GoldsmithUncheckedUpdateWithoutDeliveriesInput>
  }

  export type JobcardUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutDeliveriesInput
    upsert?: JobcardUpsertWithoutDeliveriesInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutDeliveriesInput, JobcardUpdateWithoutDeliveriesInput>, JobcardUncheckedUpdateWithoutDeliveriesInput>
  }

  export type deductionUpdateManyWithoutItemDeliveryNestedInput = {
    create?: XOR<deductionCreateWithoutItemDeliveryInput, deductionUncheckedCreateWithoutItemDeliveryInput> | deductionCreateWithoutItemDeliveryInput[] | deductionUncheckedCreateWithoutItemDeliveryInput[]
    connectOrCreate?: deductionCreateOrConnectWithoutItemDeliveryInput | deductionCreateOrConnectWithoutItemDeliveryInput[]
    upsert?: deductionUpsertWithWhereUniqueWithoutItemDeliveryInput | deductionUpsertWithWhereUniqueWithoutItemDeliveryInput[]
    createMany?: deductionCreateManyItemDeliveryInputEnvelope
    set?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    disconnect?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    delete?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    connect?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    update?: deductionUpdateWithWhereUniqueWithoutItemDeliveryInput | deductionUpdateWithWhereUniqueWithoutItemDeliveryInput[]
    updateMany?: deductionUpdateManyWithWhereWithoutItemDeliveryInput | deductionUpdateManyWithWhereWithoutItemDeliveryInput[]
    deleteMany?: deductionScalarWhereInput | deductionScalarWhereInput[]
  }

  export type deductionUncheckedUpdateManyWithoutItemDeliveryNestedInput = {
    create?: XOR<deductionCreateWithoutItemDeliveryInput, deductionUncheckedCreateWithoutItemDeliveryInput> | deductionCreateWithoutItemDeliveryInput[] | deductionUncheckedCreateWithoutItemDeliveryInput[]
    connectOrCreate?: deductionCreateOrConnectWithoutItemDeliveryInput | deductionCreateOrConnectWithoutItemDeliveryInput[]
    upsert?: deductionUpsertWithWhereUniqueWithoutItemDeliveryInput | deductionUpsertWithWhereUniqueWithoutItemDeliveryInput[]
    createMany?: deductionCreateManyItemDeliveryInputEnvelope
    set?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    disconnect?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    delete?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    connect?: deductionWhereUniqueInput | deductionWhereUniqueInput[]
    update?: deductionUpdateWithWhereUniqueWithoutItemDeliveryInput | deductionUpdateWithWhereUniqueWithoutItemDeliveryInput[]
    updateMany?: deductionUpdateManyWithWhereWithoutItemDeliveryInput | deductionUpdateManyWithWhereWithoutItemDeliveryInput[]
    deleteMany?: deductionScalarWhereInput | deductionScalarWhereInput[]
  }

  export type itemDeliveryCreateNestedOneWithoutDeductionInput = {
    create?: XOR<itemDeliveryCreateWithoutDeductionInput, itemDeliveryUncheckedCreateWithoutDeductionInput>
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutDeductionInput
    connect?: itemDeliveryWhereUniqueInput
  }

  export type itemDeliveryUpdateOneRequiredWithoutDeductionNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutDeductionInput, itemDeliveryUncheckedCreateWithoutDeductionInput>
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutDeductionInput
    upsert?: itemDeliveryUpsertWithoutDeductionInput
    connect?: itemDeliveryWhereUniqueInput
    update?: XOR<XOR<itemDeliveryUpdateToOneWithWhereWithoutDeductionInput, itemDeliveryUpdateWithoutDeductionInput>, itemDeliveryUncheckedUpdateWithoutDeductionInput>
  }

  export type JobcardCreateNestedOneWithoutTotalInput = {
    create?: XOR<JobcardCreateWithoutTotalInput, JobcardUncheckedCreateWithoutTotalInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutTotalInput
    connect?: JobcardWhereUniqueInput
  }

  export type GoldsmithCreateNestedOneWithoutTotalsInput = {
    create?: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutTotalsInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type JobcardUpdateOneWithoutTotalNestedInput = {
    create?: XOR<JobcardCreateWithoutTotalInput, JobcardUncheckedCreateWithoutTotalInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutTotalInput
    upsert?: JobcardUpsertWithoutTotalInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutTotalInput, JobcardUpdateWithoutTotalInput>, JobcardUncheckedUpdateWithoutTotalInput>
  }

  export type GoldsmithUpdateOneRequiredWithoutTotalsNestedInput = {
    create?: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutTotalsInput
    upsert?: GoldsmithUpsertWithoutTotalsInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutTotalsInput, GoldsmithUpdateWithoutTotalsInput>, GoldsmithUncheckedUpdateWithoutTotalsInput>
  }

  export type RawGoldLogsCreateNestedOneWithoutReceivedSectionsInput = {
    create?: XOR<RawGoldLogsCreateWithoutReceivedSectionsInput, RawGoldLogsUncheckedCreateWithoutReceivedSectionsInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutReceivedSectionsInput
    connect?: RawGoldLogsWhereUniqueInput
  }

  export type JobcardCreateNestedOneWithoutReceivedInput = {
    create?: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutReceivedInput
    connect?: JobcardWhereUniqueInput
  }

  export type GoldsmithCreateNestedOneWithoutReceivedInput = {
    create?: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutReceivedInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type RawGoldLogsUpdateOneWithoutReceivedSectionsNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutReceivedSectionsInput, RawGoldLogsUncheckedCreateWithoutReceivedSectionsInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutReceivedSectionsInput
    upsert?: RawGoldLogsUpsertWithoutReceivedSectionsInput
    disconnect?: RawGoldLogsWhereInput | boolean
    delete?: RawGoldLogsWhereInput | boolean
    connect?: RawGoldLogsWhereUniqueInput
    update?: XOR<XOR<RawGoldLogsUpdateToOneWithWhereWithoutReceivedSectionsInput, RawGoldLogsUpdateWithoutReceivedSectionsInput>, RawGoldLogsUncheckedUpdateWithoutReceivedSectionsInput>
  }

  export type JobcardUpdateOneWithoutReceivedNestedInput = {
    create?: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutReceivedInput
    upsert?: JobcardUpsertWithoutReceivedInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutReceivedInput, JobcardUpdateWithoutReceivedInput>, JobcardUncheckedUpdateWithoutReceivedInput>
  }

  export type GoldsmithUpdateOneWithoutReceivedNestedInput = {
    create?: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutReceivedInput
    upsert?: GoldsmithUpsertWithoutReceivedInput
    disconnect?: GoldsmithWhereInput | boolean
    delete?: GoldsmithWhereInput | boolean
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutReceivedInput, GoldsmithUpdateWithoutReceivedInput>, GoldsmithUncheckedUpdateWithoutReceivedInput>
  }

  export type MasterTouchCreateNestedOneWithoutRawGoldStockInput = {
    create?: XOR<MasterTouchCreateWithoutRawGoldStockInput, MasterTouchUncheckedCreateWithoutRawGoldStockInput>
    connectOrCreate?: MasterTouchCreateOrConnectWithoutRawGoldStockInput
    connect?: MasterTouchWhereUniqueInput
  }

  export type RawGoldLogsCreateNestedManyWithoutRawGoldStockInput = {
    create?: XOR<RawGoldLogsCreateWithoutRawGoldStockInput, RawGoldLogsUncheckedCreateWithoutRawGoldStockInput> | RawGoldLogsCreateWithoutRawGoldStockInput[] | RawGoldLogsUncheckedCreateWithoutRawGoldStockInput[]
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutRawGoldStockInput | RawGoldLogsCreateOrConnectWithoutRawGoldStockInput[]
    createMany?: RawGoldLogsCreateManyRawGoldStockInputEnvelope
    connect?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
  }

  export type RawGoldLogsUncheckedCreateNestedManyWithoutRawGoldStockInput = {
    create?: XOR<RawGoldLogsCreateWithoutRawGoldStockInput, RawGoldLogsUncheckedCreateWithoutRawGoldStockInput> | RawGoldLogsCreateWithoutRawGoldStockInput[] | RawGoldLogsUncheckedCreateWithoutRawGoldStockInput[]
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutRawGoldStockInput | RawGoldLogsCreateOrConnectWithoutRawGoldStockInput[]
    createMany?: RawGoldLogsCreateManyRawGoldStockInputEnvelope
    connect?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
  }

  export type MasterTouchUpdateOneWithoutRawGoldStockNestedInput = {
    create?: XOR<MasterTouchCreateWithoutRawGoldStockInput, MasterTouchUncheckedCreateWithoutRawGoldStockInput>
    connectOrCreate?: MasterTouchCreateOrConnectWithoutRawGoldStockInput
    upsert?: MasterTouchUpsertWithoutRawGoldStockInput
    disconnect?: MasterTouchWhereInput | boolean
    delete?: MasterTouchWhereInput | boolean
    connect?: MasterTouchWhereUniqueInput
    update?: XOR<XOR<MasterTouchUpdateToOneWithWhereWithoutRawGoldStockInput, MasterTouchUpdateWithoutRawGoldStockInput>, MasterTouchUncheckedUpdateWithoutRawGoldStockInput>
  }

  export type RawGoldLogsUpdateManyWithoutRawGoldStockNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutRawGoldStockInput, RawGoldLogsUncheckedCreateWithoutRawGoldStockInput> | RawGoldLogsCreateWithoutRawGoldStockInput[] | RawGoldLogsUncheckedCreateWithoutRawGoldStockInput[]
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutRawGoldStockInput | RawGoldLogsCreateOrConnectWithoutRawGoldStockInput[]
    upsert?: RawGoldLogsUpsertWithWhereUniqueWithoutRawGoldStockInput | RawGoldLogsUpsertWithWhereUniqueWithoutRawGoldStockInput[]
    createMany?: RawGoldLogsCreateManyRawGoldStockInputEnvelope
    set?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    disconnect?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    delete?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    connect?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    update?: RawGoldLogsUpdateWithWhereUniqueWithoutRawGoldStockInput | RawGoldLogsUpdateWithWhereUniqueWithoutRawGoldStockInput[]
    updateMany?: RawGoldLogsUpdateManyWithWhereWithoutRawGoldStockInput | RawGoldLogsUpdateManyWithWhereWithoutRawGoldStockInput[]
    deleteMany?: RawGoldLogsScalarWhereInput | RawGoldLogsScalarWhereInput[]
  }

  export type RawGoldLogsUncheckedUpdateManyWithoutRawGoldStockNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutRawGoldStockInput, RawGoldLogsUncheckedCreateWithoutRawGoldStockInput> | RawGoldLogsCreateWithoutRawGoldStockInput[] | RawGoldLogsUncheckedCreateWithoutRawGoldStockInput[]
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutRawGoldStockInput | RawGoldLogsCreateOrConnectWithoutRawGoldStockInput[]
    upsert?: RawGoldLogsUpsertWithWhereUniqueWithoutRawGoldStockInput | RawGoldLogsUpsertWithWhereUniqueWithoutRawGoldStockInput[]
    createMany?: RawGoldLogsCreateManyRawGoldStockInputEnvelope
    set?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    disconnect?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    delete?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    connect?: RawGoldLogsWhereUniqueInput | RawGoldLogsWhereUniqueInput[]
    update?: RawGoldLogsUpdateWithWhereUniqueWithoutRawGoldStockInput | RawGoldLogsUpdateWithWhereUniqueWithoutRawGoldStockInput[]
    updateMany?: RawGoldLogsUpdateManyWithWhereWithoutRawGoldStockInput | RawGoldLogsUpdateManyWithWhereWithoutRawGoldStockInput[]
    deleteMany?: RawGoldLogsScalarWhereInput | RawGoldLogsScalarWhereInput[]
  }

  export type RawgoldStockCreateNestedOneWithoutRawGoldLogsInput = {
    create?: XOR<RawgoldStockCreateWithoutRawGoldLogsInput, RawgoldStockUncheckedCreateWithoutRawGoldLogsInput>
    connectOrCreate?: RawgoldStockCreateOrConnectWithoutRawGoldLogsInput
    connect?: RawgoldStockWhereUniqueInput
  }

  export type givenGoldCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<givenGoldCreateWithoutRawGoldLogsInput, givenGoldUncheckedCreateWithoutRawGoldLogsInput> | givenGoldCreateWithoutRawGoldLogsInput[] | givenGoldUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutRawGoldLogsInput | givenGoldCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: givenGoldCreateManyRawGoldLogsInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<ReceivedsectionCreateWithoutRawGoldLogsInput, ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput> | ReceivedsectionCreateWithoutRawGoldLogsInput[] | ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput | ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: ReceivedsectionCreateManyRawGoldLogsInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type billReceivedCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<billReceivedCreateWithoutRawGoldLogsInput, billReceivedUncheckedCreateWithoutRawGoldLogsInput> | billReceivedCreateWithoutRawGoldLogsInput[] | billReceivedUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutRawGoldLogsInput | billReceivedCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: billReceivedCreateManyRawGoldLogsInputEnvelope
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
  }

  export type receiptVoucherCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<receiptVoucherCreateWithoutRawGoldLogsInput, receiptVoucherUncheckedCreateWithoutRawGoldLogsInput> | receiptVoucherCreateWithoutRawGoldLogsInput[] | receiptVoucherUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutRawGoldLogsInput | receiptVoucherCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: receiptVoucherCreateManyRawGoldLogsInputEnvelope
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<TransactionCreateWithoutRawGoldLogsInput, TransactionUncheckedCreateWithoutRawGoldLogsInput> | TransactionCreateWithoutRawGoldLogsInput[] | TransactionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRawGoldLogsInput | TransactionCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: TransactionCreateManyRawGoldLogsInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<ExpenseTrackerCreateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput> | ExpenseTrackerCreateWithoutRawGoldLogsInput[] | ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput | ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: ExpenseTrackerCreateManyRawGoldLogsInputEnvelope
    connect?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
  }

  export type givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<givenGoldCreateWithoutRawGoldLogsInput, givenGoldUncheckedCreateWithoutRawGoldLogsInput> | givenGoldCreateWithoutRawGoldLogsInput[] | givenGoldUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutRawGoldLogsInput | givenGoldCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: givenGoldCreateManyRawGoldLogsInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<ReceivedsectionCreateWithoutRawGoldLogsInput, ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput> | ReceivedsectionCreateWithoutRawGoldLogsInput[] | ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput | ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: ReceivedsectionCreateManyRawGoldLogsInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<billReceivedCreateWithoutRawGoldLogsInput, billReceivedUncheckedCreateWithoutRawGoldLogsInput> | billReceivedCreateWithoutRawGoldLogsInput[] | billReceivedUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutRawGoldLogsInput | billReceivedCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: billReceivedCreateManyRawGoldLogsInputEnvelope
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
  }

  export type receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<receiptVoucherCreateWithoutRawGoldLogsInput, receiptVoucherUncheckedCreateWithoutRawGoldLogsInput> | receiptVoucherCreateWithoutRawGoldLogsInput[] | receiptVoucherUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutRawGoldLogsInput | receiptVoucherCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: receiptVoucherCreateManyRawGoldLogsInputEnvelope
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<TransactionCreateWithoutRawGoldLogsInput, TransactionUncheckedCreateWithoutRawGoldLogsInput> | TransactionCreateWithoutRawGoldLogsInput[] | TransactionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRawGoldLogsInput | TransactionCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: TransactionCreateManyRawGoldLogsInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput = {
    create?: XOR<ExpenseTrackerCreateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput> | ExpenseTrackerCreateWithoutRawGoldLogsInput[] | ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput | ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput[]
    createMany?: ExpenseTrackerCreateManyRawGoldLogsInputEnvelope
    connect?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
  }

  export type RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput = {
    create?: XOR<RawgoldStockCreateWithoutRawGoldLogsInput, RawgoldStockUncheckedCreateWithoutRawGoldLogsInput>
    connectOrCreate?: RawgoldStockCreateOrConnectWithoutRawGoldLogsInput
    upsert?: RawgoldStockUpsertWithoutRawGoldLogsInput
    disconnect?: RawgoldStockWhereInput | boolean
    delete?: RawgoldStockWhereInput | boolean
    connect?: RawgoldStockWhereUniqueInput
    update?: XOR<XOR<RawgoldStockUpdateToOneWithWhereWithoutRawGoldLogsInput, RawgoldStockUpdateWithoutRawGoldLogsInput>, RawgoldStockUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type givenGoldUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<givenGoldCreateWithoutRawGoldLogsInput, givenGoldUncheckedCreateWithoutRawGoldLogsInput> | givenGoldCreateWithoutRawGoldLogsInput[] | givenGoldUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutRawGoldLogsInput | givenGoldCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutRawGoldLogsInput | givenGoldUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: givenGoldCreateManyRawGoldLogsInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutRawGoldLogsInput | givenGoldUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutRawGoldLogsInput | givenGoldUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutRawGoldLogsInput, ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput> | ReceivedsectionCreateWithoutRawGoldLogsInput[] | ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput | ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutRawGoldLogsInput | ReceivedsectionUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: ReceivedsectionCreateManyRawGoldLogsInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutRawGoldLogsInput | ReceivedsectionUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutRawGoldLogsInput | ReceivedsectionUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type billReceivedUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<billReceivedCreateWithoutRawGoldLogsInput, billReceivedUncheckedCreateWithoutRawGoldLogsInput> | billReceivedCreateWithoutRawGoldLogsInput[] | billReceivedUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutRawGoldLogsInput | billReceivedCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: billReceivedUpsertWithWhereUniqueWithoutRawGoldLogsInput | billReceivedUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: billReceivedCreateManyRawGoldLogsInputEnvelope
    set?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    disconnect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    delete?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    update?: billReceivedUpdateWithWhereUniqueWithoutRawGoldLogsInput | billReceivedUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: billReceivedUpdateManyWithWhereWithoutRawGoldLogsInput | billReceivedUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
  }

  export type receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<receiptVoucherCreateWithoutRawGoldLogsInput, receiptVoucherUncheckedCreateWithoutRawGoldLogsInput> | receiptVoucherCreateWithoutRawGoldLogsInput[] | receiptVoucherUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutRawGoldLogsInput | receiptVoucherCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: receiptVoucherUpsertWithWhereUniqueWithoutRawGoldLogsInput | receiptVoucherUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: receiptVoucherCreateManyRawGoldLogsInputEnvelope
    set?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    disconnect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    delete?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    update?: receiptVoucherUpdateWithWhereUniqueWithoutRawGoldLogsInput | receiptVoucherUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: receiptVoucherUpdateManyWithWhereWithoutRawGoldLogsInput | receiptVoucherUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: receiptVoucherScalarWhereInput | receiptVoucherScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<TransactionCreateWithoutRawGoldLogsInput, TransactionUncheckedCreateWithoutRawGoldLogsInput> | TransactionCreateWithoutRawGoldLogsInput[] | TransactionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRawGoldLogsInput | TransactionCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutRawGoldLogsInput | TransactionUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: TransactionCreateManyRawGoldLogsInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutRawGoldLogsInput | TransactionUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutRawGoldLogsInput | TransactionUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<ExpenseTrackerCreateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput> | ExpenseTrackerCreateWithoutRawGoldLogsInput[] | ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput | ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: ExpenseTrackerUpsertWithWhereUniqueWithoutRawGoldLogsInput | ExpenseTrackerUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: ExpenseTrackerCreateManyRawGoldLogsInputEnvelope
    set?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    disconnect?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    delete?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    connect?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    update?: ExpenseTrackerUpdateWithWhereUniqueWithoutRawGoldLogsInput | ExpenseTrackerUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: ExpenseTrackerUpdateManyWithWhereWithoutRawGoldLogsInput | ExpenseTrackerUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: ExpenseTrackerScalarWhereInput | ExpenseTrackerScalarWhereInput[]
  }

  export type givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<givenGoldCreateWithoutRawGoldLogsInput, givenGoldUncheckedCreateWithoutRawGoldLogsInput> | givenGoldCreateWithoutRawGoldLogsInput[] | givenGoldUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutRawGoldLogsInput | givenGoldCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutRawGoldLogsInput | givenGoldUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: givenGoldCreateManyRawGoldLogsInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutRawGoldLogsInput | givenGoldUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutRawGoldLogsInput | givenGoldUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutRawGoldLogsInput, ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput> | ReceivedsectionCreateWithoutRawGoldLogsInput[] | ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput | ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutRawGoldLogsInput | ReceivedsectionUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: ReceivedsectionCreateManyRawGoldLogsInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutRawGoldLogsInput | ReceivedsectionUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutRawGoldLogsInput | ReceivedsectionUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<billReceivedCreateWithoutRawGoldLogsInput, billReceivedUncheckedCreateWithoutRawGoldLogsInput> | billReceivedCreateWithoutRawGoldLogsInput[] | billReceivedUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutRawGoldLogsInput | billReceivedCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: billReceivedUpsertWithWhereUniqueWithoutRawGoldLogsInput | billReceivedUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: billReceivedCreateManyRawGoldLogsInputEnvelope
    set?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    disconnect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    delete?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    update?: billReceivedUpdateWithWhereUniqueWithoutRawGoldLogsInput | billReceivedUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: billReceivedUpdateManyWithWhereWithoutRawGoldLogsInput | billReceivedUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
  }

  export type receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<receiptVoucherCreateWithoutRawGoldLogsInput, receiptVoucherUncheckedCreateWithoutRawGoldLogsInput> | receiptVoucherCreateWithoutRawGoldLogsInput[] | receiptVoucherUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: receiptVoucherCreateOrConnectWithoutRawGoldLogsInput | receiptVoucherCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: receiptVoucherUpsertWithWhereUniqueWithoutRawGoldLogsInput | receiptVoucherUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: receiptVoucherCreateManyRawGoldLogsInputEnvelope
    set?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    disconnect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    delete?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    connect?: receiptVoucherWhereUniqueInput | receiptVoucherWhereUniqueInput[]
    update?: receiptVoucherUpdateWithWhereUniqueWithoutRawGoldLogsInput | receiptVoucherUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: receiptVoucherUpdateManyWithWhereWithoutRawGoldLogsInput | receiptVoucherUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: receiptVoucherScalarWhereInput | receiptVoucherScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<TransactionCreateWithoutRawGoldLogsInput, TransactionUncheckedCreateWithoutRawGoldLogsInput> | TransactionCreateWithoutRawGoldLogsInput[] | TransactionUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRawGoldLogsInput | TransactionCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutRawGoldLogsInput | TransactionUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: TransactionCreateManyRawGoldLogsInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutRawGoldLogsInput | TransactionUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutRawGoldLogsInput | TransactionUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput = {
    create?: XOR<ExpenseTrackerCreateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput> | ExpenseTrackerCreateWithoutRawGoldLogsInput[] | ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput[]
    connectOrCreate?: ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput | ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput[]
    upsert?: ExpenseTrackerUpsertWithWhereUniqueWithoutRawGoldLogsInput | ExpenseTrackerUpsertWithWhereUniqueWithoutRawGoldLogsInput[]
    createMany?: ExpenseTrackerCreateManyRawGoldLogsInputEnvelope
    set?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    disconnect?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    delete?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    connect?: ExpenseTrackerWhereUniqueInput | ExpenseTrackerWhereUniqueInput[]
    update?: ExpenseTrackerUpdateWithWhereUniqueWithoutRawGoldLogsInput | ExpenseTrackerUpdateWithWhereUniqueWithoutRawGoldLogsInput[]
    updateMany?: ExpenseTrackerUpdateManyWithWhereWithoutRawGoldLogsInput | ExpenseTrackerUpdateManyWithWhereWithoutRawGoldLogsInput[]
    deleteMany?: ExpenseTrackerScalarWhereInput | ExpenseTrackerScalarWhereInput[]
  }

  export type RawGoldLogsCreateNestedOneWithoutExpenseTrackerInput = {
    create?: XOR<RawGoldLogsCreateWithoutExpenseTrackerInput, RawGoldLogsUncheckedCreateWithoutExpenseTrackerInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutExpenseTrackerInput
    connect?: RawGoldLogsWhereUniqueInput
  }

  export type RawGoldLogsUpdateOneWithoutExpenseTrackerNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutExpenseTrackerInput, RawGoldLogsUncheckedCreateWithoutExpenseTrackerInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutExpenseTrackerInput
    upsert?: RawGoldLogsUpsertWithoutExpenseTrackerInput
    disconnect?: RawGoldLogsWhereInput | boolean
    delete?: RawGoldLogsWhereInput | boolean
    connect?: RawGoldLogsWhereUniqueInput
    update?: XOR<XOR<RawGoldLogsUpdateToOneWithWhereWithoutExpenseTrackerInput, RawGoldLogsUpdateWithoutExpenseTrackerInput>, RawGoldLogsUncheckedUpdateWithoutExpenseTrackerInput>
  }

  export type GoldsmithCreateNestedOneWithoutSummariesInput = {
    create?: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutSummariesInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type GoldsmithUpdateOneRequiredWithoutSummariesNestedInput = {
    create?: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutSummariesInput
    upsert?: GoldsmithUpsertWithoutSummariesInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutSummariesInput, GoldsmithUpdateWithoutSummariesInput>, GoldsmithUncheckedUpdateWithoutSummariesInput>
  }

  export type GoldsmithCreateNestedOneWithoutRepairsInput = {
    create?: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutRepairsInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type GoldsmithUpdateOneRequiredWithoutRepairsNestedInput = {
    create?: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutRepairsInput
    upsert?: GoldsmithUpsertWithoutRepairsInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutRepairsInput, GoldsmithUpdateWithoutRepairsInput>, GoldsmithUncheckedUpdateWithoutRepairsInput>
  }

  export type JobcardCreateNestedOneWithoutProductStockInput = {
    create?: XOR<JobcardCreateWithoutProductStockInput, JobcardUncheckedCreateWithoutProductStockInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutProductStockInput
    connect?: JobcardWhereUniqueInput
  }

  export type JobcardUpdateOneWithoutProductStockNestedInput = {
    create?: XOR<JobcardCreateWithoutProductStockInput, JobcardUncheckedCreateWithoutProductStockInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutProductStockInput
    upsert?: JobcardUpsertWithoutProductStockInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutProductStockInput, JobcardUpdateWithoutProductStockInput>, JobcardUncheckedUpdateWithoutProductStockInput>
  }

  export type CustomerCreateNestedOneWithoutBillInput = {
    create?: XOR<CustomerCreateWithoutBillInput, CustomerUncheckedCreateWithoutBillInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBillInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderItemsCreateNestedManyWithoutBillInput = {
    create?: XOR<OrderItemsCreateWithoutBillInput, OrderItemsUncheckedCreateWithoutBillInput> | OrderItemsCreateWithoutBillInput[] | OrderItemsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutBillInput | OrderItemsCreateOrConnectWithoutBillInput[]
    createMany?: OrderItemsCreateManyBillInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type billReceivedCreateNestedManyWithoutBillInput = {
    create?: XOR<billReceivedCreateWithoutBillInput, billReceivedUncheckedCreateWithoutBillInput> | billReceivedCreateWithoutBillInput[] | billReceivedUncheckedCreateWithoutBillInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutBillInput | billReceivedCreateOrConnectWithoutBillInput[]
    createMany?: billReceivedCreateManyBillInputEnvelope
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<OrderItemsCreateWithoutBillInput, OrderItemsUncheckedCreateWithoutBillInput> | OrderItemsCreateWithoutBillInput[] | OrderItemsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutBillInput | OrderItemsCreateOrConnectWithoutBillInput[]
    createMany?: OrderItemsCreateManyBillInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type billReceivedUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<billReceivedCreateWithoutBillInput, billReceivedUncheckedCreateWithoutBillInput> | billReceivedCreateWithoutBillInput[] | billReceivedUncheckedCreateWithoutBillInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutBillInput | billReceivedCreateOrConnectWithoutBillInput[]
    createMany?: billReceivedCreateManyBillInputEnvelope
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutBillNestedInput = {
    create?: XOR<CustomerCreateWithoutBillInput, CustomerUncheckedCreateWithoutBillInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBillInput
    upsert?: CustomerUpsertWithoutBillInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutBillInput, CustomerUpdateWithoutBillInput>, CustomerUncheckedUpdateWithoutBillInput>
  }

  export type OrderItemsUpdateManyWithoutBillNestedInput = {
    create?: XOR<OrderItemsCreateWithoutBillInput, OrderItemsUncheckedCreateWithoutBillInput> | OrderItemsCreateWithoutBillInput[] | OrderItemsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutBillInput | OrderItemsCreateOrConnectWithoutBillInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutBillInput | OrderItemsUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: OrderItemsCreateManyBillInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutBillInput | OrderItemsUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutBillInput | OrderItemsUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type billReceivedUpdateManyWithoutBillNestedInput = {
    create?: XOR<billReceivedCreateWithoutBillInput, billReceivedUncheckedCreateWithoutBillInput> | billReceivedCreateWithoutBillInput[] | billReceivedUncheckedCreateWithoutBillInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutBillInput | billReceivedCreateOrConnectWithoutBillInput[]
    upsert?: billReceivedUpsertWithWhereUniqueWithoutBillInput | billReceivedUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: billReceivedCreateManyBillInputEnvelope
    set?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    disconnect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    delete?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    update?: billReceivedUpdateWithWhereUniqueWithoutBillInput | billReceivedUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: billReceivedUpdateManyWithWhereWithoutBillInput | billReceivedUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
  }

  export type OrderItemsUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<OrderItemsCreateWithoutBillInput, OrderItemsUncheckedCreateWithoutBillInput> | OrderItemsCreateWithoutBillInput[] | OrderItemsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutBillInput | OrderItemsCreateOrConnectWithoutBillInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutBillInput | OrderItemsUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: OrderItemsCreateManyBillInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutBillInput | OrderItemsUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutBillInput | OrderItemsUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type billReceivedUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<billReceivedCreateWithoutBillInput, billReceivedUncheckedCreateWithoutBillInput> | billReceivedCreateWithoutBillInput[] | billReceivedUncheckedCreateWithoutBillInput[]
    connectOrCreate?: billReceivedCreateOrConnectWithoutBillInput | billReceivedCreateOrConnectWithoutBillInput[]
    upsert?: billReceivedUpsertWithWhereUniqueWithoutBillInput | billReceivedUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: billReceivedCreateManyBillInputEnvelope
    set?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    disconnect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    delete?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    connect?: billReceivedWhereUniqueInput | billReceivedWhereUniqueInput[]
    update?: billReceivedUpdateWithWhereUniqueWithoutBillInput | billReceivedUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: billReceivedUpdateManyWithWhereWithoutBillInput | billReceivedUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
  }

  export type BillCreateNestedOneWithoutOrdersInput = {
    create?: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BillCreateOrConnectWithoutOrdersInput
    connect?: BillWhereUniqueInput
  }

  export type BillUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BillCreateOrConnectWithoutOrdersInput
    upsert?: BillUpsertWithoutOrdersInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutOrdersInput, BillUpdateWithoutOrdersInput>, BillUncheckedUpdateWithoutOrdersInput>
  }

  export type BillCreateNestedOneWithoutBillReceiveInput = {
    create?: XOR<BillCreateWithoutBillReceiveInput, BillUncheckedCreateWithoutBillReceiveInput>
    connectOrCreate?: BillCreateOrConnectWithoutBillReceiveInput
    connect?: BillWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutBillReceiveInput = {
    create?: XOR<CustomerCreateWithoutBillReceiveInput, CustomerUncheckedCreateWithoutBillReceiveInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBillReceiveInput
    connect?: CustomerWhereUniqueInput
  }

  export type RawGoldLogsCreateNestedOneWithoutBillReceiveInput = {
    create?: XOR<RawGoldLogsCreateWithoutBillReceiveInput, RawGoldLogsUncheckedCreateWithoutBillReceiveInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutBillReceiveInput
    connect?: RawGoldLogsWhereUniqueInput
  }

  export type BillUpdateOneWithoutBillReceiveNestedInput = {
    create?: XOR<BillCreateWithoutBillReceiveInput, BillUncheckedCreateWithoutBillReceiveInput>
    connectOrCreate?: BillCreateOrConnectWithoutBillReceiveInput
    upsert?: BillUpsertWithoutBillReceiveInput
    disconnect?: BillWhereInput | boolean
    delete?: BillWhereInput | boolean
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutBillReceiveInput, BillUpdateWithoutBillReceiveInput>, BillUncheckedUpdateWithoutBillReceiveInput>
  }

  export type CustomerUpdateOneRequiredWithoutBillReceiveNestedInput = {
    create?: XOR<CustomerCreateWithoutBillReceiveInput, CustomerUncheckedCreateWithoutBillReceiveInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBillReceiveInput
    upsert?: CustomerUpsertWithoutBillReceiveInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutBillReceiveInput, CustomerUpdateWithoutBillReceiveInput>, CustomerUncheckedUpdateWithoutBillReceiveInput>
  }

  export type RawGoldLogsUpdateOneWithoutBillReceiveNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutBillReceiveInput, RawGoldLogsUncheckedCreateWithoutBillReceiveInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutBillReceiveInput
    upsert?: RawGoldLogsUpsertWithoutBillReceiveInput
    disconnect?: RawGoldLogsWhereInput | boolean
    delete?: RawGoldLogsWhereInput | boolean
    connect?: RawGoldLogsWhereUniqueInput
    update?: XOR<XOR<RawGoldLogsUpdateToOneWithWhereWithoutBillReceiveInput, RawGoldLogsUpdateWithoutBillReceiveInput>, RawGoldLogsUncheckedUpdateWithoutBillReceiveInput>
  }

  export type CustomerCreateNestedOneWithoutReceiptVoucherInput = {
    create?: XOR<CustomerCreateWithoutReceiptVoucherInput, CustomerUncheckedCreateWithoutReceiptVoucherInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReceiptVoucherInput
    connect?: CustomerWhereUniqueInput
  }

  export type RawGoldLogsCreateNestedOneWithoutReceiptVoucherInput = {
    create?: XOR<RawGoldLogsCreateWithoutReceiptVoucherInput, RawGoldLogsUncheckedCreateWithoutReceiptVoucherInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutReceiptVoucherInput
    connect?: RawGoldLogsWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutReceiptVoucherNestedInput = {
    create?: XOR<CustomerCreateWithoutReceiptVoucherInput, CustomerUncheckedCreateWithoutReceiptVoucherInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReceiptVoucherInput
    upsert?: CustomerUpsertWithoutReceiptVoucherInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutReceiptVoucherInput, CustomerUpdateWithoutReceiptVoucherInput>, CustomerUncheckedUpdateWithoutReceiptVoucherInput>
  }

  export type RawGoldLogsUpdateOneWithoutReceiptVoucherNestedInput = {
    create?: XOR<RawGoldLogsCreateWithoutReceiptVoucherInput, RawGoldLogsUncheckedCreateWithoutReceiptVoucherInput>
    connectOrCreate?: RawGoldLogsCreateOrConnectWithoutReceiptVoucherInput
    upsert?: RawGoldLogsUpsertWithoutReceiptVoucherInput
    disconnect?: RawGoldLogsWhereInput | boolean
    delete?: RawGoldLogsWhereInput | boolean
    connect?: RawGoldLogsWhereUniqueInput
    update?: XOR<XOR<RawGoldLogsUpdateToOneWithWhereWithoutReceiptVoucherInput, RawGoldLogsUpdateWithoutReceiptVoucherInput>, RawGoldLogsUncheckedUpdateWithoutReceiptVoucherInput>
  }

  export type CustomerCreateNestedOneWithoutCustomerBillBalanceInput = {
    create?: XOR<CustomerCreateWithoutCustomerBillBalanceInput, CustomerUncheckedCreateWithoutCustomerBillBalanceInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerBillBalanceInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerBillBalanceNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerBillBalanceInput, CustomerUncheckedCreateWithoutCustomerBillBalanceInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerBillBalanceInput
    upsert?: CustomerUpsertWithoutCustomerBillBalanceInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerBillBalanceInput, CustomerUpdateWithoutCustomerBillBalanceInput>, CustomerUncheckedUpdateWithoutCustomerBillBalanceInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TransactionCreateWithoutCustomerInput = {
    date: Date | string
    type: string
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    createdAt?: Date | string
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: number
    date: Date | string
    type: string
    logId?: number | null
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: TransactionCreateManyCustomerInput | TransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type customer_orderCreateWithoutCustomersInput = {
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    productImages?: product_multiple_imagesCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderUncheckedCreateWithoutCustomersInput = {
    id?: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    productImages?: product_multiple_imagesUncheckedCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderCreateOrConnectWithoutCustomersInput = {
    where: customer_orderWhereUniqueInput
    create: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput>
  }

  export type customer_orderCreateManyCustomersInputEnvelope = {
    data: customer_orderCreateManyCustomersInput | customer_orderCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type BillCreateWithoutCustomersInput = {
    date?: Date | string | null
    time?: Date | string | null
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    orders?: OrderItemsCreateNestedManyWithoutBillInput
    billReceive?: billReceivedCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutCustomersInput = {
    id?: number
    date?: Date | string | null
    time?: Date | string | null
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    orders?: OrderItemsUncheckedCreateNestedManyWithoutBillInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutCustomersInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutCustomersInput, BillUncheckedCreateWithoutCustomersInput>
  }

  export type BillCreateManyCustomersInputEnvelope = {
    data: BillCreateManyCustomersInput | BillCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type billReceivedCreateWithoutCustomersInput = {
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
    bill?: BillCreateNestedOneWithoutBillReceiveInput
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutBillReceiveInput
  }

  export type billReceivedUncheckedCreateWithoutCustomersInput = {
    id?: number
    billId?: number | null
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type billReceivedCreateOrConnectWithoutCustomersInput = {
    where: billReceivedWhereUniqueInput
    create: XOR<billReceivedCreateWithoutCustomersInput, billReceivedUncheckedCreateWithoutCustomersInput>
  }

  export type billReceivedCreateManyCustomersInputEnvelope = {
    data: billReceivedCreateManyCustomersInput | billReceivedCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type receiptVoucherCreateWithoutCustomersInput = {
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutReceiptVoucherInput
  }

  export type receiptVoucherUncheckedCreateWithoutCustomersInput = {
    id?: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type receiptVoucherCreateOrConnectWithoutCustomersInput = {
    where: receiptVoucherWhereUniqueInput
    create: XOR<receiptVoucherCreateWithoutCustomersInput, receiptVoucherUncheckedCreateWithoutCustomersInput>
  }

  export type receiptVoucherCreateManyCustomersInputEnvelope = {
    data: receiptVoucherCreateManyCustomersInput | receiptVoucherCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type customerBillBalanceCreateWithoutCustomersInput = {
    balance?: number | null
    hallMarkBal?: number | null
    createdAt?: Date | string
  }

  export type customerBillBalanceUncheckedCreateWithoutCustomersInput = {
    id?: number
    balance?: number | null
    hallMarkBal?: number | null
    createdAt?: Date | string
  }

  export type customerBillBalanceCreateOrConnectWithoutCustomersInput = {
    where: customerBillBalanceWhereUniqueInput
    create: XOR<customerBillBalanceCreateWithoutCustomersInput, customerBillBalanceUncheckedCreateWithoutCustomersInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    logId?: IntNullableFilter<"Transaction"> | number | null
    gold?: FloatNullableFilter<"Transaction"> | number | null
    amount?: FloatNullableFilter<"Transaction"> | number | null
    goldRate?: FloatNullableFilter<"Transaction"> | number | null
    purity?: FloatNullableFilter<"Transaction"> | number | null
    touch?: FloatNullableFilter<"Transaction"> | number | null
    customerId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type customer_orderUpsertWithWhereUniqueWithoutCustomersInput = {
    where: customer_orderWhereUniqueInput
    update: XOR<customer_orderUpdateWithoutCustomersInput, customer_orderUncheckedUpdateWithoutCustomersInput>
    create: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput>
  }

  export type customer_orderUpdateWithWhereUniqueWithoutCustomersInput = {
    where: customer_orderWhereUniqueInput
    data: XOR<customer_orderUpdateWithoutCustomersInput, customer_orderUncheckedUpdateWithoutCustomersInput>
  }

  export type customer_orderUpdateManyWithWhereWithoutCustomersInput = {
    where: customer_orderScalarWhereInput
    data: XOR<customer_orderUpdateManyMutationInput, customer_orderUncheckedUpdateManyWithoutCustomersInput>
  }

  export type customer_orderScalarWhereInput = {
    AND?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
    OR?: customer_orderScalarWhereInput[]
    NOT?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
    id?: IntFilter<"customer_order"> | number
    customer_id?: IntFilter<"customer_order"> | number
    order_group_id?: IntFilter<"customer_order"> | number
    item_name?: StringFilter<"customer_order"> | string
    description?: StringFilter<"customer_order"> | string
    weight?: FloatFilter<"customer_order"> | number
    image?: StringNullableFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableFilter<"customer_order"> | Date | string | null
    status?: StringFilter<"customer_order"> | string
    worker_name?: StringNullableFilter<"customer_order"> | string | null
    created_at?: DateTimeFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeFilter<"customer_order"> | Date | string
  }

  export type BillUpsertWithWhereUniqueWithoutCustomersInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutCustomersInput, BillUncheckedUpdateWithoutCustomersInput>
    create: XOR<BillCreateWithoutCustomersInput, BillUncheckedCreateWithoutCustomersInput>
  }

  export type BillUpdateWithWhereUniqueWithoutCustomersInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutCustomersInput, BillUncheckedUpdateWithoutCustomersInput>
  }

  export type BillUpdateManyWithWhereWithoutCustomersInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutCustomersInput>
  }

  export type BillScalarWhereInput = {
    AND?: BillScalarWhereInput | BillScalarWhereInput[]
    OR?: BillScalarWhereInput[]
    NOT?: BillScalarWhereInput | BillScalarWhereInput[]
    id?: IntFilter<"Bill"> | number
    date?: DateTimeNullableFilter<"Bill"> | Date | string | null
    time?: DateTimeNullableFilter<"Bill"> | Date | string | null
    customer_id?: IntFilter<"Bill"> | number
    billAmount?: FloatFilter<"Bill"> | number
    hallMark?: FloatNullableFilter<"Bill"> | number | null
    prevHallMark?: FloatNullableFilter<"Bill"> | number | null
    PrevBalance?: FloatNullableFilter<"Bill"> | number | null
    billDetailsprofit?: FloatNullableFilter<"Bill"> | number | null
    Stoneprofit?: FloatNullableFilter<"Bill"> | number | null
    Totalprofit?: FloatNullableFilter<"Bill"> | number | null
    cashBalance?: FloatNullableFilter<"Bill"> | number | null
    createdAt?: DateTimeFilter<"Bill"> | Date | string
  }

  export type billReceivedUpsertWithWhereUniqueWithoutCustomersInput = {
    where: billReceivedWhereUniqueInput
    update: XOR<billReceivedUpdateWithoutCustomersInput, billReceivedUncheckedUpdateWithoutCustomersInput>
    create: XOR<billReceivedCreateWithoutCustomersInput, billReceivedUncheckedCreateWithoutCustomersInput>
  }

  export type billReceivedUpdateWithWhereUniqueWithoutCustomersInput = {
    where: billReceivedWhereUniqueInput
    data: XOR<billReceivedUpdateWithoutCustomersInput, billReceivedUncheckedUpdateWithoutCustomersInput>
  }

  export type billReceivedUpdateManyWithWhereWithoutCustomersInput = {
    where: billReceivedScalarWhereInput
    data: XOR<billReceivedUpdateManyMutationInput, billReceivedUncheckedUpdateManyWithoutCustomersInput>
  }

  export type billReceivedScalarWhereInput = {
    AND?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
    OR?: billReceivedScalarWhereInput[]
    NOT?: billReceivedScalarWhereInput | billReceivedScalarWhereInput[]
    id?: IntFilter<"billReceived"> | number
    billId?: IntNullableFilter<"billReceived"> | number | null
    customer_id?: IntFilter<"billReceived"> | number
    logId?: IntNullableFilter<"billReceived"> | number | null
    date?: StringNullableFilter<"billReceived"> | string | null
    type?: StringNullableFilter<"billReceived"> | string | null
    goldRate?: IntNullableFilter<"billReceived"> | number | null
    gold?: FloatNullableFilter<"billReceived"> | number | null
    touch?: FloatNullableFilter<"billReceived"> | number | null
    purity?: FloatNullableFilter<"billReceived"> | number | null
    receiveHallMark?: FloatNullableFilter<"billReceived"> | number | null
    amount?: FloatNullableFilter<"billReceived"> | number | null
    createdAt?: DateTimeFilter<"billReceived"> | Date | string
  }

  export type receiptVoucherUpsertWithWhereUniqueWithoutCustomersInput = {
    where: receiptVoucherWhereUniqueInput
    update: XOR<receiptVoucherUpdateWithoutCustomersInput, receiptVoucherUncheckedUpdateWithoutCustomersInput>
    create: XOR<receiptVoucherCreateWithoutCustomersInput, receiptVoucherUncheckedCreateWithoutCustomersInput>
  }

  export type receiptVoucherUpdateWithWhereUniqueWithoutCustomersInput = {
    where: receiptVoucherWhereUniqueInput
    data: XOR<receiptVoucherUpdateWithoutCustomersInput, receiptVoucherUncheckedUpdateWithoutCustomersInput>
  }

  export type receiptVoucherUpdateManyWithWhereWithoutCustomersInput = {
    where: receiptVoucherScalarWhereInput
    data: XOR<receiptVoucherUpdateManyMutationInput, receiptVoucherUncheckedUpdateManyWithoutCustomersInput>
  }

  export type receiptVoucherScalarWhereInput = {
    AND?: receiptVoucherScalarWhereInput | receiptVoucherScalarWhereInput[]
    OR?: receiptVoucherScalarWhereInput[]
    NOT?: receiptVoucherScalarWhereInput | receiptVoucherScalarWhereInput[]
    id?: IntFilter<"receiptVoucher"> | number
    customer_id?: IntFilter<"receiptVoucher"> | number
    logId?: IntNullableFilter<"receiptVoucher"> | number | null
    date?: StringNullableFilter<"receiptVoucher"> | string | null
    type?: StringNullableFilter<"receiptVoucher"> | string | null
    goldRate?: IntNullableFilter<"receiptVoucher"> | number | null
    gold?: FloatNullableFilter<"receiptVoucher"> | number | null
    touch?: FloatNullableFilter<"receiptVoucher"> | number | null
    purity?: FloatNullableFilter<"receiptVoucher"> | number | null
    receiveHallMark?: FloatNullableFilter<"receiptVoucher"> | number | null
    amount?: FloatNullableFilter<"receiptVoucher"> | number | null
    createdAt?: DateTimeFilter<"receiptVoucher"> | Date | string
  }

  export type customerBillBalanceUpsertWithoutCustomersInput = {
    update: XOR<customerBillBalanceUpdateWithoutCustomersInput, customerBillBalanceUncheckedUpdateWithoutCustomersInput>
    create: XOR<customerBillBalanceCreateWithoutCustomersInput, customerBillBalanceUncheckedCreateWithoutCustomersInput>
    where?: customerBillBalanceWhereInput
  }

  export type customerBillBalanceUpdateToOneWithWhereWithoutCustomersInput = {
    where?: customerBillBalanceWhereInput
    data: XOR<customerBillBalanceUpdateWithoutCustomersInput, customerBillBalanceUncheckedUpdateWithoutCustomersInput>
  }

  export type customerBillBalanceUpdateWithoutCustomersInput = {
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    hallMarkBal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerBillBalanceUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    hallMarkBal?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawgoldStockCreateWithoutMasterTouchInput = {
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
    rawGoldLogs?: RawGoldLogsCreateNestedManyWithoutRawGoldStockInput
  }

  export type RawgoldStockUncheckedCreateWithoutMasterTouchInput = {
    id?: number
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
    rawGoldLogs?: RawGoldLogsUncheckedCreateNestedManyWithoutRawGoldStockInput
  }

  export type RawgoldStockCreateOrConnectWithoutMasterTouchInput = {
    where: RawgoldStockWhereUniqueInput
    create: XOR<RawgoldStockCreateWithoutMasterTouchInput, RawgoldStockUncheckedCreateWithoutMasterTouchInput>
  }

  export type RawgoldStockCreateManyMasterTouchInputEnvelope = {
    data: RawgoldStockCreateManyMasterTouchInput | RawgoldStockCreateManyMasterTouchInput[]
    skipDuplicates?: boolean
  }

  export type RawgoldStockUpsertWithWhereUniqueWithoutMasterTouchInput = {
    where: RawgoldStockWhereUniqueInput
    update: XOR<RawgoldStockUpdateWithoutMasterTouchInput, RawgoldStockUncheckedUpdateWithoutMasterTouchInput>
    create: XOR<RawgoldStockCreateWithoutMasterTouchInput, RawgoldStockUncheckedCreateWithoutMasterTouchInput>
  }

  export type RawgoldStockUpdateWithWhereUniqueWithoutMasterTouchInput = {
    where: RawgoldStockWhereUniqueInput
    data: XOR<RawgoldStockUpdateWithoutMasterTouchInput, RawgoldStockUncheckedUpdateWithoutMasterTouchInput>
  }

  export type RawgoldStockUpdateManyWithWhereWithoutMasterTouchInput = {
    where: RawgoldStockScalarWhereInput
    data: XOR<RawgoldStockUpdateManyMutationInput, RawgoldStockUncheckedUpdateManyWithoutMasterTouchInput>
  }

  export type RawgoldStockScalarWhereInput = {
    AND?: RawgoldStockScalarWhereInput | RawgoldStockScalarWhereInput[]
    OR?: RawgoldStockScalarWhereInput[]
    NOT?: RawgoldStockScalarWhereInput | RawgoldStockScalarWhereInput[]
    id?: IntFilter<"RawgoldStock"> | number
    touchId?: IntFilter<"RawgoldStock"> | number
    touch?: FloatNullableFilter<"RawgoldStock"> | number | null
    weight?: FloatNullableFilter<"RawgoldStock"> | number | null
    remainingWt?: FloatNullableFilter<"RawgoldStock"> | number | null
  }

  export type RawGoldLogsCreateWithoutTransactionsInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    rawGoldStock?: RawgoldStockCreateNestedOneWithoutRawGoldLogsInput
    givenGold?: givenGoldCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateWithoutTransactionsInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsCreateOrConnectWithoutTransactionsInput = {
    where: RawGoldLogsWhereUniqueInput
    create: XOR<RawGoldLogsCreateWithoutTransactionsInput, RawGoldLogsUncheckedCreateWithoutTransactionsInput>
  }

  export type CustomerCreateWithoutTransactionsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
    bill?: BillCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
    bill?: BillUncheckedCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceUncheckedCreateNestedOneWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type RawGoldLogsUpsertWithoutTransactionsInput = {
    update: XOR<RawGoldLogsUpdateWithoutTransactionsInput, RawGoldLogsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<RawGoldLogsCreateWithoutTransactionsInput, RawGoldLogsUncheckedCreateWithoutTransactionsInput>
    where?: RawGoldLogsWhereInput
  }

  export type RawGoldLogsUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: RawGoldLogsWhereInput
    data: XOR<RawGoldLogsUpdateWithoutTransactionsInput, RawGoldLogsUncheckedUpdateWithoutTransactionsInput>
  }

  export type RawGoldLogsUpdateWithoutTransactionsInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldStock?: RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput
    givenGold?: givenGoldUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
    bill?: BillUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
    bill?: BillUncheckedUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUncheckedUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerCreateWithoutCustomerOrdersInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    bill?: BillCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutCustomerOrdersInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    bill?: BillUncheckedCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceUncheckedCreateNestedOneWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutCustomerOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
  }

  export type product_multiple_imagesCreateWithoutCustomerOrderDetailsInput = {
    filename: string
  }

  export type product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput = {
    id?: number
    filename: string
  }

  export type product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesWhereUniqueInput
    create: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope = {
    data: product_multiple_imagesCreateManyCustomerOrderDetailsInput | product_multiple_imagesCreateManyCustomerOrderDetailsInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutCustomerOrdersInput = {
    update: XOR<CustomerUpdateWithoutCustomerOrdersInput, CustomerUncheckedUpdateWithoutCustomerOrdersInput>
    create: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerOrdersInput, CustomerUncheckedUpdateWithoutCustomerOrdersInput>
  }

  export type CustomerUpdateWithoutCustomerOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    bill?: BillUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    bill?: BillUncheckedUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUncheckedUpdateOneWithoutCustomersNestedInput
  }

  export type product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesWhereUniqueInput
    update: XOR<product_multiple_imagesUpdateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedUpdateWithoutCustomerOrderDetailsInput>
    create: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesWhereUniqueInput
    data: XOR<product_multiple_imagesUpdateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedUpdateWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesScalarWhereInput
    data: XOR<product_multiple_imagesUpdateManyMutationInput, product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesScalarWhereInput = {
    AND?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
    OR?: product_multiple_imagesScalarWhereInput[]
    NOT?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
    id?: IntFilter<"product_multiple_images"> | number
    customer_order_id?: IntFilter<"product_multiple_images"> | number
    filename?: StringFilter<"product_multiple_images"> | string
  }

  export type customer_orderCreateWithoutProductImagesInput = {
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    customers: CustomerCreateNestedOneWithoutCustomerOrdersInput
  }

  export type customer_orderUncheckedCreateWithoutProductImagesInput = {
    id?: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type customer_orderCreateOrConnectWithoutProductImagesInput = {
    where: customer_orderWhereUniqueInput
    create: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
  }

  export type customer_orderUpsertWithoutProductImagesInput = {
    update: XOR<customer_orderUpdateWithoutProductImagesInput, customer_orderUncheckedUpdateWithoutProductImagesInput>
    create: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
    where?: customer_orderWhereInput
  }

  export type customer_orderUpdateToOneWithWhereWithoutProductImagesInput = {
    where?: customer_orderWhereInput
    data: XOR<customer_orderUpdateWithoutProductImagesInput, customer_orderUncheckedUpdateWithoutProductImagesInput>
  }

  export type customer_orderUpdateWithoutProductImagesInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutCustomerOrdersNestedInput
  }

  export type customer_orderUncheckedUpdateWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BullionPurchaseCreateWithoutBullionInput = {
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    givenDetails?: GivenDetailCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseUncheckedCreateWithoutBullionInput = {
    id?: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    givenDetails?: GivenDetailUncheckedCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseCreateOrConnectWithoutBullionInput = {
    where: BullionPurchaseWhereUniqueInput
    create: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput>
  }

  export type BullionPurchaseCreateManyBullionInputEnvelope = {
    data: BullionPurchaseCreateManyBullionInput | BullionPurchaseCreateManyBullionInput[]
    skipDuplicates?: boolean
  }

  export type BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput = {
    where: BullionPurchaseWhereUniqueInput
    update: XOR<BullionPurchaseUpdateWithoutBullionInput, BullionPurchaseUncheckedUpdateWithoutBullionInput>
    create: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput>
  }

  export type BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput = {
    where: BullionPurchaseWhereUniqueInput
    data: XOR<BullionPurchaseUpdateWithoutBullionInput, BullionPurchaseUncheckedUpdateWithoutBullionInput>
  }

  export type BullionPurchaseUpdateManyWithWhereWithoutBullionInput = {
    where: BullionPurchaseScalarWhereInput
    data: XOR<BullionPurchaseUpdateManyMutationInput, BullionPurchaseUncheckedUpdateManyWithoutBullionInput>
  }

  export type BullionPurchaseScalarWhereInput = {
    AND?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
    OR?: BullionPurchaseScalarWhereInput[]
    NOT?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
    id?: IntFilter<"BullionPurchase"> | number
    bullionId?: IntFilter<"BullionPurchase"> | number
    grams?: FloatFilter<"BullionPurchase"> | number
    touch?: FloatNullableFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableFilter<"BullionPurchase"> | number | null
    rate?: FloatFilter<"BullionPurchase"> | number
    amount?: FloatFilter<"BullionPurchase"> | number
    balance?: FloatFilter<"BullionPurchase"> | number
    createdAt?: DateTimeFilter<"BullionPurchase"> | Date | string
  }

  export type MasterBullionCreateWithoutPurchasesInput = {
    name: string
    phone?: string | null
    address?: string | null
  }

  export type MasterBullionUncheckedCreateWithoutPurchasesInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
  }

  export type MasterBullionCreateOrConnectWithoutPurchasesInput = {
    where: MasterBullionWhereUniqueInput
    create: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
  }

  export type GivenDetailCreateWithoutBullionPurchaseInput = {
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
  }

  export type GivenDetailUncheckedCreateWithoutBullionPurchaseInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
  }

  export type GivenDetailCreateOrConnectWithoutBullionPurchaseInput = {
    where: GivenDetailWhereUniqueInput
    create: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput>
  }

  export type GivenDetailCreateManyBullionPurchaseInputEnvelope = {
    data: GivenDetailCreateManyBullionPurchaseInput | GivenDetailCreateManyBullionPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type MasterBullionUpsertWithoutPurchasesInput = {
    update: XOR<MasterBullionUpdateWithoutPurchasesInput, MasterBullionUncheckedUpdateWithoutPurchasesInput>
    create: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
    where?: MasterBullionWhereInput
  }

  export type MasterBullionUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: MasterBullionWhereInput
    data: XOR<MasterBullionUpdateWithoutPurchasesInput, MasterBullionUncheckedUpdateWithoutPurchasesInput>
  }

  export type MasterBullionUpdateWithoutPurchasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterBullionUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput = {
    where: GivenDetailWhereUniqueInput
    update: XOR<GivenDetailUpdateWithoutBullionPurchaseInput, GivenDetailUncheckedUpdateWithoutBullionPurchaseInput>
    create: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput>
  }

  export type GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput = {
    where: GivenDetailWhereUniqueInput
    data: XOR<GivenDetailUpdateWithoutBullionPurchaseInput, GivenDetailUncheckedUpdateWithoutBullionPurchaseInput>
  }

  export type GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput = {
    where: GivenDetailScalarWhereInput
    data: XOR<GivenDetailUpdateManyMutationInput, GivenDetailUncheckedUpdateManyWithoutBullionPurchaseInput>
  }

  export type GivenDetailScalarWhereInput = {
    AND?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
    OR?: GivenDetailScalarWhereInput[]
    NOT?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
    id?: IntFilter<"GivenDetail"> | number
    amount?: FloatFilter<"GivenDetail"> | number
    grams?: FloatFilter<"GivenDetail"> | number
    touch?: FloatNullableFilter<"GivenDetail"> | number | null
    purity?: FloatNullableFilter<"GivenDetail"> | number | null
    purchaseId?: IntFilter<"GivenDetail"> | number
  }

  export type BullionPurchaseCreateWithoutGivenDetailsInput = {
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    bullion: MasterBullionCreateNestedOneWithoutPurchasesInput
  }

  export type BullionPurchaseUncheckedCreateWithoutGivenDetailsInput = {
    id?: number
    bullionId: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
  }

  export type BullionPurchaseCreateOrConnectWithoutGivenDetailsInput = {
    where: BullionPurchaseWhereUniqueInput
    create: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
  }

  export type BullionPurchaseUpsertWithoutGivenDetailsInput = {
    update: XOR<BullionPurchaseUpdateWithoutGivenDetailsInput, BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput>
    create: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
    where?: BullionPurchaseWhereInput
  }

  export type BullionPurchaseUpdateToOneWithWhereWithoutGivenDetailsInput = {
    where?: BullionPurchaseWhereInput
    data: XOR<BullionPurchaseUpdateWithoutGivenDetailsInput, BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput>
  }

  export type BullionPurchaseUpdateWithoutGivenDetailsInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bullion?: MasterBullionUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bullionId?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobcardCreateWithoutGoldsmithInput = {
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockCreateNestedManyWithoutJobcardInput
    total?: TotalCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutJobcardInput
    total?: TotalUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutGoldsmithInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput>
  }

  export type JobcardCreateManyGoldsmithInputEnvelope = {
    data: JobcardCreateManyGoldsmithInput | JobcardCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type givenGoldCreateWithoutGoldsmithInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutGivenGoldInput
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutGivenGoldInput
  }

  export type givenGoldUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    jobcardId?: number | null
    logId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldCreateOrConnectWithoutGoldsmithInput = {
    where: givenGoldWhereUniqueInput
    create: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput>
  }

  export type givenGoldCreateManyGoldsmithInputEnvelope = {
    data: givenGoldCreateManyGoldsmithInput | givenGoldCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type itemDeliveryCreateWithoutGoldsmithInput = {
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutDeliveriesInput
    deduction?: deductionCreateNestedManyWithoutItemDeliveryInput
  }

  export type itemDeliveryUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deduction?: deductionUncheckedCreateNestedManyWithoutItemDeliveryInput
  }

  export type itemDeliveryCreateOrConnectWithoutGoldsmithInput = {
    where: itemDeliveryWhereUniqueInput
    create: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput>
  }

  export type itemDeliveryCreateManyGoldsmithInputEnvelope = {
    data: itemDeliveryCreateManyGoldsmithInput | itemDeliveryCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type ReceivedsectionCreateWithoutGoldsmithInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutReceivedSectionsInput
    jobcard?: JobcardCreateNestedOneWithoutReceivedInput
  }

  export type ReceivedsectionUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    logId?: number | null
    jobcardId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateOrConnectWithoutGoldsmithInput = {
    where: ReceivedsectionWhereUniqueInput
    create: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput>
  }

  export type ReceivedsectionCreateManyGoldsmithInputEnvelope = {
    data: ReceivedsectionCreateManyGoldsmithInput | ReceivedsectionCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type TotalCreateWithoutGoldsmithInput = {
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutTotalInput
  }

  export type TotalUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    jobcardId?: number | null
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalCreateOrConnectWithoutGoldsmithInput = {
    where: TotalWhereUniqueInput
    create: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput>
  }

  export type TotalCreateManyGoldsmithInputEnvelope = {
    data: TotalCreateManyGoldsmithInput | TotalCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type RepairCreateWithoutGoldsmithInput = {
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairCreateOrConnectWithoutGoldsmithInput = {
    where: RepairWhereUniqueInput
    create: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput>
  }

  export type RepairCreateManyGoldsmithInputEnvelope = {
    data: RepairCreateManyGoldsmithInput | RepairCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type BalancesCreateWithoutGoldsmithInput = {
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesCreateOrConnectWithoutGoldsmithInput = {
    where: BalancesWhereUniqueInput
    create: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput>
  }

  export type BalancesCreateManyGoldsmithInputEnvelope = {
    data: BalancesCreateManyGoldsmithInput | BalancesCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type JobcardUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: JobcardWhereUniqueInput
    update: XOR<JobcardUpdateWithoutGoldsmithInput, JobcardUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput>
  }

  export type JobcardUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: JobcardWhereUniqueInput
    data: XOR<JobcardUpdateWithoutGoldsmithInput, JobcardUncheckedUpdateWithoutGoldsmithInput>
  }

  export type JobcardUpdateManyWithWhereWithoutGoldsmithInput = {
    where: JobcardScalarWhereInput
    data: XOR<JobcardUpdateManyMutationInput, JobcardUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type JobcardScalarWhereInput = {
    AND?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
    OR?: JobcardScalarWhereInput[]
    NOT?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
    id?: IntFilter<"Jobcard"> | number
    goldsmithId?: IntFilter<"Jobcard"> | number
    description?: StringNullableFilter<"Jobcard"> | string | null
    stockIsMove?: BoolNullableFilter<"Jobcard"> | boolean | null
    createdAt?: DateTimeFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeFilter<"Jobcard"> | Date | string
  }

  export type givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: givenGoldWhereUniqueInput
    update: XOR<givenGoldUpdateWithoutGoldsmithInput, givenGoldUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput>
  }

  export type givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: givenGoldWhereUniqueInput
    data: XOR<givenGoldUpdateWithoutGoldsmithInput, givenGoldUncheckedUpdateWithoutGoldsmithInput>
  }

  export type givenGoldUpdateManyWithWhereWithoutGoldsmithInput = {
    where: givenGoldScalarWhereInput
    data: XOR<givenGoldUpdateManyMutationInput, givenGoldUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type givenGoldScalarWhereInput = {
    AND?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
    OR?: givenGoldScalarWhereInput[]
    NOT?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
    id?: IntFilter<"givenGold"> | number
    goldsmithId?: IntNullableFilter<"givenGold"> | number | null
    jobcardId?: IntNullableFilter<"givenGold"> | number | null
    logId?: IntNullableFilter<"givenGold"> | number | null
    weight?: FloatNullableFilter<"givenGold"> | number | null
    touch?: FloatNullableFilter<"givenGold"> | number | null
    purity?: FloatNullableFilter<"givenGold"> | number | null
    finaltouch?: FloatNullableFilter<"givenGold"> | number | null
    finalPurity?: FloatNullableFilter<"givenGold"> | number | null
    copperPurity?: FloatNullableFilter<"givenGold"> | number | null
    createdAt?: DateTimeFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeFilter<"givenGold"> | Date | string
  }

  export type itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: itemDeliveryWhereUniqueInput
    update: XOR<itemDeliveryUpdateWithoutGoldsmithInput, itemDeliveryUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput>
  }

  export type itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: itemDeliveryWhereUniqueInput
    data: XOR<itemDeliveryUpdateWithoutGoldsmithInput, itemDeliveryUncheckedUpdateWithoutGoldsmithInput>
  }

  export type itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput = {
    where: itemDeliveryScalarWhereInput
    data: XOR<itemDeliveryUpdateManyMutationInput, itemDeliveryUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type itemDeliveryScalarWhereInput = {
    AND?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
    OR?: itemDeliveryScalarWhereInput[]
    NOT?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
    id?: IntFilter<"itemDelivery"> | number
    itemName?: StringNullableFilter<"itemDelivery"> | string | null
    itemWeight?: FloatNullableFilter<"itemDelivery"> | number | null
    count?: IntNullableFilter<"itemDelivery"> | number | null
    touch?: FloatNullableFilter<"itemDelivery"> | number | null
    sealName?: StringNullableFilter<"itemDelivery"> | string | null
    netWeight?: FloatNullableFilter<"itemDelivery"> | number | null
    wastageType?: StringNullableFilter<"itemDelivery"> | string | null
    wastageValue?: FloatNullableFilter<"itemDelivery"> | number | null
    wastagePure?: FloatNullableFilter<"itemDelivery"> | number | null
    finalPurity?: FloatNullableFilter<"itemDelivery"> | number | null
    goldsmithId?: IntNullableFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"itemDelivery"> | Date | string
  }

  export type ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: ReceivedsectionWhereUniqueInput
    update: XOR<ReceivedsectionUpdateWithoutGoldsmithInput, ReceivedsectionUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput>
  }

  export type ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: ReceivedsectionWhereUniqueInput
    data: XOR<ReceivedsectionUpdateWithoutGoldsmithInput, ReceivedsectionUncheckedUpdateWithoutGoldsmithInput>
  }

  export type ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput = {
    where: ReceivedsectionScalarWhereInput
    data: XOR<ReceivedsectionUpdateManyMutationInput, ReceivedsectionUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type ReceivedsectionScalarWhereInput = {
    AND?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
    OR?: ReceivedsectionScalarWhereInput[]
    NOT?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
    id?: IntFilter<"Receivedsection"> | number
    weight?: FloatNullableFilter<"Receivedsection"> | number | null
    touch?: FloatNullableFilter<"Receivedsection"> | number | null
    purity?: FloatNullableFilter<"Receivedsection"> | number | null
    logId?: IntNullableFilter<"Receivedsection"> | number | null
    jobcardId?: IntFilter<"Receivedsection"> | number
    goldsmithId?: IntFilter<"Receivedsection"> | number
    createdAt?: DateTimeFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeFilter<"Receivedsection"> | Date | string
  }

  export type TotalUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: TotalWhereUniqueInput
    update: XOR<TotalUpdateWithoutGoldsmithInput, TotalUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput>
  }

  export type TotalUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: TotalWhereUniqueInput
    data: XOR<TotalUpdateWithoutGoldsmithInput, TotalUncheckedUpdateWithoutGoldsmithInput>
  }

  export type TotalUpdateManyWithWhereWithoutGoldsmithInput = {
    where: TotalScalarWhereInput
    data: XOR<TotalUpdateManyMutationInput, TotalUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type TotalScalarWhereInput = {
    AND?: TotalScalarWhereInput | TotalScalarWhereInput[]
    OR?: TotalScalarWhereInput[]
    NOT?: TotalScalarWhereInput | TotalScalarWhereInput[]
    id?: IntFilter<"Total"> | number
    jobcardId?: IntNullableFilter<"Total"> | number | null
    goldsmithId?: IntFilter<"Total"> | number
    givenTotal?: FloatNullableFilter<"Total"> | number | null
    deliveryTotal?: FloatNullableFilter<"Total"> | number | null
    stoneTotalWt?: FloatNullableFilter<"Total"> | number | null
    openingBalance?: FloatNullableFilter<"Total"> | number | null
    jobCardBalance?: FloatNullableFilter<"Total"> | number | null
    receivedTotal?: FloatNullableFilter<"Total"> | number | null
    isFinished?: StringNullableFilter<"Total"> | string | null
    createdAt?: DateTimeFilter<"Total"> | Date | string
    updatedAt?: DateTimeFilter<"Total"> | Date | string
  }

  export type RepairUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: RepairWhereUniqueInput
    update: XOR<RepairUpdateWithoutGoldsmithInput, RepairUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput>
  }

  export type RepairUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: RepairWhereUniqueInput
    data: XOR<RepairUpdateWithoutGoldsmithInput, RepairUncheckedUpdateWithoutGoldsmithInput>
  }

  export type RepairUpdateManyWithWhereWithoutGoldsmithInput = {
    where: RepairScalarWhereInput
    data: XOR<RepairUpdateManyMutationInput, RepairUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type RepairScalarWhereInput = {
    AND?: RepairScalarWhereInput | RepairScalarWhereInput[]
    OR?: RepairScalarWhereInput[]
    NOT?: RepairScalarWhereInput | RepairScalarWhereInput[]
    id?: IntFilter<"Repair"> | number
    goldsmithId?: IntFilter<"Repair"> | number
    givenWeights?: JsonFilter<"Repair">
    totalGiven?: FloatFilter<"Repair"> | number
    itemWeights?: JsonFilter<"Repair">
    totalItem?: FloatFilter<"Repair"> | number
    stone?: FloatFilter<"Repair"> | number
    wastageType?: StringFilter<"Repair"> | string
    touch?: FloatFilter<"Repair"> | number
    netWeight?: FloatFilter<"Repair"> | number
    createdAt?: DateTimeFilter<"Repair"> | Date | string
  }

  export type BalancesUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: BalancesWhereUniqueInput
    update: XOR<BalancesUpdateWithoutGoldsmithInput, BalancesUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput>
  }

  export type BalancesUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: BalancesWhereUniqueInput
    data: XOR<BalancesUpdateWithoutGoldsmithInput, BalancesUncheckedUpdateWithoutGoldsmithInput>
  }

  export type BalancesUpdateManyWithWhereWithoutGoldsmithInput = {
    where: BalancesScalarWhereInput
    data: XOR<BalancesUpdateManyMutationInput, BalancesUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type BalancesScalarWhereInput = {
    AND?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
    OR?: BalancesScalarWhereInput[]
    NOT?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
    id?: IntFilter<"Balances"> | number
    goldsmithId?: IntFilter<"Balances"> | number
    totalDeliveries?: IntFilter<"Balances"> | number
    totalItemWeight?: FloatFilter<"Balances"> | number
    totalNetWeight?: FloatFilter<"Balances"> | number
    totalPurity?: FloatFilter<"Balances"> | number
    totalReceivedWeight?: FloatFilter<"Balances"> | number
    totalReceivedTouch?: FloatFilter<"Balances"> | number
    totalReceivedPurity?: FloatFilter<"Balances"> | number
    createdAt?: DateTimeFilter<"Balances"> | Date | string
    updatedAt?: DateTimeFilter<"Balances"> | Date | string
  }

  export type GoldsmithCreateWithoutJobcardsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutJobcardsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutJobcardsInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
  }

  export type givenGoldCreateWithoutJobcardInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutGivenGoldInput
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutGivenGoldInput
  }

  export type givenGoldUncheckedCreateWithoutJobcardInput = {
    id?: number
    goldsmithId?: number | null
    logId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldCreateOrConnectWithoutJobcardInput = {
    where: givenGoldWhereUniqueInput
    create: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput>
  }

  export type givenGoldCreateManyJobcardInputEnvelope = {
    data: givenGoldCreateManyJobcardInput | givenGoldCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type itemDeliveryCreateWithoutJobcardInput = {
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutDeliveriesInput
    deduction?: deductionCreateNestedManyWithoutItemDeliveryInput
  }

  export type itemDeliveryUncheckedCreateWithoutJobcardInput = {
    id?: number
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deduction?: deductionUncheckedCreateNestedManyWithoutItemDeliveryInput
  }

  export type itemDeliveryCreateOrConnectWithoutJobcardInput = {
    where: itemDeliveryWhereUniqueInput
    create: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput>
  }

  export type itemDeliveryCreateManyJobcardInputEnvelope = {
    data: itemDeliveryCreateManyJobcardInput | itemDeliveryCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type ReceivedsectionCreateWithoutJobcardInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutReceivedSectionsInput
    goldsmith?: GoldsmithCreateNestedOneWithoutReceivedInput
  }

  export type ReceivedsectionUncheckedCreateWithoutJobcardInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    logId?: number | null
    goldsmithId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateOrConnectWithoutJobcardInput = {
    where: ReceivedsectionWhereUniqueInput
    create: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput>
  }

  export type ReceivedsectionCreateManyJobcardInputEnvelope = {
    data: ReceivedsectionCreateManyJobcardInput | ReceivedsectionCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type ProductStockCreateWithoutJobcardInput = {
    itemName: string
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight?: number | null
    wastagePure?: number | null
    finalWeight: number
    createdAt?: Date | string
  }

  export type ProductStockUncheckedCreateWithoutJobcardInput = {
    id?: number
    itemName: string
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight?: number | null
    wastagePure?: number | null
    finalWeight: number
    createdAt?: Date | string
  }

  export type ProductStockCreateOrConnectWithoutJobcardInput = {
    where: ProductStockWhereUniqueInput
    create: XOR<ProductStockCreateWithoutJobcardInput, ProductStockUncheckedCreateWithoutJobcardInput>
  }

  export type ProductStockCreateManyJobcardInputEnvelope = {
    data: ProductStockCreateManyJobcardInput | ProductStockCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type TotalCreateWithoutJobcardInput = {
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutTotalsInput
  }

  export type TotalUncheckedCreateWithoutJobcardInput = {
    id?: number
    goldsmithId: number
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalCreateOrConnectWithoutJobcardInput = {
    where: TotalWhereUniqueInput
    create: XOR<TotalCreateWithoutJobcardInput, TotalUncheckedCreateWithoutJobcardInput>
  }

  export type TotalCreateManyJobcardInputEnvelope = {
    data: TotalCreateManyJobcardInput | TotalCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type GoldsmithUpsertWithoutJobcardsInput = {
    update: XOR<GoldsmithUpdateWithoutJobcardsInput, GoldsmithUncheckedUpdateWithoutJobcardsInput>
    create: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutJobcardsInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutJobcardsInput, GoldsmithUncheckedUpdateWithoutJobcardsInput>
  }

  export type GoldsmithUpdateWithoutJobcardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutJobcardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type givenGoldUpsertWithWhereUniqueWithoutJobcardInput = {
    where: givenGoldWhereUniqueInput
    update: XOR<givenGoldUpdateWithoutJobcardInput, givenGoldUncheckedUpdateWithoutJobcardInput>
    create: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput>
  }

  export type givenGoldUpdateWithWhereUniqueWithoutJobcardInput = {
    where: givenGoldWhereUniqueInput
    data: XOR<givenGoldUpdateWithoutJobcardInput, givenGoldUncheckedUpdateWithoutJobcardInput>
  }

  export type givenGoldUpdateManyWithWhereWithoutJobcardInput = {
    where: givenGoldScalarWhereInput
    data: XOR<givenGoldUpdateManyMutationInput, givenGoldUncheckedUpdateManyWithoutJobcardInput>
  }

  export type itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput = {
    where: itemDeliveryWhereUniqueInput
    update: XOR<itemDeliveryUpdateWithoutJobcardInput, itemDeliveryUncheckedUpdateWithoutJobcardInput>
    create: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput>
  }

  export type itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput = {
    where: itemDeliveryWhereUniqueInput
    data: XOR<itemDeliveryUpdateWithoutJobcardInput, itemDeliveryUncheckedUpdateWithoutJobcardInput>
  }

  export type itemDeliveryUpdateManyWithWhereWithoutJobcardInput = {
    where: itemDeliveryScalarWhereInput
    data: XOR<itemDeliveryUpdateManyMutationInput, itemDeliveryUncheckedUpdateManyWithoutJobcardInput>
  }

  export type ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput = {
    where: ReceivedsectionWhereUniqueInput
    update: XOR<ReceivedsectionUpdateWithoutJobcardInput, ReceivedsectionUncheckedUpdateWithoutJobcardInput>
    create: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput>
  }

  export type ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput = {
    where: ReceivedsectionWhereUniqueInput
    data: XOR<ReceivedsectionUpdateWithoutJobcardInput, ReceivedsectionUncheckedUpdateWithoutJobcardInput>
  }

  export type ReceivedsectionUpdateManyWithWhereWithoutJobcardInput = {
    where: ReceivedsectionScalarWhereInput
    data: XOR<ReceivedsectionUpdateManyMutationInput, ReceivedsectionUncheckedUpdateManyWithoutJobcardInput>
  }

  export type ProductStockUpsertWithWhereUniqueWithoutJobcardInput = {
    where: ProductStockWhereUniqueInput
    update: XOR<ProductStockUpdateWithoutJobcardInput, ProductStockUncheckedUpdateWithoutJobcardInput>
    create: XOR<ProductStockCreateWithoutJobcardInput, ProductStockUncheckedCreateWithoutJobcardInput>
  }

  export type ProductStockUpdateWithWhereUniqueWithoutJobcardInput = {
    where: ProductStockWhereUniqueInput
    data: XOR<ProductStockUpdateWithoutJobcardInput, ProductStockUncheckedUpdateWithoutJobcardInput>
  }

  export type ProductStockUpdateManyWithWhereWithoutJobcardInput = {
    where: ProductStockScalarWhereInput
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyWithoutJobcardInput>
  }

  export type ProductStockScalarWhereInput = {
    AND?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
    OR?: ProductStockScalarWhereInput[]
    NOT?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
    id?: IntFilter<"ProductStock"> | number
    jobcardId?: IntFilter<"ProductStock"> | number
    itemName?: StringFilter<"ProductStock"> | string
    itemWeight?: FloatFilter<"ProductStock"> | number
    count?: IntFilter<"ProductStock"> | number
    touch?: FloatFilter<"ProductStock"> | number
    stoneWeight?: FloatFilter<"ProductStock"> | number
    wastageValue?: FloatFilter<"ProductStock"> | number
    netWeight?: FloatNullableFilter<"ProductStock"> | number | null
    wastagePure?: FloatNullableFilter<"ProductStock"> | number | null
    finalWeight?: FloatFilter<"ProductStock"> | number
    createdAt?: DateTimeFilter<"ProductStock"> | Date | string
  }

  export type TotalUpsertWithWhereUniqueWithoutJobcardInput = {
    where: TotalWhereUniqueInput
    update: XOR<TotalUpdateWithoutJobcardInput, TotalUncheckedUpdateWithoutJobcardInput>
    create: XOR<TotalCreateWithoutJobcardInput, TotalUncheckedCreateWithoutJobcardInput>
  }

  export type TotalUpdateWithWhereUniqueWithoutJobcardInput = {
    where: TotalWhereUniqueInput
    data: XOR<TotalUpdateWithoutJobcardInput, TotalUncheckedUpdateWithoutJobcardInput>
  }

  export type TotalUpdateManyWithWhereWithoutJobcardInput = {
    where: TotalScalarWhereInput
    data: XOR<TotalUpdateManyMutationInput, TotalUncheckedUpdateManyWithoutJobcardInput>
  }

  export type GoldsmithCreateWithoutGivenGoldInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutGivenGoldInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutGivenGoldInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
  }

  export type JobcardCreateWithoutGivenGoldInput = {
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockCreateNestedManyWithoutJobcardInput
    total?: TotalCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutGivenGoldInput = {
    id?: number
    goldsmithId: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutJobcardInput
    total?: TotalUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutGivenGoldInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
  }

  export type RawGoldLogsCreateWithoutGivenGoldInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    rawGoldStock?: RawgoldStockCreateNestedOneWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateWithoutGivenGoldInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    receivedSections?: ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsCreateOrConnectWithoutGivenGoldInput = {
    where: RawGoldLogsWhereUniqueInput
    create: XOR<RawGoldLogsCreateWithoutGivenGoldInput, RawGoldLogsUncheckedCreateWithoutGivenGoldInput>
  }

  export type GoldsmithUpsertWithoutGivenGoldInput = {
    update: XOR<GoldsmithUpdateWithoutGivenGoldInput, GoldsmithUncheckedUpdateWithoutGivenGoldInput>
    create: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutGivenGoldInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutGivenGoldInput, GoldsmithUncheckedUpdateWithoutGivenGoldInput>
  }

  export type GoldsmithUpdateWithoutGivenGoldInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutGivenGoldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type JobcardUpsertWithoutGivenGoldInput = {
    update: XOR<JobcardUpdateWithoutGivenGoldInput, JobcardUncheckedUpdateWithoutGivenGoldInput>
    create: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutGivenGoldInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutGivenGoldInput, JobcardUncheckedUpdateWithoutGivenGoldInput>
  }

  export type JobcardUpdateWithoutGivenGoldInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUpdateManyWithoutJobcardNestedInput
    total?: TotalUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutGivenGoldInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutJobcardNestedInput
    total?: TotalUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type RawGoldLogsUpsertWithoutGivenGoldInput = {
    update: XOR<RawGoldLogsUpdateWithoutGivenGoldInput, RawGoldLogsUncheckedUpdateWithoutGivenGoldInput>
    create: XOR<RawGoldLogsCreateWithoutGivenGoldInput, RawGoldLogsUncheckedCreateWithoutGivenGoldInput>
    where?: RawGoldLogsWhereInput
  }

  export type RawGoldLogsUpdateToOneWithWhereWithoutGivenGoldInput = {
    where?: RawGoldLogsWhereInput
    data: XOR<RawGoldLogsUpdateWithoutGivenGoldInput, RawGoldLogsUncheckedUpdateWithoutGivenGoldInput>
  }

  export type RawGoldLogsUpdateWithoutGivenGoldInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldStock?: RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateWithoutGivenGoldInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedSections?: ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type GoldsmithCreateWithoutDeliveriesInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutDeliveriesInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
  }

  export type JobcardCreateWithoutDeliveriesInput = {
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockCreateNestedManyWithoutJobcardInput
    total?: TotalCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    goldsmithId: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutJobcardInput
    total?: TotalUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutDeliveriesInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
  }

  export type deductionCreateWithoutItemDeliveryInput = {
    type?: string | null
    weight?: number | null
    stoneWt?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deductionUncheckedCreateWithoutItemDeliveryInput = {
    id?: number
    type?: string | null
    weight?: number | null
    stoneWt?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deductionCreateOrConnectWithoutItemDeliveryInput = {
    where: deductionWhereUniqueInput
    create: XOR<deductionCreateWithoutItemDeliveryInput, deductionUncheckedCreateWithoutItemDeliveryInput>
  }

  export type deductionCreateManyItemDeliveryInputEnvelope = {
    data: deductionCreateManyItemDeliveryInput | deductionCreateManyItemDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type GoldsmithUpsertWithoutDeliveriesInput = {
    update: XOR<GoldsmithUpdateWithoutDeliveriesInput, GoldsmithUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutDeliveriesInput, GoldsmithUncheckedUpdateWithoutDeliveriesInput>
  }

  export type GoldsmithUpdateWithoutDeliveriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type JobcardUpsertWithoutDeliveriesInput = {
    update: XOR<JobcardUpdateWithoutDeliveriesInput, JobcardUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutDeliveriesInput, JobcardUncheckedUpdateWithoutDeliveriesInput>
  }

  export type JobcardUpdateWithoutDeliveriesInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUpdateManyWithoutJobcardNestedInput
    total?: TotalUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutJobcardNestedInput
    total?: TotalUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type deductionUpsertWithWhereUniqueWithoutItemDeliveryInput = {
    where: deductionWhereUniqueInput
    update: XOR<deductionUpdateWithoutItemDeliveryInput, deductionUncheckedUpdateWithoutItemDeliveryInput>
    create: XOR<deductionCreateWithoutItemDeliveryInput, deductionUncheckedCreateWithoutItemDeliveryInput>
  }

  export type deductionUpdateWithWhereUniqueWithoutItemDeliveryInput = {
    where: deductionWhereUniqueInput
    data: XOR<deductionUpdateWithoutItemDeliveryInput, deductionUncheckedUpdateWithoutItemDeliveryInput>
  }

  export type deductionUpdateManyWithWhereWithoutItemDeliveryInput = {
    where: deductionScalarWhereInput
    data: XOR<deductionUpdateManyMutationInput, deductionUncheckedUpdateManyWithoutItemDeliveryInput>
  }

  export type deductionScalarWhereInput = {
    AND?: deductionScalarWhereInput | deductionScalarWhereInput[]
    OR?: deductionScalarWhereInput[]
    NOT?: deductionScalarWhereInput | deductionScalarWhereInput[]
    id?: IntFilter<"deduction"> | number
    type?: StringNullableFilter<"deduction"> | string | null
    deliveryId?: IntFilter<"deduction"> | number
    weight?: FloatNullableFilter<"deduction"> | number | null
    stoneWt?: FloatNullableFilter<"deduction"> | number | null
    createdAt?: DateTimeFilter<"deduction"> | Date | string
    updatedAt?: DateTimeFilter<"deduction"> | Date | string
  }

  export type itemDeliveryCreateWithoutDeductionInput = {
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutDeliveriesInput
    jobcard?: JobcardCreateNestedOneWithoutDeliveriesInput
  }

  export type itemDeliveryUncheckedCreateWithoutDeductionInput = {
    id?: number
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    goldsmithId?: number | null
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryCreateOrConnectWithoutDeductionInput = {
    where: itemDeliveryWhereUniqueInput
    create: XOR<itemDeliveryCreateWithoutDeductionInput, itemDeliveryUncheckedCreateWithoutDeductionInput>
  }

  export type itemDeliveryUpsertWithoutDeductionInput = {
    update: XOR<itemDeliveryUpdateWithoutDeductionInput, itemDeliveryUncheckedUpdateWithoutDeductionInput>
    create: XOR<itemDeliveryCreateWithoutDeductionInput, itemDeliveryUncheckedCreateWithoutDeductionInput>
    where?: itemDeliveryWhereInput
  }

  export type itemDeliveryUpdateToOneWithWhereWithoutDeductionInput = {
    where?: itemDeliveryWhereInput
    data: XOR<itemDeliveryUpdateWithoutDeductionInput, itemDeliveryUncheckedUpdateWithoutDeductionInput>
  }

  export type itemDeliveryUpdateWithoutDeductionInput = {
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutDeliveriesNestedInput
    jobcard?: JobcardUpdateOneWithoutDeliveriesNestedInput
  }

  export type itemDeliveryUncheckedUpdateWithoutDeductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobcardCreateWithoutTotalInput = {
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutTotalInput = {
    id?: number
    goldsmithId: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutTotalInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutTotalInput, JobcardUncheckedCreateWithoutTotalInput>
  }

  export type GoldsmithCreateWithoutTotalsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutTotalsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutTotalsInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
  }

  export type JobcardUpsertWithoutTotalInput = {
    update: XOR<JobcardUpdateWithoutTotalInput, JobcardUncheckedUpdateWithoutTotalInput>
    create: XOR<JobcardCreateWithoutTotalInput, JobcardUncheckedCreateWithoutTotalInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutTotalInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutTotalInput, JobcardUncheckedUpdateWithoutTotalInput>
  }

  export type JobcardUpdateWithoutTotalInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutTotalInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type GoldsmithUpsertWithoutTotalsInput = {
    update: XOR<GoldsmithUpdateWithoutTotalsInput, GoldsmithUncheckedUpdateWithoutTotalsInput>
    create: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutTotalsInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutTotalsInput, GoldsmithUncheckedUpdateWithoutTotalsInput>
  }

  export type GoldsmithUpdateWithoutTotalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutTotalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type RawGoldLogsCreateWithoutReceivedSectionsInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    rawGoldStock?: RawgoldStockCreateNestedOneWithoutRawGoldLogsInput
    givenGold?: givenGoldCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateWithoutReceivedSectionsInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsCreateOrConnectWithoutReceivedSectionsInput = {
    where: RawGoldLogsWhereUniqueInput
    create: XOR<RawGoldLogsCreateWithoutReceivedSectionsInput, RawGoldLogsUncheckedCreateWithoutReceivedSectionsInput>
  }

  export type JobcardCreateWithoutReceivedInput = {
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockCreateNestedManyWithoutJobcardInput
    total?: TotalCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutReceivedInput = {
    id?: number
    goldsmithId: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    productStock?: ProductStockUncheckedCreateNestedManyWithoutJobcardInput
    total?: TotalUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutReceivedInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
  }

  export type GoldsmithCreateWithoutReceivedInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutReceivedInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutReceivedInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
  }

  export type RawGoldLogsUpsertWithoutReceivedSectionsInput = {
    update: XOR<RawGoldLogsUpdateWithoutReceivedSectionsInput, RawGoldLogsUncheckedUpdateWithoutReceivedSectionsInput>
    create: XOR<RawGoldLogsCreateWithoutReceivedSectionsInput, RawGoldLogsUncheckedCreateWithoutReceivedSectionsInput>
    where?: RawGoldLogsWhereInput
  }

  export type RawGoldLogsUpdateToOneWithWhereWithoutReceivedSectionsInput = {
    where?: RawGoldLogsWhereInput
    data: XOR<RawGoldLogsUpdateWithoutReceivedSectionsInput, RawGoldLogsUncheckedUpdateWithoutReceivedSectionsInput>
  }

  export type RawGoldLogsUpdateWithoutReceivedSectionsInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldStock?: RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput
    givenGold?: givenGoldUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateWithoutReceivedSectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type JobcardUpsertWithoutReceivedInput = {
    update: XOR<JobcardUpdateWithoutReceivedInput, JobcardUncheckedUpdateWithoutReceivedInput>
    create: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutReceivedInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutReceivedInput, JobcardUncheckedUpdateWithoutReceivedInput>
  }

  export type JobcardUpdateWithoutReceivedInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUpdateManyWithoutJobcardNestedInput
    total?: TotalUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutJobcardNestedInput
    total?: TotalUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type GoldsmithUpsertWithoutReceivedInput = {
    update: XOR<GoldsmithUpdateWithoutReceivedInput, GoldsmithUncheckedUpdateWithoutReceivedInput>
    create: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutReceivedInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutReceivedInput, GoldsmithUncheckedUpdateWithoutReceivedInput>
  }

  export type GoldsmithUpdateWithoutReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type MasterTouchCreateWithoutRawGoldStockInput = {
    touch: number
    createdAt?: Date | string
  }

  export type MasterTouchUncheckedCreateWithoutRawGoldStockInput = {
    id?: number
    touch: number
    createdAt?: Date | string
  }

  export type MasterTouchCreateOrConnectWithoutRawGoldStockInput = {
    where: MasterTouchWhereUniqueInput
    create: XOR<MasterTouchCreateWithoutRawGoldStockInput, MasterTouchUncheckedCreateWithoutRawGoldStockInput>
  }

  export type RawGoldLogsCreateWithoutRawGoldStockInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateWithoutRawGoldStockInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsCreateOrConnectWithoutRawGoldStockInput = {
    where: RawGoldLogsWhereUniqueInput
    create: XOR<RawGoldLogsCreateWithoutRawGoldStockInput, RawGoldLogsUncheckedCreateWithoutRawGoldStockInput>
  }

  export type RawGoldLogsCreateManyRawGoldStockInputEnvelope = {
    data: RawGoldLogsCreateManyRawGoldStockInput | RawGoldLogsCreateManyRawGoldStockInput[]
    skipDuplicates?: boolean
  }

  export type MasterTouchUpsertWithoutRawGoldStockInput = {
    update: XOR<MasterTouchUpdateWithoutRawGoldStockInput, MasterTouchUncheckedUpdateWithoutRawGoldStockInput>
    create: XOR<MasterTouchCreateWithoutRawGoldStockInput, MasterTouchUncheckedCreateWithoutRawGoldStockInput>
    where?: MasterTouchWhereInput
  }

  export type MasterTouchUpdateToOneWithWhereWithoutRawGoldStockInput = {
    where?: MasterTouchWhereInput
    data: XOR<MasterTouchUpdateWithoutRawGoldStockInput, MasterTouchUncheckedUpdateWithoutRawGoldStockInput>
  }

  export type MasterTouchUpdateWithoutRawGoldStockInput = {
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterTouchUncheckedUpdateWithoutRawGoldStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawGoldLogsUpsertWithWhereUniqueWithoutRawGoldStockInput = {
    where: RawGoldLogsWhereUniqueInput
    update: XOR<RawGoldLogsUpdateWithoutRawGoldStockInput, RawGoldLogsUncheckedUpdateWithoutRawGoldStockInput>
    create: XOR<RawGoldLogsCreateWithoutRawGoldStockInput, RawGoldLogsUncheckedCreateWithoutRawGoldStockInput>
  }

  export type RawGoldLogsUpdateWithWhereUniqueWithoutRawGoldStockInput = {
    where: RawGoldLogsWhereUniqueInput
    data: XOR<RawGoldLogsUpdateWithoutRawGoldStockInput, RawGoldLogsUncheckedUpdateWithoutRawGoldStockInput>
  }

  export type RawGoldLogsUpdateManyWithWhereWithoutRawGoldStockInput = {
    where: RawGoldLogsScalarWhereInput
    data: XOR<RawGoldLogsUpdateManyMutationInput, RawGoldLogsUncheckedUpdateManyWithoutRawGoldStockInput>
  }

  export type RawGoldLogsScalarWhereInput = {
    AND?: RawGoldLogsScalarWhereInput | RawGoldLogsScalarWhereInput[]
    OR?: RawGoldLogsScalarWhereInput[]
    NOT?: RawGoldLogsScalarWhereInput | RawGoldLogsScalarWhereInput[]
    id?: IntFilter<"RawGoldLogs"> | number
    rawGoldStockId?: IntFilter<"RawGoldLogs"> | number
    weight?: FloatNullableFilter<"RawGoldLogs"> | number | null
    touch?: FloatNullableFilter<"RawGoldLogs"> | number | null
    purity?: FloatNullableFilter<"RawGoldLogs"> | number | null
  }

  export type RawgoldStockCreateWithoutRawGoldLogsInput = {
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
    masterTouch?: MasterTouchCreateNestedOneWithoutRawGoldStockInput
  }

  export type RawgoldStockUncheckedCreateWithoutRawGoldLogsInput = {
    id?: number
    touchId: number
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
  }

  export type RawgoldStockCreateOrConnectWithoutRawGoldLogsInput = {
    where: RawgoldStockWhereUniqueInput
    create: XOR<RawgoldStockCreateWithoutRawGoldLogsInput, RawgoldStockUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type givenGoldCreateWithoutRawGoldLogsInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutGivenGoldInput
    jobcard?: JobcardCreateNestedOneWithoutGivenGoldInput
  }

  export type givenGoldUncheckedCreateWithoutRawGoldLogsInput = {
    id?: number
    goldsmithId?: number | null
    jobcardId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldCreateOrConnectWithoutRawGoldLogsInput = {
    where: givenGoldWhereUniqueInput
    create: XOR<givenGoldCreateWithoutRawGoldLogsInput, givenGoldUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type givenGoldCreateManyRawGoldLogsInputEnvelope = {
    data: givenGoldCreateManyRawGoldLogsInput | givenGoldCreateManyRawGoldLogsInput[]
    skipDuplicates?: boolean
  }

  export type ReceivedsectionCreateWithoutRawGoldLogsInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutReceivedInput
    goldsmith?: GoldsmithCreateNestedOneWithoutReceivedInput
  }

  export type ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    jobcardId: number
    goldsmithId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateOrConnectWithoutRawGoldLogsInput = {
    where: ReceivedsectionWhereUniqueInput
    create: XOR<ReceivedsectionCreateWithoutRawGoldLogsInput, ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type ReceivedsectionCreateManyRawGoldLogsInputEnvelope = {
    data: ReceivedsectionCreateManyRawGoldLogsInput | ReceivedsectionCreateManyRawGoldLogsInput[]
    skipDuplicates?: boolean
  }

  export type billReceivedCreateWithoutRawGoldLogsInput = {
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
    bill?: BillCreateNestedOneWithoutBillReceiveInput
    customers: CustomerCreateNestedOneWithoutBillReceiveInput
  }

  export type billReceivedUncheckedCreateWithoutRawGoldLogsInput = {
    id?: number
    billId?: number | null
    customer_id: number
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type billReceivedCreateOrConnectWithoutRawGoldLogsInput = {
    where: billReceivedWhereUniqueInput
    create: XOR<billReceivedCreateWithoutRawGoldLogsInput, billReceivedUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type billReceivedCreateManyRawGoldLogsInputEnvelope = {
    data: billReceivedCreateManyRawGoldLogsInput | billReceivedCreateManyRawGoldLogsInput[]
    skipDuplicates?: boolean
  }

  export type receiptVoucherCreateWithoutRawGoldLogsInput = {
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
    customers: CustomerCreateNestedOneWithoutReceiptVoucherInput
  }

  export type receiptVoucherUncheckedCreateWithoutRawGoldLogsInput = {
    id?: number
    customer_id: number
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type receiptVoucherCreateOrConnectWithoutRawGoldLogsInput = {
    where: receiptVoucherWhereUniqueInput
    create: XOR<receiptVoucherCreateWithoutRawGoldLogsInput, receiptVoucherUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type receiptVoucherCreateManyRawGoldLogsInputEnvelope = {
    data: receiptVoucherCreateManyRawGoldLogsInput | receiptVoucherCreateManyRawGoldLogsInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutRawGoldLogsInput = {
    date: Date | string
    type: string
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutRawGoldLogsInput = {
    id?: number
    date: Date | string
    type: string
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    customerId: number
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutRawGoldLogsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutRawGoldLogsInput, TransactionUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type TransactionCreateManyRawGoldLogsInputEnvelope = {
    data: TransactionCreateManyRawGoldLogsInput | TransactionCreateManyRawGoldLogsInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseTrackerCreateWithoutRawGoldLogsInput = {
    gold?: number | null
    touch?: number | null
    purity?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput = {
    id?: number
    gold?: number | null
    touch?: number | null
    purity?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseTrackerCreateOrConnectWithoutRawGoldLogsInput = {
    where: ExpenseTrackerWhereUniqueInput
    create: XOR<ExpenseTrackerCreateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type ExpenseTrackerCreateManyRawGoldLogsInputEnvelope = {
    data: ExpenseTrackerCreateManyRawGoldLogsInput | ExpenseTrackerCreateManyRawGoldLogsInput[]
    skipDuplicates?: boolean
  }

  export type RawgoldStockUpsertWithoutRawGoldLogsInput = {
    update: XOR<RawgoldStockUpdateWithoutRawGoldLogsInput, RawgoldStockUncheckedUpdateWithoutRawGoldLogsInput>
    create: XOR<RawgoldStockCreateWithoutRawGoldLogsInput, RawgoldStockUncheckedCreateWithoutRawGoldLogsInput>
    where?: RawgoldStockWhereInput
  }

  export type RawgoldStockUpdateToOneWithWhereWithoutRawGoldLogsInput = {
    where?: RawgoldStockWhereInput
    data: XOR<RawgoldStockUpdateWithoutRawGoldLogsInput, RawgoldStockUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type RawgoldStockUpdateWithoutRawGoldLogsInput = {
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
    masterTouch?: MasterTouchUpdateOneWithoutRawGoldStockNestedInput
  }

  export type RawgoldStockUncheckedUpdateWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    touchId?: IntFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type givenGoldUpsertWithWhereUniqueWithoutRawGoldLogsInput = {
    where: givenGoldWhereUniqueInput
    update: XOR<givenGoldUpdateWithoutRawGoldLogsInput, givenGoldUncheckedUpdateWithoutRawGoldLogsInput>
    create: XOR<givenGoldCreateWithoutRawGoldLogsInput, givenGoldUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type givenGoldUpdateWithWhereUniqueWithoutRawGoldLogsInput = {
    where: givenGoldWhereUniqueInput
    data: XOR<givenGoldUpdateWithoutRawGoldLogsInput, givenGoldUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type givenGoldUpdateManyWithWhereWithoutRawGoldLogsInput = {
    where: givenGoldScalarWhereInput
    data: XOR<givenGoldUpdateManyMutationInput, givenGoldUncheckedUpdateManyWithoutRawGoldLogsInput>
  }

  export type ReceivedsectionUpsertWithWhereUniqueWithoutRawGoldLogsInput = {
    where: ReceivedsectionWhereUniqueInput
    update: XOR<ReceivedsectionUpdateWithoutRawGoldLogsInput, ReceivedsectionUncheckedUpdateWithoutRawGoldLogsInput>
    create: XOR<ReceivedsectionCreateWithoutRawGoldLogsInput, ReceivedsectionUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type ReceivedsectionUpdateWithWhereUniqueWithoutRawGoldLogsInput = {
    where: ReceivedsectionWhereUniqueInput
    data: XOR<ReceivedsectionUpdateWithoutRawGoldLogsInput, ReceivedsectionUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type ReceivedsectionUpdateManyWithWhereWithoutRawGoldLogsInput = {
    where: ReceivedsectionScalarWhereInput
    data: XOR<ReceivedsectionUpdateManyMutationInput, ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsInput>
  }

  export type billReceivedUpsertWithWhereUniqueWithoutRawGoldLogsInput = {
    where: billReceivedWhereUniqueInput
    update: XOR<billReceivedUpdateWithoutRawGoldLogsInput, billReceivedUncheckedUpdateWithoutRawGoldLogsInput>
    create: XOR<billReceivedCreateWithoutRawGoldLogsInput, billReceivedUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type billReceivedUpdateWithWhereUniqueWithoutRawGoldLogsInput = {
    where: billReceivedWhereUniqueInput
    data: XOR<billReceivedUpdateWithoutRawGoldLogsInput, billReceivedUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type billReceivedUpdateManyWithWhereWithoutRawGoldLogsInput = {
    where: billReceivedScalarWhereInput
    data: XOR<billReceivedUpdateManyMutationInput, billReceivedUncheckedUpdateManyWithoutRawGoldLogsInput>
  }

  export type receiptVoucherUpsertWithWhereUniqueWithoutRawGoldLogsInput = {
    where: receiptVoucherWhereUniqueInput
    update: XOR<receiptVoucherUpdateWithoutRawGoldLogsInput, receiptVoucherUncheckedUpdateWithoutRawGoldLogsInput>
    create: XOR<receiptVoucherCreateWithoutRawGoldLogsInput, receiptVoucherUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type receiptVoucherUpdateWithWhereUniqueWithoutRawGoldLogsInput = {
    where: receiptVoucherWhereUniqueInput
    data: XOR<receiptVoucherUpdateWithoutRawGoldLogsInput, receiptVoucherUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type receiptVoucherUpdateManyWithWhereWithoutRawGoldLogsInput = {
    where: receiptVoucherScalarWhereInput
    data: XOR<receiptVoucherUpdateManyMutationInput, receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutRawGoldLogsInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutRawGoldLogsInput, TransactionUncheckedUpdateWithoutRawGoldLogsInput>
    create: XOR<TransactionCreateWithoutRawGoldLogsInput, TransactionUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutRawGoldLogsInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutRawGoldLogsInput, TransactionUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type TransactionUpdateManyWithWhereWithoutRawGoldLogsInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutRawGoldLogsInput>
  }

  export type ExpenseTrackerUpsertWithWhereUniqueWithoutRawGoldLogsInput = {
    where: ExpenseTrackerWhereUniqueInput
    update: XOR<ExpenseTrackerUpdateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedUpdateWithoutRawGoldLogsInput>
    create: XOR<ExpenseTrackerCreateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedCreateWithoutRawGoldLogsInput>
  }

  export type ExpenseTrackerUpdateWithWhereUniqueWithoutRawGoldLogsInput = {
    where: ExpenseTrackerWhereUniqueInput
    data: XOR<ExpenseTrackerUpdateWithoutRawGoldLogsInput, ExpenseTrackerUncheckedUpdateWithoutRawGoldLogsInput>
  }

  export type ExpenseTrackerUpdateManyWithWhereWithoutRawGoldLogsInput = {
    where: ExpenseTrackerScalarWhereInput
    data: XOR<ExpenseTrackerUpdateManyMutationInput, ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsInput>
  }

  export type ExpenseTrackerScalarWhereInput = {
    AND?: ExpenseTrackerScalarWhereInput | ExpenseTrackerScalarWhereInput[]
    OR?: ExpenseTrackerScalarWhereInput[]
    NOT?: ExpenseTrackerScalarWhereInput | ExpenseTrackerScalarWhereInput[]
    id?: IntFilter<"ExpenseTracker"> | number
    logId?: IntNullableFilter<"ExpenseTracker"> | number | null
    gold?: FloatNullableFilter<"ExpenseTracker"> | number | null
    touch?: FloatNullableFilter<"ExpenseTracker"> | number | null
    purity?: FloatNullableFilter<"ExpenseTracker"> | number | null
    description?: StringNullableFilter<"ExpenseTracker"> | string | null
    createdAt?: DateTimeFilter<"ExpenseTracker"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseTracker"> | Date | string
  }

  export type RawGoldLogsCreateWithoutExpenseTrackerInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    rawGoldStock?: RawgoldStockCreateNestedOneWithoutRawGoldLogsInput
    givenGold?: givenGoldCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateWithoutExpenseTrackerInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsCreateOrConnectWithoutExpenseTrackerInput = {
    where: RawGoldLogsWhereUniqueInput
    create: XOR<RawGoldLogsCreateWithoutExpenseTrackerInput, RawGoldLogsUncheckedCreateWithoutExpenseTrackerInput>
  }

  export type RawGoldLogsUpsertWithoutExpenseTrackerInput = {
    update: XOR<RawGoldLogsUpdateWithoutExpenseTrackerInput, RawGoldLogsUncheckedUpdateWithoutExpenseTrackerInput>
    create: XOR<RawGoldLogsCreateWithoutExpenseTrackerInput, RawGoldLogsUncheckedCreateWithoutExpenseTrackerInput>
    where?: RawGoldLogsWhereInput
  }

  export type RawGoldLogsUpdateToOneWithWhereWithoutExpenseTrackerInput = {
    where?: RawGoldLogsWhereInput
    data: XOR<RawGoldLogsUpdateWithoutExpenseTrackerInput, RawGoldLogsUncheckedUpdateWithoutExpenseTrackerInput>
  }

  export type RawGoldLogsUpdateWithoutExpenseTrackerInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldStock?: RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput
    givenGold?: givenGoldUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateWithoutExpenseTrackerInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type GoldsmithCreateWithoutSummariesInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutSummariesInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutSummariesInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
  }

  export type GoldsmithUpsertWithoutSummariesInput = {
    update: XOR<GoldsmithUpdateWithoutSummariesInput, GoldsmithUncheckedUpdateWithoutSummariesInput>
    create: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutSummariesInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutSummariesInput, GoldsmithUncheckedUpdateWithoutSummariesInput>
  }

  export type GoldsmithUpdateWithoutSummariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutSummariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithCreateWithoutRepairsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutRepairsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutRepairsInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
  }

  export type GoldsmithUpsertWithoutRepairsInput = {
    update: XOR<GoldsmithUpdateWithoutRepairsInput, GoldsmithUncheckedUpdateWithoutRepairsInput>
    create: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutRepairsInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutRepairsInput, GoldsmithUncheckedUpdateWithoutRepairsInput>
  }

  export type GoldsmithUpdateWithoutRepairsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutRepairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type JobcardCreateWithoutProductStockInput = {
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
    total?: TotalCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutProductStockInput = {
    id?: number
    goldsmithId: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
    total?: TotalUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutProductStockInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutProductStockInput, JobcardUncheckedCreateWithoutProductStockInput>
  }

  export type JobcardUpsertWithoutProductStockInput = {
    update: XOR<JobcardUpdateWithoutProductStockInput, JobcardUncheckedUpdateWithoutProductStockInput>
    create: XOR<JobcardCreateWithoutProductStockInput, JobcardUncheckedCreateWithoutProductStockInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutProductStockInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutProductStockInput, JobcardUncheckedUpdateWithoutProductStockInput>
  }

  export type JobcardUpdateWithoutProductStockInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
    total?: TotalUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutProductStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
    total?: TotalUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type CustomerCreateWithoutBillInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutBillInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceUncheckedCreateNestedOneWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutBillInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutBillInput, CustomerUncheckedCreateWithoutBillInput>
  }

  export type OrderItemsCreateWithoutBillInput = {
    productName: string
    count?: number | null
    weight?: number | null
    stoneWeight?: number | null
    afterWeight?: number | null
    percentage?: number | null
    finalWeight?: number | null
    createdAt?: Date | string
  }

  export type OrderItemsUncheckedCreateWithoutBillInput = {
    id?: number
    productName: string
    count?: number | null
    weight?: number | null
    stoneWeight?: number | null
    afterWeight?: number | null
    percentage?: number | null
    finalWeight?: number | null
    createdAt?: Date | string
  }

  export type OrderItemsCreateOrConnectWithoutBillInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutBillInput, OrderItemsUncheckedCreateWithoutBillInput>
  }

  export type OrderItemsCreateManyBillInputEnvelope = {
    data: OrderItemsCreateManyBillInput | OrderItemsCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type billReceivedCreateWithoutBillInput = {
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
    customers: CustomerCreateNestedOneWithoutBillReceiveInput
    rawGoldLogs?: RawGoldLogsCreateNestedOneWithoutBillReceiveInput
  }

  export type billReceivedUncheckedCreateWithoutBillInput = {
    id?: number
    customer_id: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type billReceivedCreateOrConnectWithoutBillInput = {
    where: billReceivedWhereUniqueInput
    create: XOR<billReceivedCreateWithoutBillInput, billReceivedUncheckedCreateWithoutBillInput>
  }

  export type billReceivedCreateManyBillInputEnvelope = {
    data: billReceivedCreateManyBillInput | billReceivedCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutBillInput = {
    update: XOR<CustomerUpdateWithoutBillInput, CustomerUncheckedUpdateWithoutBillInput>
    create: XOR<CustomerCreateWithoutBillInput, CustomerUncheckedCreateWithoutBillInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutBillInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutBillInput, CustomerUncheckedUpdateWithoutBillInput>
  }

  export type CustomerUpdateWithoutBillInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutBillInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUncheckedUpdateOneWithoutCustomersNestedInput
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutBillInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutBillInput, OrderItemsUncheckedUpdateWithoutBillInput>
    create: XOR<OrderItemsCreateWithoutBillInput, OrderItemsUncheckedCreateWithoutBillInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutBillInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutBillInput, OrderItemsUncheckedUpdateWithoutBillInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutBillInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutBillInput>
  }

  export type OrderItemsScalarWhereInput = {
    AND?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
    OR?: OrderItemsScalarWhereInput[]
    NOT?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
    id?: IntFilter<"OrderItems"> | number
    billId?: IntFilter<"OrderItems"> | number
    productName?: StringFilter<"OrderItems"> | string
    count?: IntNullableFilter<"OrderItems"> | number | null
    weight?: FloatNullableFilter<"OrderItems"> | number | null
    stoneWeight?: FloatNullableFilter<"OrderItems"> | number | null
    afterWeight?: FloatNullableFilter<"OrderItems"> | number | null
    percentage?: FloatNullableFilter<"OrderItems"> | number | null
    finalWeight?: FloatNullableFilter<"OrderItems"> | number | null
    createdAt?: DateTimeFilter<"OrderItems"> | Date | string
  }

  export type billReceivedUpsertWithWhereUniqueWithoutBillInput = {
    where: billReceivedWhereUniqueInput
    update: XOR<billReceivedUpdateWithoutBillInput, billReceivedUncheckedUpdateWithoutBillInput>
    create: XOR<billReceivedCreateWithoutBillInput, billReceivedUncheckedCreateWithoutBillInput>
  }

  export type billReceivedUpdateWithWhereUniqueWithoutBillInput = {
    where: billReceivedWhereUniqueInput
    data: XOR<billReceivedUpdateWithoutBillInput, billReceivedUncheckedUpdateWithoutBillInput>
  }

  export type billReceivedUpdateManyWithWhereWithoutBillInput = {
    where: billReceivedScalarWhereInput
    data: XOR<billReceivedUpdateManyMutationInput, billReceivedUncheckedUpdateManyWithoutBillInput>
  }

  export type BillCreateWithoutOrdersInput = {
    date?: Date | string | null
    time?: Date | string | null
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    customers: CustomerCreateNestedOneWithoutBillInput
    billReceive?: billReceivedCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutOrdersInput = {
    id?: number
    date?: Date | string | null
    time?: Date | string | null
    customer_id: number
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutOrdersInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
  }

  export type BillUpsertWithoutOrdersInput = {
    update: XOR<BillUpdateWithoutOrdersInput, BillUncheckedUpdateWithoutOrdersInput>
    create: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutOrdersInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutOrdersInput, BillUncheckedUpdateWithoutOrdersInput>
  }

  export type BillUpdateWithoutOrdersInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutBillNestedInput
    billReceive?: billReceivedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer_id?: IntFieldUpdateOperationsInput | number
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billReceive?: billReceivedUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillCreateWithoutBillReceiveInput = {
    date?: Date | string | null
    time?: Date | string | null
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    customers: CustomerCreateNestedOneWithoutBillInput
    orders?: OrderItemsCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutBillReceiveInput = {
    id?: number
    date?: Date | string | null
    time?: Date | string | null
    customer_id: number
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
    orders?: OrderItemsUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutBillReceiveInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutBillReceiveInput, BillUncheckedCreateWithoutBillReceiveInput>
  }

  export type CustomerCreateWithoutBillReceiveInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
    bill?: BillCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutBillReceiveInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
    bill?: BillUncheckedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceUncheckedCreateNestedOneWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutBillReceiveInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutBillReceiveInput, CustomerUncheckedCreateWithoutBillReceiveInput>
  }

  export type RawGoldLogsCreateWithoutBillReceiveInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    rawGoldStock?: RawgoldStockCreateNestedOneWithoutRawGoldLogsInput
    givenGold?: givenGoldCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateWithoutBillReceiveInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsCreateOrConnectWithoutBillReceiveInput = {
    where: RawGoldLogsWhereUniqueInput
    create: XOR<RawGoldLogsCreateWithoutBillReceiveInput, RawGoldLogsUncheckedCreateWithoutBillReceiveInput>
  }

  export type BillUpsertWithoutBillReceiveInput = {
    update: XOR<BillUpdateWithoutBillReceiveInput, BillUncheckedUpdateWithoutBillReceiveInput>
    create: XOR<BillCreateWithoutBillReceiveInput, BillUncheckedCreateWithoutBillReceiveInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutBillReceiveInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutBillReceiveInput, BillUncheckedUpdateWithoutBillReceiveInput>
  }

  export type BillUpdateWithoutBillReceiveInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutBillNestedInput
    orders?: OrderItemsUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutBillReceiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer_id?: IntFieldUpdateOperationsInput | number
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemsUncheckedUpdateManyWithoutBillNestedInput
  }

  export type CustomerUpsertWithoutBillReceiveInput = {
    update: XOR<CustomerUpdateWithoutBillReceiveInput, CustomerUncheckedUpdateWithoutBillReceiveInput>
    create: XOR<CustomerCreateWithoutBillReceiveInput, CustomerUncheckedCreateWithoutBillReceiveInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutBillReceiveInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutBillReceiveInput, CustomerUncheckedUpdateWithoutBillReceiveInput>
  }

  export type CustomerUpdateWithoutBillReceiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
    bill?: BillUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutBillReceiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
    bill?: BillUncheckedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUncheckedUpdateOneWithoutCustomersNestedInput
  }

  export type RawGoldLogsUpsertWithoutBillReceiveInput = {
    update: XOR<RawGoldLogsUpdateWithoutBillReceiveInput, RawGoldLogsUncheckedUpdateWithoutBillReceiveInput>
    create: XOR<RawGoldLogsCreateWithoutBillReceiveInput, RawGoldLogsUncheckedCreateWithoutBillReceiveInput>
    where?: RawGoldLogsWhereInput
  }

  export type RawGoldLogsUpdateToOneWithWhereWithoutBillReceiveInput = {
    where?: RawGoldLogsWhereInput
    data: XOR<RawGoldLogsUpdateWithoutBillReceiveInput, RawGoldLogsUncheckedUpdateWithoutBillReceiveInput>
  }

  export type RawGoldLogsUpdateWithoutBillReceiveInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldStock?: RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput
    givenGold?: givenGoldUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateWithoutBillReceiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type CustomerCreateWithoutReceiptVoucherInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
    bill?: BillCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutReceiptVoucherInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
    bill?: BillUncheckedCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutCustomersInput
    customerBillBalance?: customerBillBalanceUncheckedCreateNestedOneWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutReceiptVoucherInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReceiptVoucherInput, CustomerUncheckedCreateWithoutReceiptVoucherInput>
  }

  export type RawGoldLogsCreateWithoutReceiptVoucherInput = {
    weight?: number | null
    touch?: number | null
    purity?: number | null
    rawGoldStock?: RawgoldStockCreateNestedOneWithoutRawGoldLogsInput
    givenGold?: givenGoldCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsUncheckedCreateWithoutReceiptVoucherInput = {
    id?: number
    rawGoldStockId: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutRawGoldLogsInput
    receivedSections?: ReceivedsectionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutRawGoldLogsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutRawGoldLogsInput
    expenseTracker?: ExpenseTrackerUncheckedCreateNestedManyWithoutRawGoldLogsInput
  }

  export type RawGoldLogsCreateOrConnectWithoutReceiptVoucherInput = {
    where: RawGoldLogsWhereUniqueInput
    create: XOR<RawGoldLogsCreateWithoutReceiptVoucherInput, RawGoldLogsUncheckedCreateWithoutReceiptVoucherInput>
  }

  export type CustomerUpsertWithoutReceiptVoucherInput = {
    update: XOR<CustomerUpdateWithoutReceiptVoucherInput, CustomerUncheckedUpdateWithoutReceiptVoucherInput>
    create: XOR<CustomerCreateWithoutReceiptVoucherInput, CustomerUncheckedCreateWithoutReceiptVoucherInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutReceiptVoucherInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutReceiptVoucherInput, CustomerUncheckedUpdateWithoutReceiptVoucherInput>
  }

  export type CustomerUpdateWithoutReceiptVoucherInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
    bill?: BillUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReceiptVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
    bill?: BillUncheckedUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutCustomersNestedInput
    customerBillBalance?: customerBillBalanceUncheckedUpdateOneWithoutCustomersNestedInput
  }

  export type RawGoldLogsUpsertWithoutReceiptVoucherInput = {
    update: XOR<RawGoldLogsUpdateWithoutReceiptVoucherInput, RawGoldLogsUncheckedUpdateWithoutReceiptVoucherInput>
    create: XOR<RawGoldLogsCreateWithoutReceiptVoucherInput, RawGoldLogsUncheckedCreateWithoutReceiptVoucherInput>
    where?: RawGoldLogsWhereInput
  }

  export type RawGoldLogsUpdateToOneWithWhereWithoutReceiptVoucherInput = {
    where?: RawGoldLogsWhereInput
    data: XOR<RawGoldLogsUpdateWithoutReceiptVoucherInput, RawGoldLogsUncheckedUpdateWithoutReceiptVoucherInput>
  }

  export type RawGoldLogsUpdateWithoutReceiptVoucherInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldStock?: RawgoldStockUpdateOneWithoutRawGoldLogsNestedInput
    givenGold?: givenGoldUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateWithoutReceiptVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawGoldStockId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type CustomerCreateWithoutCustomerBillBalanceInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
    bill?: BillCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutCustomerBillBalanceInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
    bill?: BillUncheckedCreateNestedManyWithoutCustomersInput
    billReceive?: billReceivedUncheckedCreateNestedManyWithoutCustomersInput
    receiptVoucher?: receiptVoucherUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutCustomerBillBalanceInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerBillBalanceInput, CustomerUncheckedCreateWithoutCustomerBillBalanceInput>
  }

  export type CustomerUpsertWithoutCustomerBillBalanceInput = {
    update: XOR<CustomerUpdateWithoutCustomerBillBalanceInput, CustomerUncheckedUpdateWithoutCustomerBillBalanceInput>
    create: XOR<CustomerCreateWithoutCustomerBillBalanceInput, CustomerUncheckedCreateWithoutCustomerBillBalanceInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerBillBalanceInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerBillBalanceInput, CustomerUncheckedUpdateWithoutCustomerBillBalanceInput>
  }

  export type CustomerUpdateWithoutCustomerBillBalanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
    bill?: BillUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerBillBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
    bill?: BillUncheckedUpdateManyWithoutCustomersNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutCustomersNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type TransactionCreateManyCustomerInput = {
    id?: number
    date: Date | string
    type: string
    logId?: number | null
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    createdAt?: Date | string
  }

  export type customer_orderCreateManyCustomersInput = {
    id?: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type BillCreateManyCustomersInput = {
    id?: number
    date?: Date | string | null
    time?: Date | string | null
    billAmount: number
    hallMark?: number | null
    prevHallMark?: number | null
    PrevBalance?: number | null
    billDetailsprofit?: number | null
    Stoneprofit?: number | null
    Totalprofit?: number | null
    cashBalance?: number | null
    createdAt?: Date | string
  }

  export type billReceivedCreateManyCustomersInput = {
    id?: number
    billId?: number | null
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type receiptVoucherCreateManyCustomersInput = {
    id?: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutCustomerInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_orderUpdateWithoutCustomersInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productImages?: product_multiple_imagesUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productImages?: product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUpdateWithoutCustomersInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemsUpdateManyWithoutBillNestedInput
    billReceive?: billReceivedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemsUncheckedUpdateManyWithoutBillNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billAmount?: FloatFieldUpdateOperationsInput | number
    hallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    prevHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    PrevBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    billDetailsprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Stoneprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    Totalprofit?: NullableFloatFieldUpdateOperationsInput | number | null
    cashBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedUpdateWithoutCustomersInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneWithoutBillReceiveNestedInput
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutBillReceiveNestedInput
  }

  export type billReceivedUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type receiptVoucherUpdateWithoutCustomersInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutReceiptVoucherNestedInput
  }

  export type receiptVoucherUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type receiptVoucherUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawgoldStockCreateManyMasterTouchInput = {
    id?: number
    touch?: number | null
    weight?: number | null
    remainingWt?: number | null
  }

  export type RawgoldStockUpdateWithoutMasterTouchInput = {
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldLogs?: RawGoldLogsUpdateManyWithoutRawGoldStockNestedInput
  }

  export type RawgoldStockUncheckedUpdateWithoutMasterTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
    rawGoldLogs?: RawGoldLogsUncheckedUpdateManyWithoutRawGoldStockNestedInput
  }

  export type RawgoldStockUncheckedUpdateManyWithoutMasterTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingWt?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type product_multiple_imagesCreateManyCustomerOrderDetailsInput = {
    id?: number
    filename: string
  }

  export type product_multiple_imagesUpdateWithoutCustomerOrderDetailsInput = {
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesUncheckedUpdateWithoutCustomerOrderDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type BullionPurchaseCreateManyBullionInput = {
    id?: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
  }

  export type BullionPurchaseUpdateWithoutBullionInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenDetails?: GivenDetailUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseUncheckedUpdateWithoutBullionInput = {
    id?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenDetails?: GivenDetailUncheckedUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseUncheckedUpdateManyWithoutBullionInput = {
    id?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GivenDetailCreateManyBullionPurchaseInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
  }

  export type GivenDetailUpdateWithoutBullionPurchaseInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type GivenDetailUncheckedUpdateWithoutBullionPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type GivenDetailUncheckedUpdateManyWithoutBullionPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobcardCreateManyGoldsmithInput = {
    id?: number
    description?: string | null
    stockIsMove?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldCreateManyGoldsmithInput = {
    id?: number
    jobcardId?: number | null
    logId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryCreateManyGoldsmithInput = {
    id?: number
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateManyGoldsmithInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    logId?: number | null
    jobcardId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalCreateManyGoldsmithInput = {
    id?: number
    jobcardId?: number | null
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepairCreateManyGoldsmithInput = {
    id?: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type BalancesCreateManyGoldsmithInput = {
    id?: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobcardUpdateWithoutGoldsmithInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUpdateManyWithoutJobcardNestedInput
    total?: TotalUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
    productStock?: ProductStockUncheckedUpdateManyWithoutJobcardNestedInput
    total?: TotalUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockIsMove?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUpdateWithoutGoldsmithInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutGivenGoldNestedInput
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutGivenGoldNestedInput
  }

  export type givenGoldUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUpdateWithoutGoldsmithInput = {
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutDeliveriesNestedInput
    deduction?: deductionUpdateManyWithoutItemDeliveryNestedInput
  }

  export type itemDeliveryUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deduction?: deductionUncheckedUpdateManyWithoutItemDeliveryNestedInput
  }

  export type itemDeliveryUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUpdateWithoutGoldsmithInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutReceivedSectionsNestedInput
    jobcard?: JobcardUpdateOneWithoutReceivedNestedInput
  }

  export type ReceivedsectionUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUpdateWithoutGoldsmithInput = {
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutTotalNestedInput
  }

  export type TotalUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUpdateWithoutGoldsmithInput = {
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUpdateWithoutGoldsmithInput = {
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldCreateManyJobcardInput = {
    id?: number
    goldsmithId?: number | null
    logId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryCreateManyJobcardInput = {
    id?: number
    itemName?: string | null
    itemWeight?: number | null
    count?: number | null
    touch?: number | null
    sealName?: string | null
    netWeight?: number | null
    wastageType?: string | null
    wastageValue?: number | null
    wastagePure?: number | null
    finalPurity?: number | null
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateManyJobcardInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    logId?: number | null
    goldsmithId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStockCreateManyJobcardInput = {
    id?: number
    itemName: string
    itemWeight: number
    count: number
    touch: number
    stoneWeight: number
    wastageValue: number
    netWeight?: number | null
    wastagePure?: number | null
    finalWeight: number
    createdAt?: Date | string
  }

  export type TotalCreateManyJobcardInput = {
    id?: number
    goldsmithId: number
    givenTotal?: number | null
    deliveryTotal?: number | null
    stoneTotalWt?: number | null
    openingBalance?: number | null
    jobCardBalance?: number | null
    receivedTotal?: number | null
    isFinished?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldUpdateWithoutJobcardInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutGivenGoldNestedInput
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutGivenGoldNestedInput
  }

  export type givenGoldUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUpdateWithoutJobcardInput = {
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutDeliveriesNestedInput
    deduction?: deductionUpdateManyWithoutItemDeliveryNestedInput
  }

  export type itemDeliveryUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deduction?: deductionUncheckedUpdateManyWithoutItemDeliveryNestedInput
  }

  export type itemDeliveryUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    itemWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    sealName?: NullableStringFieldUpdateOperationsInput | string | null
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastageType?: NullableStringFieldUpdateOperationsInput | string | null
    wastageValue?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUpdateWithoutJobcardInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutReceivedSectionsNestedInput
    goldsmith?: GoldsmithUpdateOneWithoutReceivedNestedInput
  }

  export type ReceivedsectionUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    goldsmithId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    goldsmithId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUpdateWithoutJobcardInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    wastageValue?: FloatFieldUpdateOperationsInput | number
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    wastageValue?: FloatFieldUpdateOperationsInput | number
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    wastageValue?: FloatFieldUpdateOperationsInput | number
    netWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastagePure?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUpdateWithoutJobcardInput = {
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutTotalsNestedInput
  }

  export type TotalUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneTotalWt?: NullableFloatFieldUpdateOperationsInput | number | null
    openingBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    jobCardBalance?: NullableFloatFieldUpdateOperationsInput | number | null
    receivedTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isFinished?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deductionCreateManyItemDeliveryInput = {
    id?: number
    type?: string | null
    weight?: number | null
    stoneWt?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deductionUpdateWithoutItemDeliveryInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWt?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deductionUncheckedUpdateWithoutItemDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWt?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deductionUncheckedUpdateManyWithoutItemDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWt?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawGoldLogsCreateManyRawGoldStockInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
  }

  export type RawGoldLogsUpdateWithoutRawGoldStockInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateWithoutRawGoldStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    givenGold?: givenGoldUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receivedSections?: ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    billReceive?: billReceivedUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    receiptVoucher?: receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutRawGoldLogsNestedInput
    expenseTracker?: ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsNestedInput
  }

  export type RawGoldLogsUncheckedUpdateManyWithoutRawGoldStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type givenGoldCreateManyRawGoldLogsInput = {
    id?: number
    goldsmithId?: number | null
    jobcardId?: number | null
    weight?: number | null
    touch?: number | null
    purity?: number | null
    finaltouch?: number | null
    finalPurity?: number | null
    copperPurity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateManyRawGoldLogsInput = {
    id?: number
    weight?: number | null
    touch?: number | null
    purity?: number | null
    jobcardId: number
    goldsmithId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type billReceivedCreateManyRawGoldLogsInput = {
    id?: number
    billId?: number | null
    customer_id: number
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type receiptVoucherCreateManyRawGoldLogsInput = {
    id?: number
    customer_id: number
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyRawGoldLogsInput = {
    id?: number
    date: Date | string
    type: string
    gold?: number | null
    amount?: number | null
    goldRate?: number | null
    purity?: number | null
    touch?: number | null
    customerId: number
    createdAt?: Date | string
  }

  export type ExpenseTrackerCreateManyRawGoldLogsInput = {
    id?: number
    gold?: number | null
    touch?: number | null
    purity?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldUpdateWithoutRawGoldLogsInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutGivenGoldNestedInput
    jobcard?: JobcardUpdateOneWithoutGivenGoldNestedInput
  }

  export type givenGoldUncheckedUpdateWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUncheckedUpdateManyWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    finaltouch?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    copperPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUpdateWithoutRawGoldLogsInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutReceivedNestedInput
    goldsmith?: GoldsmithUpdateOneWithoutReceivedNestedInput
  }

  export type ReceivedsectionUncheckedUpdateWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    jobcardId?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    jobcardId?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedUpdateWithoutRawGoldLogsInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneWithoutBillReceiveNestedInput
    customers?: CustomerUpdateOneRequiredWithoutBillReceiveNestedInput
  }

  export type billReceivedUncheckedUpdateWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedUncheckedUpdateManyWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type receiptVoucherUpdateWithoutRawGoldLogsInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutReceiptVoucherNestedInput
  }

  export type receiptVoucherUncheckedUpdateWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type receiptVoucherUncheckedUpdateManyWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutRawGoldLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseTrackerUpdateWithoutRawGoldLogsInput = {
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseTrackerUncheckedUpdateWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseTrackerUncheckedUpdateManyWithoutRawGoldLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateManyBillInput = {
    id?: number
    productName: string
    count?: number | null
    weight?: number | null
    stoneWeight?: number | null
    afterWeight?: number | null
    percentage?: number | null
    finalWeight?: number | null
    createdAt?: Date | string
  }

  export type billReceivedCreateManyBillInput = {
    id?: number
    customer_id: number
    logId?: number | null
    date?: string | null
    type?: string | null
    goldRate?: number | null
    gold?: number | null
    touch?: number | null
    purity?: number | null
    receiveHallMark?: number | null
    amount?: number | null
    createdAt?: Date | string
  }

  export type OrderItemsUpdateWithoutBillInput = {
    productName?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    afterWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUncheckedUpdateWithoutBillInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    afterWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUncheckedUpdateManyWithoutBillInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    stoneWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    afterWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    finalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedUpdateWithoutBillInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutBillReceiveNestedInput
    rawGoldLogs?: RawGoldLogsUpdateOneWithoutBillReceiveNestedInput
  }

  export type billReceivedUncheckedUpdateWithoutBillInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billReceivedUncheckedUpdateManyWithoutBillInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    logId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    goldRate?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    receiveHallMark?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}